# **구조 패턴**

구조 패턴은 생성패턴과 달리 구조를 확장하기 위한 관점으로 설계된 패턴모음이다. 구조 패턴은 상속보다 합성을 통해 다양한 객체 확장 방법을 제안한다.

<br>

> **확장**

클래스는 하나의 책임(역할)으로 설계한다. 하지만 하나의 책임만으로는 전체 기능을 구현할 수 없다.

- 단일 책임은 클래스의 행동을 분리하는 설계원칙이다.
- 여러개로 분리된 책임과 행동은 서로 관계를 맺고 주어진 행동을 해결한다.(다수의 클래스에 책임을 분산하고, 문제를 해결하기 위해 다시 분리된 책임들을 상호 결합한다.)
- 객체 지향 개발은 클래스를 결합하여 더 큰 객체로 확장한다.

<br>

> **상속**

상속은 객체를 확장하는 방법이다.

- 상속을 이용하여 객체를 확장하면 상위 클래스에서 정의된 객체의 속성과 동작을 모두 포함하게 된다.
- 이는 정적인 결합을 통해 객체를 확장한다.(정적 상태의 결합은 대형 프로그램을 개발하고 유연한 작업을 하는데 한계가 존재한다.)
- 상속은 필요한 행위와 불필요한 행위도 모두 함께 존재한다.
- 상속은 강력한 결합력 때문에 고객의 요청을 반영하여 코드를 유지보수 하는데 어렵게 한다.

<br>

> **합성**

상속 결합의 단점을 보완하기 위한 기법으로 객체 합성을 사용한다. 합성이란 하나의 객체가 다른 객체를 포함하는 것을 말한다. 

- 합성은 강한 의존 관계를 줄이고 유연한 구조로 변경할 수 있다. 또한 실행 중에도 객체를 확장할 수 있다.
- 합성을 이용한 객체 확장은 자원을 보다 효율적으로 사용할 수 있게 된다.

<br>

> **재사용**

코드는 단계별로 발전하면서 기존의 코드를 재사용하는데, 코드를 재사용하면 많은 시간과 노력을 줄일 수 있다.

- 하지만 모든 코드를 재사용 할 수는 없다.(다양한 변화요인(코드스타일변화, 사회적변화 등)때문에 불가능하다.)
- 코드를 재사용하기 위해서는 변환(변형) 작업이 필요하다.
- 코드 변환 작업은 내부의 기능적 요인보다 외부적인 인터페이스를 변환하는 작업이 많다.

<br>

> **보정 코드**

보정코드는 발생한 오류를 수정하고 기능을 변경하는데, 보정 코드를 만드는 방법은 매우 다양하며, 보정코드는 조건을 다르게 처리하여 코드를 호출한다.

- 소스에서 보정된 코드가 많으면 가독성이 떨어지므로 이런 경우 별도의 객체를 생성하여 보정을 처리하는 것이 좋다.
- 보정만을 위해 설계된 패턴이 `Adapter` 패턴이다.

<br>

> **상속**

![class-layer.png](/img/class-layer.png)

객체지향에서 상속은 **부모와 자식 형태**의 관계로 설명한다.

- 상속이란 **상위클래스의 속성(기능)을 포함하는 서브객체를 의미**하며, **기존의 모든 기능을 갖고 있으며 새로운 기능을 추가하는 확장의 개념**이다.
- 하위 클래스가 상위 클래스를 상속 받으면 하위 클래스는 상위 클래스의 모든 메서드와 프로퍼티를 사용할 수 있다.
- 상속은 클래스를 통한 객체의 확장이며, 클래스가 다른 클래스를 상속 받는다는 의미는 클래스간 계층을 만든다는 것이다.
- 상속은 계층적 특성과 함께 기존 클래스의 책임을 포함하는 **상하관계**를 갖게 된다.
- 상속을 하면 구현과 추상 개념이 영구적으로 결합된다.(향후 상속된 클래스를 수정하거나 확장하기 어렵다. 즉 **기능을 상속으로 확장하면 최종 클래스가 무거워 진다.**)
- 상속은 클래스의 계층을 분리하고 기능을 확장하지만 **강력한 결합 관계와 불필요한 메서드도 상속에 같이 포함**되는 단점이 존재한다.

<br>

> **다중 상속**

![multiple_inheritance.png](/img/multiple_inheritance.png)

하나의 클래스가 2개 이상의 클래스에서 상속되는 것을 말한다.

- **다중 상속에서는 클래스의 메서드 충돌이 발생**하며, 2개 이상의 클래스에서 동일한 메서드명을 사용할 경우 어느 것을 기준으로 해야 하는지 판달할 수 없다.

<br>

> **위임**

**상속으로 인한 강력한 결합 관계(종속된 관계)의 문제를 해결**하기 위해, 위임을 사용한다. 위임은 작성한 코드를 다양하게 사용할 수 있도록(독립적인 확장이 가능) 강력한 결합관계를 줄이고 **느슨한 결합 관계로 변경**한다.

- 위임을 통해 객체의 구성을 복합 객체 구조로 변경한다.

<br>

> **계층 분리**

유지보수가 많아진 코드는 객체 내에 구현과 추상이 복잡하게 섞여있다. 따라서 여러 군데에 흩어진 기능과 구현을 정리하는 것이 필요하다.
**잘 설계된 계층은 클래스의 동작을 쉽게 이해하고 동작 수행을 예측하는데 수월**하다.

- 클래스의 계층을 설계할 때는 새로운 기능을 **생성하기 위한 것**인지, **역할 분담을 위한 것** 인지 판단해야 한다.
- **인터페이스**를 이용화여 계층화된 **클래스를 분리**한다.(***분리된 객체는 동일한 호출 명령을 할 수 있도록 같은 인터페이스를 각 클래스에 적용한다.***)

<br>

> **추상 계층**

추상 계층은 **각각의 계층이 독립적으로 확장/변경 가능하도록 하기 위함** 이다.

- 브리지 패턴은 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.

<br><hr>

## **패턴**

구조 패턴은 크게 구조 클래스 패턴(structural class pattern) 과 구조 객체 패턴(structural object pattern)으로 나눌 수 있다.

<br>

> **구조 클래스 패턴(structural class pattern)**

- **Adapter Pattern**

    어댑터 패턴은 인터페이스를 추상화하여 서로 다른 인터페이스를 통일화 한다. 상속을 통한 어댑터와 합성을 통한 어댑터로 구분한다.

<br>

- **Bridge Pattern**

    개념과 추상을 구분하여 처리한다. 또한 객체의 독립으로 확장과 변형이 가능하다.

<br>

- **Composite Pattern**

    객체의 구조를 이용하여 객체를 확장한다. 복합 객체는 트리 구조의 특징을 갖고 있다.

<br>

- **Decorator Pattern**

    객체에 기능을 동적으로 추가한다. 확장 시 객체에 새로운 책임을 부과할 수 있다. 재귀적 합성 방법을 응용하여 객체를 확장한다.

<br>

- **Facade Pattern**

    파사드는 복잡한 객체의 구조와 접근을 간단하게 표현하는 방법이다.

 <br>

 - **Flyweight Pattern**

    플라이웨이트 패턴은 객체를 공유한다. 객체 공유를 통해 자원의 효율성과 공유된 객체의 일관성을 보장한다.

 <br>

 - **Proxy Pattern**

    객체의 접근을 제한할 수 있다. 객체를 엑세스할 때 추가적인 책임을 부여하는 역할을 수행한다.