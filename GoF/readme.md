# **Design Pattern**

>### **공부하게 된 배경**

소프트웨어 개발은 다음의 과정들을 반복하게 된다.

- 요구사항 분석
- 설계
- 구현
- 테스트

그 중 **설계 부분**을 **올바르고 효과적**으로 하기 위해 디자인 패턴을 적용한다.

소프르 웨어 설계 간, 클래스 간의 최적의 관계를 효과적으로 설계할 수 있는 하나의 사례를 공부하여 여러 관점을 이해하고 만들기 위해서 공부한다.

큰 프로젝트 개발과 유지 보수를 보다 쉽게 하기 위해 공부한다.

<br><hr>

## **디자인 패턴**

*디자인 패턴이란, 소프트웨어 설계 방법으로 반복되는 패턴처럼 자주 나타나는 클래스 간의 관계를 맺는 방법을 말한다.*

- 디자인 패턴의 구분은 각각의 패턴이 어떤 관심사를 가지고 문제를 해결하려는가 하는 것이다.

    *클래스 간의 관계는 클래스 다이어그램을 통해 나타낸다.*

- **구조만으로 패턴을 파악하는 것은 불가능**하며 패턴을 파악하려면 **의도** 와 **목적** 을 잘 파악하는 것이 중요하다. 

- 디자인 패턴은 외우거나 그대로 이렇게 적용하는 것이 아니다.(이해를 하는 것이 중요하다.) 클래스 간의 최적의 관계를 효과적으로 설계할 수 있는 하나의 사례일 뿐이다.

- 패턴은 문제를 해결하는 과정을 일반화 한 것이라 할 수 있으며, 하나의 패턴이 또 다른 패턴에 중복적으로 사용되는 경우가 존재한다.

<br>

**디자인 패턴을 여러가지 관점에서 변형하고, 서로 혼합하여 소프트웨어 설계에서 활용하자.**

<br>

>### **디자인 패턴의 필요성**

- 클래스는 최소한의 단위를 가진다.
- 큰 기능은 이러한 단위 기능을 갖는 클래스 간의 관계를 통해 개발된다.
- 꼭 필요한 것들만으로 구성된 최적화된 소프트웨어 개발이 용이하다.
- 문제 발생 시 최소한의 코드 수정으로 유지보수가 용이하다.
- 기존 기능에 영향을 주지 않고 새로운 기능 추가가 용이하다.

<br>

> ### **디자인 패턴의 종류**

- 총 23개의 패턴으로 구성되며 **생성패턴(5개)**, **구조 패턴(7개)**, **행위 패턴(11개)** 로 분류한다.

<br>

- **생성 패턴**
  - Factory Method
  - Abstract Factory
  - Builder
  - Prototype
  - Singleton

<br>

- **구조 패턴**
  - Adapter
  - Bridge
  - Composite
  - Decorator
  - Facade
  - FlyWeight
  - Proxy

<br>

- **행위 패턴**
  - Interpreter
  - Templete Method
  - Chain of Responsibility
  - Command
  - Iterator
  - Mediator
  - Memento
  - Observer
  - Strategy
  - Visitor

<br><hr><br>

## **참고사항**

- 클래스 다이어그램 관련

    ![diagram-explain.png](/img/diagram-explain.png)

<br><hr><br>

## **목표**

각 패턴의 **문제(Problem)**, **해법(Soloution)**, **결과(Consequence)** 을 정리하여 패턴을 이해한다.

유지 보수성을 고려하는 코드를 작성한다. -> 문제 해결 방법외에도 개발 비용과 시간을 절약 할 수 있는 코드를 작성한다.

- **문제(Problem)**

    문제는 패턴 적용을 고려해야하는 시점을 말한다. 코드에서 해결할 문제점을 발견한 후 그와 관련된 여러 배경을 먼저 정리한다.
    그 후 이러한 문제점을 해결할 수 있는 다양한 적용 사례를 찾아본다.

<br>

- **해법(Soloution)**

    문제점에 대한 해결방법을 찾기 위해 객체 요소 간 관계를 정리한다.
    패턴은 객체들을 추상화하는 과정을 거치며, 해결을 위한 객체를 나열한다.

<br>

- **결과(Consequence)**

    디자인 패턴을 적용한다고 해서 모든 문제를 완벽하게 제거할 수는 없다. 하지만, 디자인 패턴은 다양한 문제를 해결할 수 있는 선배 개발자의 경험이다.

    하지만 패턴은 유용 하지만, 꼭 필요한 경우를 생각하여 적절히 분배하여 사용해야한다.