# **Builder 패턴**

![builderExample.png](/img/builderExample.png)

|Builder|내용|
|---|---|
|**목적**|복잡한 구조의 복합 객체를 생성하는 로직을 별도로 분리하여 객체 생성을 처리한다. Abstract Factory 에서 유사한 객체의 제품군을 알고리즘화 하여 다양한 복합 객체를 생성, 관리하는 용도로 사용하기 위해 사용한다.|
|**설명**|Abstract Factory 패턴을 확장한, 복합 객체의 생성 과정을 단계별로 분리하여 복합 객체의 생성을 일반화 하는 패턴을 말한다. Builder 패턴은 생성 단계를 중점으로 설계한다.(Abstract Factory 패턴은 유사한 객체의 생성 과정을 중심으로 제품군을 설계한다. Builder 패턴은 만들고자 하는 부품이 모여야 의미가 있으나, Abstract Factory 패턴은 각각의 부품에만 의미를 부여한다.|
|**방법**|추상화를 통해 다양한 종류의 복합 객체를 생성 관리한다. (추상화를 통해 공통된 로직을 분리한다.) 관계된 서브 객체의 단계별 생성 절차가 완료된 후 복합객체를 생성 및 반환한다.|
|**장점**|동적으로 객체를 확장 할 수 있다. 추상화를 통해 다양한 복합객체를 생성할 수 있다.|
|**단점**|계층적인 구조 관계로 인해 생성하는것이 쉽지 않다.(이는 구조에 맞게 생성 과정을 분리하여 처리하는 방법을 통해 극복 가능하다.)|
||

`Builder` 패턴은 복잡한 구성의 객체를 효과적으로 생성하는 패턴을 말한다.

Factory 패턴 또한 요청한 객체의 생성 과정을 분리하지만, Factory 패턴은 단일 클래스의 객체만 생성, 반환 하므로 요청된 객체가 복합 객체일 경우 팩토리 패턴을 적용할 수 없다.

복합 객체는 동적으로 객체를 확장할 수 있다. 하지만 계층적인 구조 관계를 나타내어, 생성하는 것이 쉽지 않다.
복합 객체의 구조는 종속적이며, 종속된 순서의 역순으로 객체를 생성하여 결합해야한다.

따라서, 복합 객체에는 구조에 맞게 객체를 생성하고 관계를 설정하는 로직이 필요하다.(이러한 코드는 클라이언트 안에 작성한다. 일반 코드로 작성할 시, 객체 생성과정을 효율적으로 관리하기 어렵다.)

복합 객체의 생성 로직은 직접 클라이언트 코드로 구현하거나 메서드를 호출하지 않고, 독립적인 단계별 구축 공정을 분리하여 처리한다.

- 복합 객체를 만들기 위한 단계별 과정은 추상 클래스를 통해 해당 과정을 약속하고, 빌더 패턴은 약속된 생성 과정만 호출한다.
- 혹은 생성 로직을 별도의 알고리즘으로 분리하여 외부로 부터 주입 받을 수 도 있다.
- 다양한 종류의 복합 객체 생성 로직을 구분하고, 추상 메서드와 외부 알고리즘을 통해 객체의 실제 생성 로직을 외부로 부터 숨기는 효과가 있다.

<br>

1개의 빌더로 다양한 종류의 복합 객체를 생성하기 위해 생성로직을 분리하는 것이 좋다.

- Builder 클래스는 어떤 복합 객체가 만들어지는 지 알 수 없으며, 미리 약속된 동작으로만 객체 생성 과정을 호출하고, 실제 객체는 알고리즘에 의해 생성된다.(전달되는 알고리즘을 교체하여 다양한 복합객체를 동적으로 생성할 수 있다.)
- 알고리즘 패턴으로 Strategy 패턴(전략패턴)을 이야기 할 수 있다.

*전략 패턴은 외부에서 처리 객체를 전달 받아 수행하는 패턴을 말한다.*

<br>

>Builder 그룹 형성

Builder 패턴은 추상화의 다형성을 이용하여 그룹별로 복합 객체의 종류를 설계할 수 있다. 추상화를 통해 객체의 생성그룹A 와 그룹 B 형태로 분리할 수 있다. 

- 분리된 생성 그룹을 빌더 패턴의 인자로 전달하여 선택된 그룹에서 선언 및 구현된 메서드만을 이용하여 복합 객체를 생성한다.

<br>

> **`Builder` 패턴을 사용하는 경우**
- 생성 시 지정해야 할 인지가 많을 때 사용한다.
- 객체 생성 시 여러 단계를 순차적으로 거칠 때, 이 단계의 순서를 결정해 두고 각 단계를 다양하게 구현할 수 있을 경우

<br><hr><br>

## **예제 코드**

<br>

### **코드 구조**
Builder1
![Builder1.png](/img/Builder1.png)

<br>

- ### **설명** 

    - `Car` 클래스는 실제로 생성하고자 하는 클래스이다.

    <br>

    - `CarBuilder` 클래스는 Car 객체를  생성해주는 Builder 클래스이다.
    `Car` 클래스를 생성할 때, 생성자의 인자에 `Car` 를 구성하는 스펙 항목들을 지정받게 된다.여기서는 총 6개의 인자를 받는다.

    `Car` 클래스를 생성하는 방법은 2가지이다.
    1. new 키워드와 함께 `Car` 클래스를 생성하는 방법
    2. `CarBuilder` 클래스를 이용하는 방법

<br><hr><br>

### **코드 구조**
Builder2
![Builder2.png](/img/Builder2.png)

<br>

- ### **설명** 

    - `Builder` 클래스는 추상 클래스이며, 무언가를 만드는 책임을 갖는다.
        무언가를 만들어 반환하는 메스드 들을 제공해야 하며, 이 메서드들은 추상메서드 이다.

    <br>

    - `Director` 클래스는 Builder 에서 제공하는 메서드들을 정해진 순서대로 정확하게 호출해야 할 책임을 갖는다.

    - `Builder` 추상클래스를 구현하는 `PlainTextBuilder`,       `JSONBuilder`, `XMLBuilder` 클래스들은 무언가를 만드는 `Builder` 클래스에 추상 메서드들을 구체적으로 구현한다.

    <br>

    - `PlainTextBuilder` 는 어떠한 텍스트 객체, `Data` 객체를 평이한 텍스트 형태의 문자열로 바꾼다.

    - `JSONBuilder` 는  `Data` 객체를 JSON 형태의 문자열로 만든다.

    - `XMLBuilder` 객체는 `Data` 객체를 XML 형태의 문자열로 만든다.
    
    <br>

    - `Builder` 패턴은 `Template`, `Facade`, `Strategy` 패턴을 객체의 생성에 적용한 것이라고 볼 수 있다. 

    - `Director` 가 `Facade` 패턴에 관한 것으로 `Builder` **객체의 메서드들의 사용을 단순화** 시켜주고 있다.

    - `Builder` 를 통해서 무언가를 생성해 낼 때, **호출되는 메서드들을 추상메서드로 선언하고, 각 메서드를 구현 클래스에서 구현하고 이를 메서드들의 호출 방식**은 `Director` 클래스에서 정해놓은 것은 `Template` 패턴의 응용에 해당한다.

    - **원하는 상황에 맞는 형식의 문자열로 변환하는 것**은 `Strategy` 패턴의 적용에 해당한다.