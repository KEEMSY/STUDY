# **생성 패턴**

![CreationalPatternExample.png](/img/CreationalPatternExample.png)

<br>

생성패턴의 주요 목적은 객체의 생성 과정을 한 곳에 집중화 하는 것이다. 패턴을 사용하여 객체를  생성 관리하는 이유는 인스턴스화 과정에서 발생하는 강력한 의존 관계를 해소하기 위함이다.

생성패턴은 객체 간 강력한 결합 관계를 **느슨한 결합으로 변경하는 설계기법**을 말한다. 느슨한 결합으로 변경된 객채는 **확장**을 보다 유연하게 하고 **유지보수성**을 편리하게 한다.

작성로직에서 **직접 객체를 생성**하고 **관계를 설정하**면 코드는 **객체 간에 매우 강력한 결합 관계**를 갖게 된다. 그리고 이 **종속 관계**를 가진 객체는 향후 (확장과 유지보수를 어렵게) 하는 원인이 된다.

생성패턴은  객체 생성을 위임하여 ***별개의 클래스*** 로 분리하고, 객체 생성 과정을 담당할 별도의 클래스를 선언한다.

- **별개의 클래스**는 필요한 객체를 **생성**하고 **관리**하는 **캡슐화된 클래스**를 말한다.
- 생성 패턴은 **목적과 과정**에 외에 **매개변수**에 의한 생성 방법과 **합성**에 의한 객체 생성 방법으로도 구분된다.

<br>

> **인스턴스화**

객체를 생성화는 과정에는 컴파일, 인터프리터 과정에서 선언된 클래스에 다른 객체를 생성하고 이를 메모리에 할당한다.
이러한 객체를 생성하는 과정을 인스턴스화 라고 한다. 그리고 인스턴스화를 통해 생성된 객체를 인스턴스라고 한다.

- 객체지향에서 객체는 단일객체, 복합객체 2종류의 객체가 존재한다.
- 객체는 데이터와 행동을 가지며, 때로는 객체를 확장하기 위해 상속 구조를 적용한다.

*인스턴스와 객체는 같은 말이며, 인스턴스화는 선언된 클래스를 이용하여 실제 메모리에 할당할 객체를 생성하는 과정을 말한다.*

<br>

> **의존성**

**객체의 관계**는 객체가 **서로 결합한다**는 의미이다. 그리고 이 객체 간 결합을 **의존성**이라고 한다.

- 의존은 객체지향에서 객체의 관계를 설정해야하는데, 이는 해결해야하는 기능과 연관된 책임을 **캡슐화**로 분배한다.

즉, 객체 내부에서 다른 객체를 생성하면 두 객체 사이에 **의존성**이 발생한다.

- **의존성은 객체를 생성할 때마다 발생**한다. 그리고 **코드에서 직접 생성한 객체**는 **의존성이 매우 강력**하여 유지보수와 수정을 어렵게 한다.

*외부에 의해 결합 관계가 발생하는 것을 **의존성 주입** 이라한다. 의존성 주입이 발생되면 객체는 일반이 아닌 복합 객체의 형태를 갖게 된다.*

<br>

> **복합객체**

복합객체는 하나의 객체가 다른 객체의 정보를 가진 구조를 말한다.

![is-a_Class.png](/img/is-a_Class.png)
전형적인 클래스의 확장 방식은 **상속**이다.

- 상속은 is-a 관계로 포괄하여 더 큰 규모의 객체를 생성한다.
- 강력한 상하 결합 관계와 불필요한 모든 행위까지 포함된다는 단점이 존재한다.

<br>

![complexClass.png](/img/complexClass.png)

객체지향에서는 상속의 단점을 보완하기 위해 **의존성 주입**을 사용한다. 의존성 주입을 통한 복합 객체는 생성된 후에도 다른 객체와의 관계를 설정해 동적 확장 할 수 있다.

- 종속적이고 연관 관계를 갖게된다.
- 외부에서 전달받은(의존성 주입) 객체(정보)를 내부 프로퍼티에 저장함으로써 복합 구조 형태로 변경한다.(복합 객체의 구성은 의존성 주입 형태가 권장된다.)
- 의존성 주입이 이루진 객체의 접근 권한을 private(혹은 protected)으로 설정 할 경우, getter/setter 메서드를 추가해야 한다.

<br>

>**매개변수에 의한 생성방식**

- 상속을 통해 서브 클래스에서 객체 생성을 담당한다.
- `Factory Method` 패턴이 대표적이다.

<br>

>**합성에 의한 생성방식**

- 3가지 패턴이 존재하나, 객체를 생성하는 관점의 차이가 존재한다.
- `Abstract Factory` : 여러 클래스의 군의 생성에 관점을 둔다.
- `Builder` : 객체를 생성하는 복잡한 과정에 관검을 둔다.
- `Prototy` : 어렵게 만들어진 객체의 중복 처리 자원을 배제하고 복사본을 통해 간편하게 처리함에 관점을 둔다.

<br>

>**스코프(scope)**

변수의 접근 영역 구분을 말한다.

- 스코프는 전역 변수, 로컬 변수로 구분되는 기준이 된다.
- 스코프의 변수 범위를 잘못 관리한다면, 사이드 이펙트(부작용)으로 오작동이 발생하고, 디버깅에 많은 어려움을 겪을 수 있다.

<br>

>**정적클래스**

![staticclass.png](/img/staticclass.png)

- 정적클래스는 다형성을 위한 인터페이스를 사용할 수 없다.
- 객체 생성 없이 클래스 선언을 통해 프로그램을 실행한다.
- 소스코드를 이용하여 여러개의 객체로 인식되지 않는다.
- 객체를 메모리에 생성하지 않아 메모리 관리에 효율적이다.
- 코드가 실행되면서 고정으로 바인딩 된다.

<br><hr>

## **추상화**

추상화는 실제 코드를 개발하기 전에 **구체적인 내용은 배제하고 개략적인 정보만 선언하는 것**을 말한다. 추상화로 선언된 코드는 실제 내용이 없어도 미리 선언된 정보만 이용하여 코드를 작성할 수 있다.

추상화는 인터페이스의 특징을 이용해 실제적 객체의 생성 동작을 하위 클래스로 위임하고, 하위클래스는 상위 추상 클래스에서 선언된 인터페이에 따라 메서드를 구현한다. 

- 구현되는 메서드는 상위 추상 메스드를 오버라이드 한다.
*추상 메서드는 인터페이스와 유사한 역할을 한다.*
- 추상화에서 가상은 인터페이스를 적용하고 실제 객체 생성은 하위 클래스에서 담당하는 것을 말한다.

<br>

추상화 작업은 **추상적 개념과 실제 코드를 분리**하는 효과가 있다.

추상적 선언은 하위 클래스에서 적용되는 인터페이스와 유사하며, 하위 클래스에 필요한 공통 내용을 포함한다.

- 하위클래스는 추상화된 상위 클래스를 상속받고, 추상 메서드는 상위 클래스에서 정의한 인터페이스에 따라 하위클래스에서 오버라이드(실제 동작하는 메서드의 내용으로 구현)된다.
- 이를 통해 실제 동작하는 구현부를 외부로 부터 감출 수 있으며, 이러한 특성을 **`은닉성`** 이라고 한다.

<br>

> **추상클래스**

![NomalVS.Abstract.png](/img/NomalVS.Abstract.png)


일반적인 상속은 상위 클래스의 내용을 포함하는 객체의 확장이지만, 추상 클래스의 상속은 하위 클래스에서 구체적 행위를 규정하는 선언이다.

- 추상화는 하위클래스에 다형성을 부여한다. 다형성을 통해 형태와 틀은 같지만 실제 처리 내용은 다르게 클래스를 만들 수 있다.
- 다형성을 적용하면 여러개의 하위 클래스를 만들어야 한다는 단점도 존재한다.
- 매개변수를 통해 생성을 선택적으로 처리하는 방법을 사용하면 추상화와 다형성의 단점을 보완할 수 있지만, 다형성을 완전히 배제할 수는 없다.

<br>

> **다형성**

추상화는 다형성을 적용해 여러 개의 하위 클래스를 생성할 수 있다. 

- 다형성을 적용하기 위해 추상 클래스를 상속 받는다.
- 상속받은 하위 클래스는 위임된 동작을 다르게 정의할 수 있는 객체로 만들 수 있다.(상속을 통해 다형성을 적용한다.)
- 이는 하위 클래스가 하나의 군으로 형성될 수 있음을 의미한다.

<br><hr>

## **패턴**

생성 패턴은 목적과 과정에 따라 **6가지**로 분류된다.

![creational.png](/img/creational.png)

- **`Factory Pattern`**

    객체의 생성 동작을 별도 클래스로 분리하여 처리한다. 또는 별도의 메서드를 호출하여 객체의 생성 동작을 처리한다.

    단일 객체를 사용한다.

<br>

- **`Sigletone Pattern`**

    선언된 클래스로 복수의 객체를 생성할 수 없도록 제한한다. 제한된 단일 객체는 공유화 충돌을 방지한다.

<br>

- **`Factory Method Pattern`**

    팩토리를 확장한 패턴이다. 팩토리 패턴에 추상화를 결합하여 객체의 생성과 사용을 분리한다. 팩토리 패턴은 선언된 클래스의 객체를 직접 생성하지 않고 별도로 준비한 추상 메서드에 생성을 위임한다.

    단일 객체를 사용한다.

<br>

- **`Abstract Factory Pattern`**

    팩토리 메서드를 확장한 패턴이다. 팩토리 메서드보다 좀 더 큰 그룹 단위 객체를 생성 관리한다. 추상 팩토리 패턴은 팩토리에 인터페이스를 적용하여 객체를 생성한다. 팩토리를 팩토리의 군(family)로 변경한다.

    단일 객체를 사용한다.

<br>

- **`Builder Pattern`**

    추상 팩토리를 확장한 패턴이다. 복잡한 구조의 복합 객체를 빌더 패턴으로 생성한다. 복합 객체를 생성하기 위한 단계를 정의하고, 각 단계별 수행동작을 변경할 수 있다.

<br>

- **`Prototype Pattern`**

    새로운 객체를 생성하지 않고 기존의 객체를 복제한다. 복잡한 구조의 객체를 새로 생성하는 것은 많은 자원을 소모하는데 프로토타입 패턴은 객체를 새로 생성하지 않고 복제를 통해 자원을 절약하는 패턴이다.