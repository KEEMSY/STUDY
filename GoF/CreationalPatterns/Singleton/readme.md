# **Singleton 패턴**

![SigletonExplaination2.png](/img/SigletonExplaination2.png)

<br>

> ### **요약**

|Singleton|내용|
|---|---|
|**목적**|객체 생성을 1개로 제한하여, 해당 객체의 중복된 생성으로 인한 자원의 손실을 방지한다.|
|**설명**|하나의 클래스 타입에 대하여 자원 공유를 위해 오직 1개의 객체만이 생성되도록 보장하는 패턴을 말한다. 그리고 생성된 객체는 공유되어 어디서든 접근할 수 있다.|
|**방법**|생성자를 제한하고, 참조체 및 생성 메서드를 만든다.(정적프로터피와 정적 메서드를 사용한다.)|
|**장점**|중복된 객체생성으로 인한 자원의 손실을 방지할 수 있다.|
|**단점**|책임을 2가지를 갖는 객체이므로 객체 지향원칙에 어긋나며, 안티패턴으로 분류 되기도 한다.|
||

**하나의 클래스** 타입에 대해서 오직 **하나의 객체만**이 생성되도록 보장해주는 패턴이다.

`Singleton` 패턴이 적용된 클래스의 객체는 **다른 클래스들에서 접근**할 수는 있지만 **생성은 할 수 없다.**(`Singleton` 패턴은 **객체 생성을 제한**한다.)

- new 키워드를 통해 객체를 생성할 때, 서로다른 A, B 객체가 생성되는 것이 아니라 동일한 객체 1개만 유지함을 의미한다.

<br>

> **Singleton 패턴이 유용한 상황**

- 공유 자원 접근
- 복수의 시스템이 하나의 자원에 접근할 때
- 유일한 객체가 필요할 때
- 값의 캐시가 필요할 때

`Singleton` 은 객체의 관계 속에서 상호 작용하기 위한 값을 저장하고 전달하는데, **값을 전달하기 위해**서는 **공용 객체가 필요**하다.
`Singleton` 패턴은 **new 키워드를 이용해 객체를 생성하는 방법을 원천적으로 금지**한다. 대신 **객체를 생성할 수 있는 메서드를 추가**하며, new 키워드 대신 **생성 메서드 호출만으로 객체를 생성** 할 수 있다.

**내부의 참조체를 통해 자신의 객체를 보관**한다.(내부적으로 **중복 생성을 방지하는 로직(`Flyweight` 패턴)이 존재**한다.
참조체를 통해 **자신의 객체가 생성되었는지 판단**한다.

`Singleton` 패턴을 적용하면 참조제를 통해 하나의 객체만 갖도록 보증하지만, **상속과 복수 객체를 생성할 수 있는 객체지향의 장점을 잃게 된다.**(*이는 접근 권한을 수정하여 어느 수준 보완 가능하다.*)

<br>

> **Singleton 패턴을 이해하기 위해서는 객체의 접근 권한 속성을 이해해야한다.**

- **new 키워드로 객체를 생성하지 못하도록** 해야한다.(생성자의 접근 권한을 변경(`public->private`)한다.)
- 객체를 생성하는 또 다른 방법인 **`clone` 또한 `private` 설정**을 통해 접근을 제한한다.
- **확장**을 위해 접근 권한을 `protected` 로 변경하면 상속을 통한 확장이 가능하다.
  - 객체 생성은 **상속받은 클래스의 내부 정적 메서드를 호출**해야한다.

<br>

>**Singleton이 안티패턴으로 분류되는 이유**

특수한 환경에서 **단일 객체 생성을 보장하지 못하는 경우**(멀티스레드 조건)에서 **객체 생성이 동시 요청되는 경우 경합성이 발생**한다.

- `경합조건`: 동일한 메모리나 자원을 동시에 접근하는 것을 말한다.(2개 이상의 스레드가 동일한 자원을 사용할 경우 충돌이 발생한다.)
- `경합성`: 메서드의메서드의 `원자성(atomic)`의 결여로 2개의 객체가 만들어지는 오류가 발생한다.

이 문제(경합성문제 및 멀티 스레드 환경)을 해결하기 위해 **늦은 바인딩**을 사용한다.

- `Sigleton` 은 **정적 호출을 통해 생성 호출하기 전에는 객체를 만들지 않는다.**
- 최초의 생성 호출이 발생할 때 객체를 생성하고 생성된 객체는 내부 참조체에 저장된다.(객체를 생성하여 메모리(자원)에 할당한다.)
- `늦은 초기화(lazy initialization)`: 늦은 바인딩을 통해 객체 생성을 동적으로 처리하는 것을 말한다.
- 경합성과 늦은 초기화 문제를 좀 더 보완하기 위해 **시스템 부팅 시 필요한 Sigleton 의 객체를 미리 생성**한다.(Sigleton 으로 처리 할 부분을 부팅시 미리 처리하면 참조체를 구별하는 if 문의 오작동을 방지할 수 있다.)
- 불필요한 객체를 모두 생성하여 메모리에 상주시키는 것은 **메모리 낭비의 문제**와 매번 공유 자원의 객체에 접근할 때마다 **자원 중복 여부를 체크**하는 여전한 문제점이 존재한다.
- `Sigleton` 으로 생성한 자원은 프로그램이 종료 될 때까지 메모리에 상주한다.

<br><hr><br>

## **예제 코드**

<br>

### **코드 구조**

![singleton.png](/img/singleton.png)

<br>

- ### **설명**

    `singleton` 표시를 통해 해당 객체(`King`)이 Singletone 패턴이 적용됬음을 인지한다.
