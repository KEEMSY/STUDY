# **LSP: 리스코프 치환 원칙**
*S 타입의 객체 o1 각각에 대응하는 T 타입 객체가 o2 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2 의 자리에 o1 으로 치환하더라도 P 의 행위가 변하지 않는다면 S는 T의 하위 타입이다.*

<br><hr><br>

## LSP를 준수하는(하지않는) 설계
<br>

>### **LSP를 준수하는 설계: License**
<br>

![LicenseLSP](/img/LicenseLSP.png)

`License` 클래스는 `calcFee()` 메서드를 가지며, `Billing` 애플리케이션에서 이 메서드를 호출한다. `license` 에는 `PersonalLicense` 와 `BusinessLicense` 라는 두 가지 하위 타입이 존재한다. 이들 두 하위 타입은 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다.

<br>

이 설계는 **`Billing` 애플리케이션의 행위가 `License` 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문에 LSP 를 준수한다**고 말할 수 있다.(이들 하위 타입은 모두 `License` 타입을 치환 할 수 있다.)

<br>

>### **LSP를 위반하는 설계: 정사각형/직사각형 문제**
<br>

![LSP위반](/img/LSP위반.png)

`Square` 는 `Rectangle` 의 하위 타입으로는 적합하지 않은데, Rectangle의 높이와 서비는 서로 독립될 수 있는 반면, Square의 높이와 너비는 반드시 함께 변경되기 때문이다.

```java
Retangle r
r.setW(5)
r.setH(2)
assert(r.area() == 10)
```

여기서 `assert` 은 실패하게 된다.
이런 형태의 **LSP 위반을 막기위한 유일한 방법은 (if문 등을 이용하여) `Rectangle` 이 실제로는 `Square` 인지를 검사하는 매커니즘을 `User` 에 추가하는 것**이다.
하지만 **이렇게 하면 User의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.**

<br><hr><br>

## **LSP와 아키텍처**
초창기에는 `LSP` 는 상속을 사용하도록 가이드하는 방법정도였으나, 시간이 지나 `LSP` 는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모 되었다.

**아키텍처 관점에서 `LSP` 를 이해하는 최선의 방법**은 이 **원칙을 어겼을 때 시스템 아키텍처에서 무슨일이 일어나는지 관찰하는 것**이다.

<br>

>**LSP 위배 사례**

### 상황: 다양한 택시 파견 서비스를 통합하는 애플리케이션을 만드는 상황
고객은 어느 택시업체인지는 신경쓰지않고 자신의 상황에 가장 적합한 택시를 찾는다.
고객이 이용할 택시를 결정하면, 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다.

<br>

### 시스템
- 택시 파견 `REST` 서비스의 `URI` 가 운전기사 데이터베이스에 저장되어있다.
- 시스템이 고객에게 알맞은 기사를 선택하면, 해당 기사의 레코드로부터 URI 정보를 얻은 다음, 그 `URI` 정보를 이용하여 해당 기사를 고객위치로 이동시킨다.

<br>

>***예시***

`purplecab.com/driver/Bob` 
- 택시기사인 밥(Bob)의 택시 파견 URI 이다.

<br>

`purplecab.com/driver/Bob/pickupAddress/24 Maple St./pickuipTime/153/destination/ORD`
- 시스템은 URI에 파견에 필요한 정보를 덧붙여 `PUT` 방식으로 호출한다.

<br>

**` 이 예시에서 분명한 점은 파견 서비스를 만들 때 다양한 택시 업체에서 동일한 REST 인터페이스를 반드시 준수하도록 만들어야 한다는 것이다. 다른 택시 없체가 pickupAddress, pickupTime, destination 필드를 모두 동일한 방식으로 처리해야 한다.`**

### **상황**
택시업체 애크미(ACME) 에서 `destination` 필드를 dest 로 축약하여 사용하였다. 이로인해 우리 아키텍처에서는 이 예외 사항을 처리하는 로직을 추가해야만 한다.

### **방법**
1. 파견 명령어를 구성하는 모듈에 if 문장을 추가한다.

    `if (driver.getDispatchUri().startWith("acme.com"))`

    "acme"라는 단어를 코드에 추가하면, 보안에 침해되며, 이해할 수도 없는 온갖 종류의 에러가 발생할 여지를 만들게 된다.
    
    <br>

2. 파견 `URI` 를 키(key)로 사용하는 설정요 데이터베이스를 이용하는 파견 명령 생성 모듈을 만든다.
```
URI         |      Dispatch Format
Acme.com        /pickupAddress/%s/pickupTime/%s/dest/%s
*               /pickupAddress/%s/pickupTime/%s/destination/%s
```

<br><hr><br>

## **결론**
`LSP` 는 아키텍처 수준까지 확잘할 수 있으며, 반드시 확장해야한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.