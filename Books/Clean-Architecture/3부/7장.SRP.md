# **SRP: 단일 책임 원칙**
***하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야한다.***

*이해관계자는 집단(해당 변경을 요청하는 한 명 이상의 사람들)을 말하며, 이런 집단을 책에서는 **Actor(액터)** 라고 말한다.*

<br>

- SRP는 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임 져야 한다.
- 모듈이란 소스파일을 의미한다.
    - 코드를 소스파일에 저장하지 않는 경우, 모듈이란 단순히 함수와 데이터 구조로 구성된 응집된 파일이다.

<br><hr><br>

## **원칙을 위배하는 경우**

<br>

### **징후 1. 우발적 중복**

![우발적중복](/img/우발적중복.png)

이 클래스는 SRP를 위반한다. 그 이유로는 **서로 다른 세가지 메서드가 서로 매우 
다른 세 명의 액터를 책임**지기 때문이다.

- `calculatePay()`: 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.
- `reportHours()`: 인사팀에서 기능을 저의하고 사용하며, COO 보고를 위해 사용한다.
- `save()`: 데이터베이스 관리자(DBA)가 기능을 정의하고, CTO 보고를 위해 사용한다.

<br>

이 세 메서드를 Employee 라는 단일 클래스에 배치하여 세 액터가 서로 결합되었다.
이 결합으로 인해 CFO 팀에서 결정한 조치가 COO 팀이 의존하는 무언가에 영향을 줄 수 있다.

- `calculatePay()` 메서드와 `reposrtHours()` 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다. 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours() 메서드에 넣었다. 

<br>

![공유된알고리즘](/img/공유된알고리즘.png)

<br>

- 이제 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정한다. 반면 인사를 담당하는 COO팀은 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른 목적으로 사용하기 때문에 이러한 변경을 원하지 않는 상황이다.
- CFO 팀은 새로운 메서드가 원하는 방식으로 동작하는지 검증하고, 시스템은 배포된다. (COO 팀에서는 이러한 일이 발생되고 있다는 사실을 모른다.)
- COO 팀은 reportHours() 메서드가 생성한 보고서를 계속해서 사용한다. (보고서는 엉터리다.) 시간이 흘러 문제를 발견하고, 피해를 인지한다.

<br><br>

### **징후 2. 병합**
*메서드가 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높다.*

DBA가 속한 CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 약간 수정한다. 이와 동시에 인사담당자가 속한 COO 팀에서는 `reportHours()` 메서드의 보고서 포맷을 변경하기로 결정하였다. <br>

두명의 서로 다른 개발자가 Employee 클래스를 체크아웃 한 후 변경사항을 적용하기 시작한다. 그리고 이들 변경사항은 서로 충돌하여 병합이 발생한다.

- 어떠한 도구도 병합이 발생하는 모든 경우를 해결할 수는 없다.

<br>

**이 문제를 벗어나는 방법은 서로 다른 액터를 뒷바침하는 코드를 서로 분리하는 것이다.**


<br><hr><br>

## **해결책**
*다양한 해결책이 존재하나, 해결책은 메서드를 각기 다른 클래스로 이동시키는 방식일 것이다.*

아무런 메서드가 없는 간단한 데이터 구조인 `EmployeeData` 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.
각 클래스는 자신의 메서드에 반드시 필요한 소스코드만을 포함한다.
세 클래스는 서로의 존재를 몰라야한다.(***우연한 중복* 을 피할 수 있다.**)

<br>

![SRP해결책](/img/SRP해결책.png)

<br>

이 해결책은 개발자가 세 가지 클래스를 인스턴스화 하고 추적해야한다는 단점이 존재한다.
- 이 문제를 해결하기 위해 사용하는 패턴으로 `퍼사드(Facade)` 패턴이 존재한다.
    <br>

    ![facade](/img/facade.png)

    <br>

    - `EmployeeFacade` 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

    <br>

<br>

- 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지 전혀 알 수 없다.

<br><hr><br>

## **결론**
<br>

**단일 책임 원칙은 메서드와 클래스 수준의 원칙**이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. **컴포넌트 수준에서는 공통 폐쇄 원칙(Common Closure Principle)** 이 된다. 아키텍처 수준에서는 아키텍처 경계(Architecture Boundary)의 생성을 책임지는 축(Axis of Chanage) 이 된다.