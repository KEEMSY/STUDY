# **DIP: 의존성 역전 원칙**
*의존성 역전원칙에서 말하는 유연성이 극대화된 시스템이란 소스 코드 의존성이 **추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는** 시스템이다.*

<br>

자바와 같은 **정적 타입 언어**에서는 `use`, `import`, `include` 구문은 **오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다**는 뜻이다. 구체적인 대상에는 절대로 의존해서는 안된다.

루비나 파이썬 같은 동적 타입 언어에도 동일한 규칙이 적용된다. 소스 코드 의존 관계에서 **구체 모듈은 참조해서는 안 된다.**

소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문에 DIP 는 비현실적인 규칙이라 할 수 있다. 
그러나 DIP 를 논할 때 운영체제나 플랫폼 같이 **안정성이 보장된 환경에 대해서는 무시**하는 편이다. 

 의존하지 않도록 **피하고자 하는 것은 변동성이 큰(volatile) 구체적인 요소**이다. 이 구체적인 요소는 우리가 열심히 **개발 중이라 자주 변경될 수 밖에 없는 모듈들**을 말한다.

 <br><hr><br>

 ## **안정된 추상화**
 추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야한다.
 반대로 **구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 대다수의 경우 변경될 필요가 없다. 인터페이스는 구현체보다 변동성이 낮다.**

 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 노력한다. **인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력**한다. 그리고 이는 소프트웨어 설계의 기본이다.

 ### **즉, 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처이다.**

<br>

 > ### **코딩 실천 법**
 1. **변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라.** 
    - 이 규칙은 언어 타입 관계없이 모두 적용된다. 
    - 이 규칙은 객체 생성 방식을 강하게 제약하고, 일반적으로 추상 팩토리를 사용하도록 강제한다.
<br>

2. **변동성이 큰 구체 클래스로부터 파생하지 말라.**
    - 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣하여 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야한다.

        동적 타입 언어 또한 의존성을 가진다는 사실에 변함이 없으므로 마찬가지로 신중하게 상속을 해야한다.
<br>

3. **구체 함수를 오버라이드 하지 말라.**
    - 구체함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다. 이러한 의존성을 제거하려면, 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.

<br>

4. **구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.**
    - 이 실천법은 DIP 원칙을 다른 방식으로 풀어쓴 것이라고 말할 수 있다.

<br><hr><br>

## **팩토리**
*객체지향 언어에서 바람직하지 못한 의존성을 처리할 때, 추상 팩토리를 사용한다.*

![추상팩토리패턴](/img/추상팩토리패턴.png)
*곡선은 경계를 의미한다. 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다.*

<br>

Application은 Service 인터페이스를 통해 ConcreteImpl을 사용하지만, Application에서는 어떤 식으로든 ConcreteImpl의 인스턴스를 생성해야한다. 
(ConcreteImpl에 대해 소스 코드 의존성이 생성된다.)

ConcreteImpl에 대해 소스 코드 의존성을 만들지 않으면서 이 목적을 이루기 위해 Application은 ServiceFactory 인터페이스의 makeSvc 메서드를 호출한다. 

이 메서드는 ServiceFactory로부터 파생된 ServiceFactoryImpl에서 구현된다. 그리고 ServiceFactoryImpl 구현체가 ConcreteImpl의 인스턴스를 생성한 후 Service 타입으로 반환한다.

소스코드의 의존성은 곡선이 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향하게된다.
곡선은 시스템을 두가지 컴포넌트로 분리한다. 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트이다. 

추상 컴포넌트는 애플리케이션의 모든 고 수준 업무 규칙을 포함한다.

구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 세부사항을 포함한다.

여기서 주목할 부분은, 제어흐름이 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 사실이다. 다시말해 소스코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전(Dependency Inversion) 이라고 부른다.

<br><hr><br>

## **구체 컴포넌트**
*DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트로 모아 시스템의 나머지 부분과 분리 할 수 있다.*

위의 그림에서 구체 컴포넌트에는 구체적인 의존성이 하나있으므로 DIP에 위배 된다.(이는 일반적인 일이다. DIP를 모두 없앨 수는 없다.) DIP 를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모아, 시스템의 나머지 부분과 분리한다.

대다수의 시스템은 이러한 구체 컴포넌트를 최소 한개 이상 갖고 있다.

<br>

*흔히 구체 컴포넌트를 Main(애플리케이션이 처음 구동될 때 운영체제가 호출하는 함수)를 말한다.*

<br>

![추상팩토리패턴](/img/추상팩토리패턴.png)

*ServiceFactoryImpl 구체 클래스가 ConcreteImpl 구체 클래스에 의존한다.*

>위의 그림의 절차
1. main 함수는 ServiceFactoryImpl의 인스턴스를 생성한 후, 이 인스턴스를 ServiceFactory 타입으로 전역 변수에 저장한다. 
2. Application이 이 전역 변수를 이용하여 ServiceFactoryImpl 인스턴스에 접근한다.

<br><hr><br>

## **결론**
DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이다. 위의 그림에서 곡선은 이후 아키텍처 경계가 된다. 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙(Dependency Rule)이라 부를 것이다.


