# **ISP: 인터페이스 분리 원칙**
*소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다..*


<br>


`ISP` 는 아래의 다이어그램에서 그 이름이 유래 되었다.

![ISP](/img/ISP.png)

<br>

`User1` 은 오직 `op1` 을 `User2` 은 `op2` 만을, `User3` 은 `op3` 만을 사용한다.

<br>

그리고 `OPS` 가 정적 타입언어로 작성된 클래스일경우 `User1` 에서는 `op2` 와 `op3` 을 전혀 사용하지 않음에도 `User1` 의 소스 코드는 이 두 메서드에 의존하게 된다. 이러한 **의존성으로 인해 OPS클래스에서 `op2` 의 소스 코드가 변경되면 `User1` 도 다시 컴파일한 후 새로 배포해야** 한다.

<br>

### **이러한 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.**
<br>

![분리한오퍼레이션](/img/분리한오퍼레이션.png)

위와 마찬가지로 정적 타입 언어로 이 다이어그램을 구현했을경우, `User1` 의 소스 코드는 `U1Ops` 와 op1에는 의존하지만 `OPS` 에는 의존하지 않게 된다. 
따라서 `OPS` 에서 발생한 변경이 **`User1` 과는 전혀 관계없는 변경이라면, `User1` 을 다시 컴파일하고 새로 배포하는 상황은 초래되지 않는다.**
<br><hr><br>

## **ISP와 언어**
<br>

앞의 예제는 **언어 타입에 의존** 한다.
소스 코드에 포함된(include) 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래한다.

루비나 파이썬과 같은 **동적 타입 언어에서는 소스 코드에 이런 선언문이 존재하지 않는다. 대신 런타임 추론이 발생** 한다.

따라서 소스 코드의존성이 아예 없으며,결국 재컴파일과, 재배포가 필요없다.

### **이로인해 ISP를 아키텍처가 아니라 언어와 관련된 문제라고 결론내릴 여지가 존재한다.**

<br><hr><br>

## **ISP와 아키텍처**
일반적으로 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
이는 불필요한 재컴파일과 재배포를 강제하기 때문이다.

S 시스템 구축에 참여하고 있는 아키텍트가 있다. 아키텍트는 F 프레임워크를 시스템에 도입하기를 원하며, F 프레임워크 개발자는 특정한 D 데이터베이스를 반드시 사용하도록 만들었다. 따라서 S 는 F 에 의존하며, F 는 다시 D 에 의존하게 된다.

![문제가있는아키텍처](/img/문제가있는아키텍처.png)

 F 에서는 불필요한 기능, 따라서 S 와는 전혀 관계없는 기능이 D에 포함된다고 가정할 경우, 그 기능 때문에 D 내부가 변경되면, F 를 재배포 해야할 수도 있고, 따라서 S 까지 재배포해야 할지 모른다. 
 
 더 심각한 문제는 D 내부의 기능 중 F와 S에서 불필요한 그 기능에 문제가 발생해도 F와 S에 영향을 준다는 사실이다.

<br><hr><br>

## **결론**
<br>

`ISP` 를 통해 배울 수 있는 교훈은 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다는 것이다.
