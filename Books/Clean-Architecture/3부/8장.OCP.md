# **OCP: 개방 폐쇄 원칙**
*소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.*

소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.
요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패이다.

<br>


OCP는 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 중요한 의미를 가진다.

<br>

아키텍트는 **기능이 어떻게, 왜, 언제, 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화** 한다. 컴포넌트 계층구조를 이와 가티 조직화하면 저수준 컴포넌트에서 발생한 변경으로 부터 고수준 컴포넌트를 보호 할 수 있다.


<br><hr><br>

## **사고 실험**
<br>

> ### 예시: **재무제표를 웹 페이지로 보여주는 시스템**

웹 페이지에 표시되는 데이터는 스크롤 할 수 있으며, 음수는 빨간색으로 출력한다.

<br>

이해관계자가 동일한 정보를 보고서 형태로 변환하여 흑백 프린터로 출력을 요청하였다.
이 보고서에는 페이지 번호가 제대로 매겨져 있어야하고, 페이지마다 적절한 머리글과 바닥글이 있어야하며, 표의 각 열에는 레이블이 있어야한다. 또한 음수는 괄호로 감싸져야한다.

<br>

이 때, 원래 코드는 얼마나 많이 수정해야 할것인가?

<br>

> ### **이상적인 상황**

소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 최소화 될 것이며, **이상적인 변경량은 0 이다.**

<br>

이는 **서로 다른 목적으로 변경되는 요소를 적절하게 분리**하고(단일책임원칙;SRP), 이들 **요소 사이의 의존성을 체계화**함으로써(의존성역전원칙;DIP)을 적용하면 변경량을 최소화 할 수 있다.

<br>

단일 책임 원칙을 적용하면 데이터흐름은 재무 데이터를 검사한 후 보서고용 데이터를 생성한 다음, 필요에 따라 두 가지 보고서 생성 절차 중 하나를 거쳐 적절하게 포매팅한다.

<br>

![적절한데이터흐름](/img/적절한데이터흐름.png)

<br>

여기서 얻을 수 있는 가장 중요한 것은, **보고서 생성이 두 개의 책임으로 분리된다는 것**이다. 하나는 보고서용 데이터를 계산하는 책임, 다른 하나는 이 데이터를 웹으로 보여주거나 종이로 프린트 하기에 적합한 형태로 표현하는 책임이다.

<br>

이 처럼 책임을 분리했다면, **두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화 해야한다.** 또한, **새로 조직화한 구조에서는 행위가 확장 될 때 변경이 발생하지 않음을 보장**해야한다.

<br>

**이러한 목적을 달성하기 위해 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 (검정선으로 표시한) 컴포넌트 단위로 구분해야 한다.**

<br>

![처리과정분할](/img/처리과정분할.png)

<br>

`<I>`로 표시된 클래스는 **인터페이스**이며 , `<DS>` 로 표시된 클래스는 **데이터 구조**이다. **화살표가 열려 있다면 사용 관계**이며, **닫혀 있다면 구현 관계 혹은 상속 관계**이다. 

- 모든 의존성이 소스 코드 의존성을 나타낸다.
    - 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스에서는 B 클래스를 호출 하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다.

<br>

- 모든 컴포넌트 관계는 **단방향**으로 이루어진다.
    - A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야한다.

<br>

- 이 예제의 경우 `Presenter` 에서 발생한 변경으로부터 `Controller` 를 보호하고자 한다. 그리고 `View` 에서 발생한 변경으로부터 `Presenter` 를 보호하고자한다. `Interactor` 는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다.

<br>

> ### **처리 중요도: Interactor > Controller > Presenter > View**

- **`Interactor` 는 OCP를 가장 잘 준수할 수 있는 곳에 위치**한다. `Database`, `Controller`, `Presenter`, `View` 에서 발생한 **어떤 변경도 `Interactor에` 영향을 주지 않는다.**
    - `Interactor` 는 **애플리케이션에서 가장 높은 수준의 정책을 포함**한다.
    - `Interactor` 이외의 컴포넌트는 모두 주변적인 문제를 처리한다.(가장 중요한 문제는 `Interactor` 가 담당한다.)

<br>

- `Controller` 는 `Presenter` 와 `View` 에 비해서는 중심적인 문제를 담당한다.
- `Presenter` 는 `View` 보다 중심적인 문제를 처리한다.

<br> 

> ### **보호의 계층구조 수준(level)**
- `Interactor` 는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다.
- `View` 는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다.

<br>

> ### **방향성 제어**
`FinancialDataGateway` 인터페이스는 `FinancialReportGenerator` 와 `FinancialDataMapper` 사이에 위치하는데 이는 의존성을 역전 시키기 위해서 이다.

<br>

`FinancialDataGateway` 인터페이스가 없었다면, 의존성이 `Interactor` 컴포넌트에서 `Database` 컴포넌트로 바로 향하게 된다. `FinancialReportPresenter` 인터페이스와 2개의 `View` 인터페이스도 같은 목적을 가진다.

<br>

> ### **정보은닉**
`FinancialReportRequester` 인터페이스는 방향성 제어와는 다른 목적을 가진다.
 이 인터페이스는 `FinacialReportController` 가 `Interactor` 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다. 만약 이 인터페이스가 없었다면, `Controller` 는 `FinancialEntities` 에 대해 추이 종속성(`trasitive dependency`)를 가지게 된다. 

 <br>

 추이 종속성을 가지게 되면, 소프트웨어 엔티티는 "자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다."는 소프트웨어 원칙을 위반하게 된다.

 <br>

 `Controller` 에서 발생한 변경으로부터  `Interactor` 를 보호하는 일이 우선순위가 가장 높지만, 반대로 `Interactor` 에서 발생한 변경으로부터 `Controller` 도 보호되기를 바란다. 이를 위해 `Interactor` 내부를 은닉한다.

<br><hr><br>

## **결론**
<br>

`OCP` 는 시스템의 아키텍처를 떠받치는 원동력 중 하나이다. `OCP` 의 목표는 **시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.** 이러한 목표를 달성하려면 **시스템을 컴포넌트 단위로 분리**하고, **저수준 컴포넌트에서 발생한 변경으로 부터 고수준 컴포넌트를 보호 할 수 있는 형태의 의존성 계층 구조**가 만들어 지도록 해야한다.
