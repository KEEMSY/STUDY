# **컴포넌트 응집도**
컴포넌트 응집도와 관련된 원칙은 세가지 원칙을 이야기 할 수있다.
1. `REP`(Reuse/Release Equivalence Princicple): 재사용/릴리스 등가 원칙
2. `CCP`(Common Closure Principle): 공통 폐쇄 원칙
3. `CRP`(Common Reuse Principle): 공통 재사용 원칙

<br><hr><br>

## **REP: 재사용/릴리스 등가 원칙**
*재사용 단위는 릴리스 단위와 같다.*

소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리 되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.

**릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.** 결정적으로, 새로운 버전이 언제 출시되고 무엇이 변했는지를 소프트 웨어 개발자들이 알지 못한다.

소**프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.** 단순히 뒤죽박죽 임의로 선택된 클래스와 모듈로 구성되어서는 안된다. **컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마 혹은 목적이 있어야한다.**

**하나의 컴포넌트로 묶인 클래스와 모듈은 버전번호가 같아야하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리즈 문서에 포홤 되어야한다.**

이 원칙의 약점은 `CCP` 와 `CRP` 를 통해 보완이 가능하다. `CCP` 와 `CRP` 는 `REP` 를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다.

<br><hr><br>

## **CCP: 공통 폐쇄 원칙**
*의존성 관리에 대한 요구가 늘어날 때 고려하자.*

*동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해라.*

<br>

이 원칙은 **단일 책임 원칙(`SRP`)을 컴포넌트 관점에서 다시 작성한 것**이다. `SRP` 에서 단일 클래스는 변경의 이유가 여러개 있어서는 안된다고 말하였듯이, 공통 폐쇄 원칙(`OCP`)에서도 마찬가지로 **단일 컴포넌트는 변경의 이유가 여러개 있어서는 안된다**고 말한다.


대다수의 **애플리케이션에서 유지보수성(maintainability)은 재사용성보다 훨씬 중요**하다. 

`CCP` 는 같은 이유로 **변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것**을 권한다. **물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.** 이를 통해 소프트웨어 **릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화** 할 수 있다.

이 원칙은 개방 폐쇄 원칙(`OCP`)와도 밀접하게 관련되어 있다. `OCP` 에서 말하는 패쇄(Closure)은 `OCP` 에서 말하는 폐쇄(Closure)와 그 의미가 같다. **100% 완전한 폐쇄란 불가능하므로, 전략적으로 폐쇄해야한다.** 즉 우리는 **발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계** 한다.

`CCP` 에서는 **동일한 유형의 병경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음**으로써 `OCP` 에서 얻은 교훈을 확대 적용한다. 따라서 **변경이 필요한 요구사항이 발생했을 떄, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.**

<br>

> ### **SRP와의 유사성**
*동일한 시점에서 동일한 이유로 변경되는 것들을 한 곳에 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.*

`CCP` 는 컴포넌트 수준의 `SRP` 이다. `SRP` 에서는 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다. `CCP` 에서는 **서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리** 하라고 말한다.



<br><hr><br>

## **CRP: 공통 재사용 원칙**
*애플리케이션이 계속 성장함에 따라 재사용 가능한 요소를 만드는 일에 관심이 생길 때, 고려하자.*

*컴포넌트 사용자들을 필요하지 않는 것에 의존하지 강요하지 말라.*

<br>

공통 재사용 원칙도 **클래스와 모듈을 어느 컴포넌트에 위치 시킬지 결정할 때 도움**되는 원칙이다. `CRP` 에서는 **같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다**고 말한다.

재사용 가능한 클래스는 **재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우**가 많다. `CRP` 에서는 이런 클래스들이 **동일한 컴포넌트에 포함되어야 한다**고 말한다. **이러한 컴포넌트 내부에서는 클래스들 사이에 수많은 의존성이 있으리라고 예상** 할 수 있다.

*예시: 컨테이너(container) 클래스와 해당 클래스의 이터레이터(uterator) 는 서로 강하게 결합되어 있기 때문에 함께 재사용 된다. 따라서 이들 클래스는 반드시 동일한 컴포넌트에 위치해 있어야한다.*

`CRP` 는 **각 컴포넌트에 어떤 클래스들을 포함해야하는지 설명해줌 뿐만아니라, 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말한다.** 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다.

**의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야한다.** 바꿔말해, **한 컴포넌트에 속한 클래스들은 더 작게 그룹 지을 수 없다.** 즉 그 중 **일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지** 해야한다. 

따라서 `CRP` 는 **어떤 클래스를 한대 묶어도 되는지 보다는, 어떤 클래스를 한대 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.** `CRP` 는 **강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치 시켜서는 안된다**고 말한다.

<br>

> ### **ISP와의 관계**
*필요하지 않는 것에 의존하지 말라.*

`CRP` 는 인터페이스 분리 원칙(`ISP`)의 포괄적인 버전이다. `ISP` 는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라 조언핟다. `CRP` 는 **사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라** 조언한다. 

<br><hr><br>

## **컴포넌트 응집도에 대한 균형 다이어 그램**
*`REP` 와 `CCP` 는 포함(inclusive)원칙으로 **컴포넌트를 더욱 크게** 만들고, `CRP` 는 배제(exclusive)원칙으로 **컴포넌트를 더욱 작게** 만든다. 뛰어난 아키텍트라면이 원칙들이 균형을 이루는 방법을 찾아야한다.*

<br>

![결합도원칙의균형](/img/결합도원칙의균형.png)

다이어그램의 각 변은 반대쪽 꼭지점에 있는 원칙을 포기 했을 때 감수해야 할 비용을 나타낸다.

`REP` 와 `CRP` 에만 중점을 두면, **사소한 변경이 일어났을 때 너무 많은 컴포넌트에 영향**을 미친다. 반대로 `CCP` 와 `REP` 에만 과도하게 집중하면 **불필요한 릴리스가 너무 빈번** 해진다.

따라서 뛰어난 아키텍트라면 이 **균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야하며, 또한 시간이 흐르면서 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해하고 있어야한다.**

*프로젝트 초기에는 `CCP` 가 `REP` 보다 훨씬 더 중요하다.(개발 가능성이 재사용성보다 더욱 중요하기 때문)*

**일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편**이며, 이때는 오직 재사용성만 희생하면 된다. **프로젝트가 성숙하고, 그 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동**해간다. 즉 **프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.**(프로젝트가 수행하는 일 자체보다는  프로젝트가 발전되고 사용되는 방법에 따라 바뀐다.)

<br><hr><br>

## **결론**
*클래스를 묶어서 컴포넌트로 만들지 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야한다.*

**세 가지 원칙(REP, CCP, CRP)을 통해 애플리케이션의 균형을 맞추는 것은 중요**하다. 그리고 이 **균형점은 항상 유동적**이다. 즉 두 힘을 현재 상황에 맞게 잘 분배했더라도, 내년이 되면 맞지 않을 수 있다. 결과적으로 **시간이 흐름에 따라 프로젝트의 초점이 개발 가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 진화한다.**
