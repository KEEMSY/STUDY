# **컴포넌트 결합**
*컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.*

<br><hr><br>

## ADP: 의존성 비순환 원칙
*컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안된다.*

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리를하면 개별 개발자 또는 단일 개발팀이 책임질 수 있는 개발 단위가 된다. 

개발자가 컴포넌트를 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다. 담당 개발자는 릴리스 번호를 컴포넌트에 부여하고, 다른팀에서 사용할 수 있는 디렉터리로 이동시키며, 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자들은 릴리스된 버전을 사용한다.

이렇게 될경우 어떤 팀도 다른 팀에 의해 좌우되지 않는다. 특정 컴포넌트가 변경되더라도 다른팀에 즉각 영향을 주지 않는다. 뿐만아니라 통합은 작고 점진적으로 이뤄지게된다.(특정 시점에 모든개발자들이 모여 진행중인 작업을 모두 통합하는 일은 사라진다.)

<br>

![컴포넌트다이어그램](/img/컴포넌트다이어그램.png)

컴포넌트는 정점(vertex)에 해당하고, 의존성 관계는 방향이 있는 간선(directed edge)에 해당한다. 여기서 주목할 점은 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다.(즉, 순환이 없다.)

Main 컴포넌트의 경우 새로 릴리스 되더라도 시스테멩서 이로 인해 영향받는 컴포넌트가 전혀 없다. 이는 Main 을 릴리스함으로써 미치게 되는 충격은 대체로 작다는 것을 의미한다.


<br>

 > ### **Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들경우**

![컴포넌트수정](/img/컴포넌트수정.png)

이 릴리스에 영향받는 팀은 의존성 화살표를 거꾸로 따라가면 된다.(View 와 Main 컴포넌트가 영향을 받는다.)
이 두 컴포넌트를 작업중인 개발자라면, Presenters 의 새로운 릴리스와 자신의 작업물을 언제 통합할지 반드시 결정해야한다.

Presenters 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용중인 버전의 Interactors 와 Entities를 이용해서 Presenters 자체 버전을 빌드하면 된다. 이 빌드 과정에서 시스템의 나머지 컴포넌트는 전혀 관련이 없다. 즉, Presenters 를 만드는 개발자가 테스트를 구성할 때 대체로 적은 노력이 든다는 뜻이며, 고려해야 할 변수도 상대적으로 적다는 것을 의미한다.

<br><br>

> ### **시스템 전체를 릴리스 해야할 경우**
이 같은 절차는 상당히 명료하며 쉽게 처리할 수 있다. 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다. 릴리스 절차는 상향식으로 진행한다. 

먼저 Entities 컴포넌트를 컴파일하고, 테스트하고 릴리스한다. 그러고나서 Database 와 Interactors 에 대해서도 동일한 과정을 거친다. 그 다음에는 Presenters, View, Controllers, Authorizer 순으로 진행한다. Main은 마지막에 처리한다.


<br><br>

> ### **순환이 컴포넌트 의존성 그래프에 미치는 영향**

![순환영향](/img/순환영향.png)

이 순환은 즉각적인 문제를 일으킨다. Database 컴포넌트를 만드느 ㄴ개발자는 컴포넌트를 릴리스 하려면 Entities 컴포넌트와 반드시 호환이 되어야한다는 사실을 알고 있다.

하지만 Entities 컴포넌트에는 순환이 있으므로, Database 컴포넌트 또한 Authorizer 와도 호환이 되어야한다. 

그런데 Authorizer 는 Interactors 에 의존한다. 이로인해 Database는 릴리스 하기가 훨씬 어려워진다. Entities, Authorizer, Interactors 는 사실상 하나의 거대한 컴포넌트가 되어 버렸기 때문이다. 해당 컴포넌트의 개발자들은 모두 서로에게 얽메이게 된다.(모두 항상 정확하게 동일한 릴리스를 사용해야하기 때문이다.)

뿐만아니라 Entities 컴포넌트를 테스트 할 경우 Authorizer 와 Interactors 까지도 반드시 빌드하고 통합해야한다. 컴포넌트 사이에 이정도까지 결합이 발생하면 문제가 될 뿐만아니라 받아들이기 어려워진다.

순환이 생기면 컴포넌트를 분리하기가 상당히 어려워지며 단위테스트를 하고 릴리스 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다. 뿐만아니라 모듈의 개수가 많아짐에 따라 빌드 관련 이슈 또한 기하급수적으로 늘어나게 된다.

컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.(사실 순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다.)

<br>

> ### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG 로 원상복구 하는 일은 언제라도 가능하다.

1. 의존성 역전 원칙(DIP)를 적용한다.

    ![순환끊기](/img/순환끊기.png)    

    User 가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다. 그리고 이 인터페이스는 Entities 에 위치시키고, Authorizer 에서는 이 인터페이스를 상속받는다. 이를 통해 Entities 와 Authorizer 사이의 의존성을 역전 시킬 수 있고, 이를통해 순환을 끊을 수 있다.

2. Entities 와 Authorizer 가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

    ![새로운컴포넌트생성](/img/새로운컴포넌트생성.png)

    > **흐트러짐(Jitters)**

    애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야한다. 순환이 발생하면 어떤식으로든 끊어야한다. 

<br><hr><br>

## **하향식(top-down) 설계**
*컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.*

컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성(buildability)와 유지보수성(maintainability)을 보여주는 지도와 같다.

따라서 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도또한 필요 없기 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.

의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다. 변덕스러운 이유로 자주 변경되는 컴포넌트로 인해 안정적이었을 컴포넌트가 영향을 받지 않아야한다. 결국 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려 시도한다면 큰 실패를 맛볼 수 있다. 공통 폐쇄에 대해 그다지 많이 파악하지 못하고 있고, 재사용 가능한 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실히 순환 의존성이 발생할 것이다. 따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야한다.

<br><hr><br>

## **SDP: 안정된 의존성 원칙**
*안정성의 방향으로(더 안정된 쪽에) 의존하라*

설계는 결코 안정적일 수 없다. 설계를 유지하다 보면 변경은 불가피하다. 공통 폐쇄 원칙을 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향을 받지 않으면서도 특정 
유형의 변경에만 민감하게 만들 수 있다. 즉 컴포넌트 중 일부는 변동성을 지니도록 설계된다.(변동성을 지니도록 설계한 컴포넌트는 언젠가 변경되리라고 예상한다.)

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

이는 내가 모듈을 만들 때에는 변경이 쉽도록 설계했지만, 이 모듈에 누군가 의존성을 매달아 버리면 내가 작성한 모듈도 변경하기 어려워진다. 안정된 의존성 원칙(Stable Dependancies Principle)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

<br>

> ### **안정성**

안정적이라는 것은 '쉽게 움직이지 않는 것' 을 말한다. 안정성은 변경을 만들기 위한 필요한 작업량과 관련된다. 

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 중 하나는 수 많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안적적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 수많은 노력이 들기 때문이다.

<br>

![안정된컴포넌트](/img/안정된컴포넌트.png)

X 는 안정된 컴포넌트이다. 세 컴포넌트가 X에 의존하며, 따라서 X 컴포넌트는 변경하지 말아야 할 이유가 세 가지나 존재한다.(이를 X는 세 컴포넌트를 책임(responseible)진다 말한다.) 반대로 X 는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.(이를 X 는 독립적(independent)라고 말한다.)

<br>

![불안정한컴포넌트](/img/불안정한컴포넌트.png)

Y 는 상당히 불안정한 컴포넌트이다. 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다고 말할 수 있다. 또한 Y는 세개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부요인이 세 가지다.(이 경우 Y는 의존적이라고 말한다.)

<br>

> ### **안정성 지표**

![안정성지표예시](/img/안정성지표예시.png)

<br>

컴포넌트 안정성은 컴포넌트로 들어오고 나가는 의존성의 개수를 세어보는 방법으로 컴포넌트가 위치상(positional) 어느정도의 안정성을 가지는지 계산할 수 있다.

- Fan-in: 안으로 들어오는 의존성. 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
- Fan-out: 바깥으로 나가는 의존성. 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다.
- I(불안정성): I = Fan-out % (Fan-in + Fan-out) [0 , 1]
     
     이 지표는 0 ~ 1 범위의 값을 갖고, 0은 최고로 안정된 컴포넌트이며 1은 최고로 불안정한 컴포넌트를 의미한다. 

<br>

Cc 컴포넌트의 안정성을 계산할 경우
- Fan-in(Cc내부 클래스에 의존하며 Cc 외부에 있는 클래스): 3
- Fam-out(Cc 내부의 클래스가 의존하는 Cc 외부에 위치한 클래스): 1
-  I = 1/4

<br>

실제로 소스 파일이 클래스당 하나가 되도록 소스코드를 구조화한다면, I 지표는 쉽게 계산할 수 있다. import 구문과 완전한 클래스 이름(fully qualified name)의 개수를 세어서 계산할 수 있다.

SDP에서 컴포넌트의 I 지표는 해당 컴포넌트가 의존하는 다른 컴포넌트들의 I 보다 커야한다고 말한다. 즉 의존성 방향으로 갈수록 I 지표 값이 감소해야한다.


<br>

> ### **모든 컴포넌트는 안정적이여야 하는가?**

*모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 그리고 이는 바람직한 상황이 아니다.*

우리가 컴포넌트 구조를 설계할 때는 불안정한 컴포넌트와 안정된 컴포넌트로 구성된다. 

<br>

![이상적인구성](/img/이상적인구성.png)

관례적으로 불안정한 컴포넌트는 위쪽에 둔다.(이 관례를 따를결우 위로 향하는 화살표가 있으면 SDP 를 위배하는 상태가 되기 때문이다.)

<br>

![SDP위배](/img/SDP위배.png)

Flexible은 변경하기 쉽도록 설계한 컴포넌트이다. 우리는 Flexible은 불안전한 상태이기를 바란다. 하지만 Stable 컴포넌트에서 Flexible에 의존성을 걸게 되면서 SDP를 위반하게 된다. Stable 의 I 지표는 Flexible의 I 지표보다는 더 작기 때문이다. 결국 Flexible은 변경할 수 어렵게 되었고 Flexible 을 변경하게 되면 Stable과 Stable에 의존하는 나머지 컴포넌트 에도 조치를 취해야한다.

이 문제를 해결하기 위해서는 Stable 의 Flexible 에 대한 의존성을 어떤식으로든 끊어야한다.(현재 의존성을 Stable 내부의 클래스 U 가 Flexible 내부의 클래스 C를 사용한다고 가정한다.)

<br>

![클래스가정](/img/클래스가정.png)

DIP 를 도입하면 이 문제는 해결 할 수 있다. 
US 라는 인터페이스를 생성한 후 UServer 컴포넌트에 넣는다. 이 때 US 인터페이스에는 U가 사용하는 모든 메서드가 반드시 선언되어 있어야 한다. 
C 가 해당 인터페이스를 구현하도록 만든다. 이를 통해 Stable의 Flexible에 대한 의존성을 끊을 수 있고, 두 컴포넌트는 모두 UServer에 의존하도록 강제한다. UServer는 매우 안정된 상태이며(I=0), Flexible 은 자신에게 맞는 불안정성(I=1)을 그대로 유지할 수 있으며, 모든 의존성은 I가 감소하는 방향으로 향한다.

<br>

![US인터페이스구현](/img/US인터페이스구현.png)

<br>

> ### **추상 컴포넌트**
*추상컴포넌트는 상당히 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.*

자바나 C# 같은 정적 타입 언어를 사용할 때 이 방식은 상당히 흔하고 반드시 필요한 전략으로 알려져있다. 하지만 루비나 파이썬과 같은 동적 타입 언어를 사용할 때는 이러한 추상 컴포넌트가 존재하지 않을 뿐만 아니라, 추상 컴포넌트로 향하는 의존성 같은 것도 전혀 없다.(의존성을 역전 시킬 때, 인터페이스를 선언하거나 상속받는 일이 전혀 필요하지 않기 때문이다.)

<br><hr><br>

## **SAP: 안정된 추상화 원칙**
*컴포넌트는 안정된 정도만큼만 추상화되어야 한다.*

안정된 추상화 원칙(Stable Abstractions Principle, SAP) 은 안정성(Stable)과 추상화 정도(Abstraction) 사이의 관계를 정의한다. 이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다.

다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말한다. 이는 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.

따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게되고 아키텍처를 과도하게 제약하지 않게 된다.

<br>

> ### **고수준의 정책을 어디에 위치 시켜야 할까?**
고수준아키텍처나 정책 결정과 같은 소프트웨어는 자주 변경해서는 절대로 안된다. 즉 업무 로직이나아키텍처와 관련된 결정에는 변동성이 없기를 기대한다. 

따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(I=0)에 위치해야한다. 불안정한 컴포넌트(I=1) 은 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야한다. 

고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기 어려워진다. 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다. 컴포넌트가 최고로 안정된 상태이면서도(I=0) 동시에 변경에 충분히 대응할 수있을 정도로 유연하게 만들 방법을 찾아야한다. 그리고 그 해결방법은, 개방 폐쇄 원칙(OCP)를 통해 해결할 수 있다.

**즉, 추상클래스에 위치하면 된다.**


*OCP는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있으며, 이는 바람직한 방식이다.*



<br>

> ### **SAP, SDP 그리고 DIP**
SAP와 SDP를 결합하면 컴포넌트에 대한 DIP와 같다고 말할 수 있다. 
SDP에서는 의존성이 반스시 안정성의 방향으로 향해야 한다고 말하며, SAP 에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다.

따라서 의존성은 추상화의 방향으로 향하게 된다.

하지만 DIP는 클래스에 대한 원칙이며, 클래스의 경우 중간은 존재하지 않는다. 즉, 클래스는 추상적이거나 아니거나 둘중 하나이다. SDP 와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 어떤 부분은 추상적이면서 다른부분은 안정적일 수 있다.


<br> <br>

> ### **추상화 정도 측정하기**
*A 지표는 컴포넌트의 추상화 정도를 측정한 값이다.(클래스 총 수 대비 인터페이스와 추상클래스의 개수를 단순히 계산한 값)*

- Nc: 컴포넌트의 클래스 개수
- Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
- A: 추상화 정도(A= Na % Nc) [0,1]
    - 0:  추상 클래스가 하나도 없다.
    - 1: 컴포넌트는 오로지 추상클래스만을 포함한다.

<br>

![AI그래프](/img/AI그래프.png)

- (0,1): 최고로 안정적이며 추상화된 컴포넌트 
- (1,0): 최고로 불안정하며 구체화된 컴포넌트

모든 컴포넌트가 (0,1) 혹은 (1,0)에 위치하도록 강요할 수는 없다.

<br>

![배제구역](/img/배제구역.png)

- **고통의 구역**
    
    *배제해야 할 구역*
    
    이 컴포넌트는 매우 안정적이며 구체적이다. 이러한 컴포넌트는 바람직한 상태가 아니다. 왜냐하면 뻣뻣한 상태이기 때문이다. 추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 상당히 어렵다. 따라서 제대로 설계된 컴포넌트라면 (0,0) 근처에는 위치하지 않을 것이라고 보는게 일반적이다.

    변동성이 없는 컴포넌트는 (0,0) 에 위치하더라도 해롭지 않으나, 변동 가능성이 있는 컴포넌트가 해당 위치에 존재할 경우 문제가 된다.

<br>

- **쓸모 없는 구역**

    *최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않는다.*

    이 영역에 존재하는 소프트웨어 엔티티는 폐기물과 같다. 쓸모없는 구역 내부 깊숙히 자리잡은 컴포넌트는 이러한 엔티티의 상당한 부분을 포함할 가능성이 높다. 그리고 쓸모없는 엔티티가 존재한다는 사실은 바람직한 상황이 아님은 분명하다.

<br>

- **주계열과의 거리**
    *이상적인 상태로부터 컴포넌트가 얼마나 멀리 떨어져 있는지 측정하는 지표를 만들어 볼 수 있다.*

   ` D=|A + I -1|[0,1]`

    D=0 일경우, 컴포넌트가 주계열 바로 옆에 위치한다는 것을 의미하며,
    D=1 일경우 주계열로부터 가장 멀리 위치한다는 것을 의미한다.

    이 계산을 통해 컴포넌트가 주계열에 대체로 일치하도록 설계되었는지 분석 할 수 있다. 가깝지 않은 컴포넌트가 있다면 해당 컴포넌트는 재 검토한 후 재구성 할 수 있다.

<br><hr><br>

## **결론**
의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다. 경험을 통해 좋은 의존성도 있지만 좋지 않은 의존성도 있다는 사실을 알아야한다.

하지만 지표는 절대적이지 않다. 지표는 그저 임의로 결정된 표준을 기초로한 값에 지나지 않는다. 하지만 이 지표로 부터 무엇인가 유용한 것을 할 수 있을 것이다.