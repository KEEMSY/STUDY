# **컴포넌트 결합**
*컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.*

<br><hr><br>

## ADP: 의존성 비순환 원칙
*컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안된다.*

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리를하면 개별 개발자 또는 단일 개발팀이 책임질 수 있는 개발 단위가 된다. 

개발자가 컴포넌트를 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다. 담당 개발자는 릴리스 번호를 컴포넌트에 부여하고, 다른팀에서 사용할 수 있는 디렉터리로 이동시키며, 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자들은 릴리스된 버전을 사용한다.

이렇게 될경우 어떤 팀도 다른 팀에 의해 좌우되지 않는다. 특정 컴포넌트가 변경되더라도 다른팀에 즉각 영향을 주지 않는다. 뿐만아니라 통합은 작고 점진적으로 이뤄지게된다.(특정 시점에 모든개발자들이 모여 진행중인 작업을 모두 통합하는 일은 사라진다.)

<br>

![컴포넌트다이어그램](/img/컴포넌트다이어그램.png)

컴포넌트는 정점(vertex)에 해당하고, 의존성 관계는 방향이 있는 간선(directed edge)에 해당한다. 여기서 주목할 점은 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다.(즉, 순환이 없다.)

Main 컴포넌트의 경우 새로 릴리스 되더라도 시스테멩서 이로 인해 영향받는 컴포넌트가 전혀 없다. 이는 Main 을 릴리스함으로써 미치게 되는 충격은 대체로 작다는 것을 의미한다.


<br>

 > ### **Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들경우**

![컴포넌트수정](/img/컴포넌트수정.png)

이 릴리스에 영향받는 팀은 의존성 화살표를 거꾸로 따라가면 된다.(View 와 Main 컴포넌트가 영향을 받는다.)
이 두 컴포넌트를 작업중인 개발자라면, Presenters 의 새로운 릴리스와 자신의 작업물을 언제 통합할지 반드시 결정해야한다.

Presenters 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용중인 버전의 Interactors 와 Entities를 이용해서 Presenters 자체 버전을 빌드하면 된다. 이 빌드 과정에서 시스템의 나머지 컴포넌트는 전혀 관련이 없다. 즉, Presenters 를 만드는 개발자가 테스트를 구성할 때 대체로 적은 노력이 든다는 뜻이며, 고려해야 할 변수도 상대적으로 적다는 것을 의미한다.

<br><br>

> ### **시스템 전체를 릴리스 해야할 경우**
이 같은 절차는 상당히 명료하며 쉽게 처리할 수 있다. 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다. 릴리스 절차는 상향식으로 진행한다. 

먼저 Entities 컴포넌트를 컴파일하고, 테스트하고 릴리스한다. 그러고나서 Database 와 Interactors 에 대해서도 동일한 과정을 거친다. 그 다음에는 Presenters, View, Controllers, Authorizer 순으로 진행한다. Main은 마지막에 처리한다.


<br><br>

> ### **순환이 컴포넌트 의존성 그래프에 미치는 영향**

![순환영향](/img/순환영향.png)

이 순환은 즉각적인 문제를 일으킨다. Database 컴포넌트를 만드느 ㄴ개발자는 컴포넌트를 릴리스 하려면 Entities 컴포넌트와 반드시 호환이 되어야한다는 사실을 알고 있다.

하지만 Entities 컴포넌트에는 순환이 있으므로, Database 컴포넌트 또한 Authorizer 와도 호환이 되어야한다. 

그런데 Authorizer 는 Interactors 에 의존한다. 이로인해 Database는 릴리스 하기가 훨씬 어려워진다. Entities, Authorizer, Interactors 는 사실상 하나의 거대한 컴포넌트가 되어 버렸기 때문이다. 해당 컴포넌트의 개발자들은 모두 서로에게 얽메이게 된다.(모두 항상 정확하게 동일한 릴리스를 사용해야하기 때문이다.)

뿐만아니라 Entities 컴포넌트를 테스트 할 경우 Authorizer 와 Interactors 까지도 반드시 빌드하고 통합해야한다. 컴포넌트 사이에 이정도까지 결합이 발생하면 문제가 될 뿐만아니라 받아들이기 어려워진다.

순환이 생기면 컴포넌트를 분리하기가 상당히 어려워지며 단위테스트를 하고 릴리스 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다. 뿐만아니라 모듈의 개수가 많아짐에 따라 빌드 관련 이슈 또한 기하급수적으로 늘어나게 된다.

컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.(사실 순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다.)

<br>

> ### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG 로 원상복구 하는 일은 언제라도 가능하다.

1. 의존성 역전 원칙(DIP)를 적용한다.

    ![순환끊기](/img/순환끊기.png)    

    User 가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다. 그리고 이 인터페이스는 Entities 에 위치시키고, Authorizer 에서는 이 인터페이스를 상속받는다. 이를 통해 Entities 와 Authorizer 사이의 의존성을 역전 시킬 수 있고, 이를통해 순환을 끊을 수 있다.

2. Entities 와 Authorizer 가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

    ![새로운컴포넌트생성](/img/새로운컴포넌트생성.png)

    > **흐트러짐(Jitters)**

    애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야한다. 순환이 발생하면 어떤식으로든 끊어야한다. 

<br><hr><br>

## **하향식(top-down) 설계**
*컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.*

컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성(buildability)와 유지보수성(maintainability)을 보여주는 지도와 같다.

따라서 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도또한 필요 없기 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.

의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다. 변덕스러운 이유로 자주 변경되는 컴포넌트로 인해 안정적이었을 컴포넌트가 영향을 받지 않아야한다. 결국 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려 시도한다면 큰 실패를 맛볼 수 있다. 공통 폐쇄에 대해 그다지 많이 파악하지 못하고 있고, 재사용 가능한 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실히 순환 의존성이 발생할 것이다. 따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야한다.

<br><hr><br>

