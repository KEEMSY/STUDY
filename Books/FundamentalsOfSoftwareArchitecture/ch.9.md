# **CHAPTER 9 기초**

아키텍처 패턴은 다양한 아키텍처 특성을 다루는 컴포넌트의 명명된 관계(named relationship)을 기술한다.

- 아키텍처 패턴의 목표는 **각 패턴 별 구조적인 측면과 어떤 종류의 아키텍처 특성이 알맞는지(또는 문제를 일으킬 수 있는지) 살펴보고 통상적인 배포 모델 및 데이터 전략 등 다양한 정보를 이해하는 것**이다.
- 아키텍처 스타일은 토폴로지와 기본 전제된 아키텍처 특성을, 이로운것과 해로운것 모두 기술한다.

<br><hr><hr>

## **기초 패턴**

기초 패턴이라 함은 소프트웨어 아키텍처의 **역사를 통틀어 끊임없이 나타나고 또 나타나는 패턴**을 말한다.

- 이런 **패턴은 코드, 배포 또는 아키텍처의 다른 부분을 구성하는 시야를 넓여준다.**

<br>

> **진흙잡탕**

`진흑잡탕(Big Ball of Mud)`란 뭐 하나 **뚜렷한 아키텍처 구조가 전무한 상태**를 말한다. 이러한 아키텍처는 무슨 수를 써서라도 피해야한다. 구조가 없으면 변경하기가 점점 어려워지고, 배포, 테스트, 확장, 성능 역시 고통스러워지기 때문이다.

- 거의 반드시 무질서한 성장과 반복적인 땜질식 수리의 징후를 나타낸다.
- 정보는 멀찍이 떨어져 있는 시스템 파트끼리 난잡하게 공유되고, 거의 모든 중요한 정보는 전역에 흩어져 있거나 중복된 경우가 많다.
- 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션을 나타낸다.
- 진흙잡탕의 코드베이스는 사소한 클래스 변경조차 다른 클래스에 미치는 연쇄적인 파급효과를 예측하기 어렵기 때문에 변경 자체가 무척 두려운 일이다.

<br>

> **클라이언트/서버**

시간이 갈수록 단일 시스템에서 여러 기능을 분리할 필요성이 대두되었고 그 분리 방법은 많은 아키텍처 스타일의 기초가 되었다.

- `FE(프론트엔드)`와 `BE(백엔드)`로 기슬적으로 분리한 `2티어` 또는 `클라이언트/서버 아키텍처`는 대표적인 기본 아키텍처 스타일이며 시대와 컴퓨팅 파워에 따라 여러가지 형태로 존재한다.

<br>

- `데스크톱 + 데이터베이스 서버`

    프레젠테이션 로직은 데스크톱에두고(양과 복잡도 모두) 계산량이 많은 액션은 사양이 탄탄한 **데이터베이스 서버**에서 실행한다.

<br>

- `브라우저 + 웹 서버`

    현대 웹 개발 시대에서 일반화된 구조이다. 클라이언트는 데스크톱보다 훨씬 가벼운 브라우저로 대체되었고, 배외부 방화벽 모두 더 넓은 범위로 배포가 가능하다.

    **데이터베이스는 웹 서버와 분리**되어 있지만 두 서버 모두 운영 센터 내부의 동급 머신에서 운용되며 유저 인터페이스는 브라우저에서 실행됨로 여전히 이 구조를 2티어로 바라보는 경우도 존재한다.

<br>

- `3티어`

    1990년대 후반에 인기를 끈 3티어 아키텍처는 더 많은 레이어로 분리한다. 애플리케이션 서버 같은 도구가 보급되고 더 많은 레이어를 토폴로지에 구축하기 시작했다.

    `3티어`는 고성능 데이터베이스 서버를 사용하는 `데이터베이스 티어`, 애플리케이션 서버가 관리하는 `애플리케이션 티어` 그리고 처음에는 HTML로 시작하여 기능이 점점 많아져 온갖 자바스크립트 코드로 가득 찬 `프론트엔드 티어` 로 구성된다.

    3티어 아키텍처는 분산 아키텍처에 적합한 공통 객체 요청 브로커 아키텍처(Common Object Request Broker Architecture, CORBA), 분산 컴포넌트 객체 모델(Distributed Componet Object Model, DCOM) 같은 네트워크 수준의 프로토콜과 잘 어울린다.

<br><hr><hr>

## **모놀리식 VS 분산 아키텍처**

아키텍처 스타일은 크게 **`모놀리식`(전체 코드를 단일 단위로 배포하는)** 과 **`분산형`(원격 액세스 프로토콜을 통해 여러 단위로 배포하는)** 두종류가 존재한다. `분산` 아키텍처는 `모놀리식` 아키텍처 스타일에서는 찾아볼 수 없는 공통적인 난제와 이슈를 갖고 있으므로 다양한 아키텍처 스타일을 분류하기에 좋은 기준이 된다.

<br>

> **모놀리식 아키텍처 종류**

- 레이어드 아키텍처
- 파이프라인 아키텍처
- 마이크로커널 아키텍처

<br>

> **분산형 아키텍처 종류**

- 서비스 기반 아키텍처
- 이벤트 기반 아키텍처
- 공간 기반 아키텍처
- 서비스지향 아키텍처
- 마이크로서비스 아키텍처

<br>

> ### **분산 아키텍처를 고려할 때, 주의해야 할 오류 8가지**

1. [네트워크는 믿을 수 있다.](#네트워크는-믿을-수-있다)
2. [레이턴시는 0 이다.](#레이턴시는-0-이다)
3. [대역폭은 무한하다.](#대역폭은-무한하다)
4. [네트워크는 안전하다.](#네트워크는-안전하다)
5. [토폴로지는 절대 안바뀐다.](#토폴로지는-절대-안바뀐다)
6. [관리자는 한 사람 뿐이다.](#관리자는-한-사람-뿐이다)
7. [운송비는 0 이다.](#운송비는-0-이다)
8. [네트워크는 균일하다.](#네트워크는-균일하다)

<br>

### **네트워크는 믿을 수 있다.**

`네트워크` 신뢰도는 점점 좋아지고 있지만, 아직도 미덥지 못한 것이 사실이다.
`분산` 아키텍처는 그 특성상 서비스를 오가는, 또 서비스 간에 이동하는 `네트워크`에 의존하므로 주의해야한다.

설계를 할 때에는 `타임아웃(timeout)` 같은 장치를 마련하거나, 서비스 사이에 `회로 차탄기(circuit breaker, 서킷브레이커)`를 두도록 한다.
시스템이 (마이크로서비스 아키텍처처럼) **네트워크에 더 의존할수록 시스템의 신뢰도는 잠재적으로 떨어질 가능성이 높단 사실을 명심**하자.

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **레이턴시는 0 이다.**

우리는 운영 환경에서 `평균 왕복 레이턴시(average round-trip latency)`가 얼마나 되는지 알고 있는가?

어떤 `분산` 아키텍처를 구축하든지 간에 우리는 `평균 레이턴시`를 알고 있어야 한다. 이는 **분산 아키텍처가 실현 가능한지 판단하는 유일한 방법**이기 때문이다.

`평균 레이턴시`도 중요하지만, **95~99번째 백분위수(percentile)를 이해**하는 것은 더 중요하다. 평균 레이턴시가 60밀리초에 불과하더라도, 95번째 백분위수는 400밀리초 일 수 있기 때문이다. 그리고 이러한 `긴 꼬리(log tail) 레이턴시`가 **분산 아키텍처의 성능을 저해하는 주범**이 된다.

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **대역폭은 무한하다.**

`모놀리식` 아키텍처는 비즈니스 요청을 처리하는 데 그리 큰 대역폭이 필요하지 않으므로 대역폭이 문제될 일은 거의 없다.

하지만 `마이크로서비스` `분산` 아키텍처에서 시스템이 자잘한 배포 단위(서비스)로 쪼개지면 이 **서비스들 간에 주고받는 통신이 대역폭을 상당히 점유**하여 **네트워크가 느려지고, 레이턴시(오류1)와 신뢰성(오류2)에도 영향**을 준다.

**`스템프 커플링`(stamp coupling, 둘 이상의 모듈이 공유 데이터 구조를 통해 통신할 때 발생하는 것을 말한다.)** 을 우리는 주의해야한다.
`스탬프 커플링`은 분산 시스템에서  상당히 많은 대역폭을 차지하기 때문이다.

***분산 시스템에서는 서비스 또는 시스템 간에 최소한의 데이터만 주고받도록 하는 것이 오류를 바로잡는 최선의 길임을 명심하자.***

이를 해결하기 위한 다음과 같은 방법들이 존재한다. 

- **`프라이빗 REST API 엔드포인트`를 둔다.**

- **계약에 `필드 셀렉터(field selector)`를 사용한다.**

- **`GraphQL`로 계약을 분리한다.**", "**`컨슈머 주도 계약`(consumer-driven contract, CDC)와 `값 주도 계약`(value-driven contact,VBC)을 병용한다.**

- **내부 `메시징` `엔드포인트`를 사용한다.**

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **네트워크는 안전하다.**

보안은 `분산` 아키텍처에서 훨씬 더 어려운 문제이다. `분산` 배포된 각 `엔드포인트`는 알려지지 않은, 또는  **악의적인 요청이 해당 서비스로 유입되지 않게 철저한 보안 대책을 강구**해야한다.

`분산` 아키텍처에는 `모놀리식`보다 더 넓은 영역이 악의적인 외부인의 위협과 공격에 노출된다. **모든 엔드포인트에, 서비스 간 통신에도 보안이 적용**돼야 하므로 `마이크로 서비스`나 `서비스 기반 아키텍처`처럼 고도로 분산된 동기 아키텍처에서 당연히 **성능이 떨어진다.**

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **토폴로지는 절대 안바뀐다.**

**네트워크 토폴로지(`라우터`, `허브`, `스위치`, `방화벽`, `네트워크`, `어플라이언스`(appliance)는 절대 가만히 있질 않는다.**

*아무것도 변한게 없는데.. 타임아웃이 난다? 이때 의심해보도록하자.*

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **관리자는 한 사람 뿐이다.**

`분산` 아키텍처는 복잡할 수 밖에 없고 모든 것을 정상 궤도에 올려 놓으려면 **상당히 많은 조율과정이 불가피하다.**

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **운송비는 0 이다.**

여기서의 운송비란, 레이턴시가 아니라 "단순한 REST 호출을 하는데 소요되는 진짜 비용(actual cost)" 를 말한다.
`분산` 아키텍처는 `하드웨어`, `서버`, `게이트웨이`, `방화벽`, `신규 서브넷`, `프록시` 등 리소스가 더 많이 동원되므로 **모놀리식 아키텍처보다 비용이 훨씬더 많이 든다.**

`분산` 아키텍처를 시작할 때에는, `용량`, `대역폭`, `레이턴시`, `보안 구역` 측면에서 **현재의 서버와 네트워크 토폴로지를 철저히 분석**하도록 하자.

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

### **네트워크는 균일하다.**

네트워크는 하드웨어 업체 한 곳에서 만들지 않았기 때문에, **네트워크는 `균일`(homogeneous)하지 않다.**
`네트워크 패킷`이 유실되는 사고도 종종 발생한다. 그리고 이는 네트워크에 대한 끝없는 혼란과 당혹스러움을 시사한다.

*[목록으로](#분산-아키텍처를-고려할-때-주의해야-할-오류-8가지)*

<br>

> ### **다른 분산 아키텍처 고려사항**

1. [분산 로깅](#분산-로깅)
2. [분산 트랜잭션](#분산-트랜잭션)
3. [계약 관리 및 버저닝](#계약-관리-및-버저닝)

<br>

### **분산 로깅**

`분산`아키텍처는 애플리케이션과 `시스템 로그`가 `분산`되어 있어 **어떤 데이터가 누락된 근본 원인을 밝혀내기 어렵고 시간도 많이 소요된다.**

- `모놀리식` 애플리케이션은 로그가 하나뿐이라 추적하여 이슈를 특정하기 쉽지만, `분산` 아키텍처는 로그 종류만해도 수백가지에 달하고 위치도 제각각, 포맷도 제각각이라 참 어렵다.
- `스플렁크(splunk)` 같은 로깅 통합 도구를 사용하여, `분산` `로그`를 관리하도록 노력하자.

<br>

### **분산 트랜잭션**

 `분산`아키텍처는 `최종 일관성(evnetual consistency)`를 바탕으로 별도로 분리된 배포 단위에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화 한다.

- `확장성`, `성능`, `가용성`을 얻는 대가로, **데이터 일관성과 무결성을 희생하는 트레이드 오프이다.**
- 시스템 또는 서비스의 기본 가용성에 따라 시스템은 `아키텍처 패턴`과 `매시징`을 사용하여 결국 일관되게 맞춰진다.
- `분산 트랜잭션`을 관리하는 방법에는 `트랜잭셔널 사가(transactional saga)`, `BASE 트랜잭션` 등등 존재한다.

 *`사가`는 보상을 위해 이벤트를 소싱하거나 트랜잭션 상태를 관리하기 위해 `유한 상태 기계`(finite state machine)을 활용한다.*

 *`BASE`는 (**BA**)sic availability-기본 가용성, (**S**)oft state-소프트 상태, (**E**)ventual consistency-최종일관성 의 약자를 의미한다.*

 <br>

### **계약 관리 및 버저닝**

계약은 클라이언트와 서비스 모두 합의한 행위와 데이터이다. 분리된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 때문에 계약 유지보수는 특히 더 어렵다.
`버전 구식화(deprecation)`에 필요한 통신 모델은 더 더욱 복잡하다.
