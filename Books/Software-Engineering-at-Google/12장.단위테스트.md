# **단위 테스트(unit test)**

*단위테스트는 단일 클래스나 메서드 처럼 범위가 상대적으로 좁은 테스트를 말한다.(일반적으로 크기가 작지만 반드시 그런것은 아니다.*

테스트의 가장 중요한 목적은 버그 예방이다. 그 다음 중요한 목적을 이야기 한다면, 엔지니어의 생산성 개선을 이야기 할 수있다.

단위테스트는 다른 범위가 더 큰 테스트에 비교하여 생산성을 끌어올리는 훌륭한 수단이 될 수 있다.

<br>

> ### **단위테스트의 특징**
- 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉽다. 따라서 엔지니어들은 커다란 시스템을 설정하거나 이해할 필요 없이 작성중인 코드를 검증하는데 집중할 수 있다.
- 빠르게 작성할 수 있으므로 테스트 커버리지를 높이기 좋다. (커버리지가 높다면 엔지니어들은 기존 동작을 망가트리지 않으리라는 확신 속에서 코드를 변경할 수 있다.)
- 각각의 테스트는 개념적으로 간단하고 시스템의 특정 부분에 집중하므로 실패 시 원인을 파악하기 쉽다.
- 대상 시스템의 사용법과 의도한 동작 방식을 알려주는 문서자료 혹은 예제 코드 역할을 한다.

<br>

단위테스트는 엔지니어 일상에서 비중이 크기때문에 테스트 유지보수성(test maintainablility)을 상당히 중요하게 생각해야 한다. 

<br><hr><hr><br>

## **테스트 유지보수성(test maintainablility)**
*유지보수하기 쉬운 테스트는 그냥 작동하는 테스트를 말한다.*

유지하기 쉬운 테스트는 한번 작성해두면 실패하지 않는 한 엔지니어가 신경 쓸 필요가 없고, 혹은 실패하면 원인을 바로 알 수 있는 진짜 버그를 찾았음을 의미한다.

질 나쁜 테스트는 체크인 되기 전에 수정돼어야 한다. 그렇지 않다면 미래의 엔지니어들을 방해할 것이다.

<br>

테스트 유지보수성을 위해서 피해야하는 테스트는 다음과 같다.
1. 버그도 없고 자신의 검증 대상과 관련 없는 변경 떄문에 실폐하는 꺠지기 쉬운(brittle) 테스트
2. 애초에 무슨 기능을 어떻게 검사하려고 했는지 조차 이해되지 않는 테스트

<br>

> ### **깨지기 쉬운 테스트 예방하기**
*깨지기 쉬운 테스트란, 실제로는 버그가 없음에도, 심지어 검증대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트를 말한다.*

깨지기 쉬운 테스트는 엔지니어가 진단하고 수정해야한다.
따라서 근본적인 개선 없이 깨지기 쉬운 테스트를 계속 양산한다면 개발팀은 테스트를 유지보수 하기위해 많은 시간을 할애하게 된다.(그리고 이는 자동화테스트라고 이야기 할 수 없다.)

대규모 변경이라면 하루 수십만 개의 테스트가 동원되기도 하는데, 이런 규모에서는 아주 작은 비율의 테스트에만 영향을 주더라도 엄청난 양의 엔지니어링 시간을 낭비하게 된다. 


<br>

> ### **변하지 않는 테스트를 작성하기**
*이상적인 테스트라면 테스트 작성 이 후 변경하지 않아야한다.*

깨지기 쉬운 테스트를 피하기 위해서는 다음 질문에 대한 답을 해보아야한다.

<br>

*테스트를 처음 작성한 후 얼마나 자주 변경할 것이라고 생각하는가?*

<br>

이상적인 테스트라면 한 번 작성한 후로는 대상 시스템의 요구사항이 변경되지 않는 한 절대 수정할 일이 없어야한다.

<br>

**테스트를 작성하는 경우**

- 순수 리팩터링
    
    외부 인터페이스는 놔두고 내부만 리팩터링한다면 테스트는 변경되지 않아야 한다.(성능최적화, 코드 가독성 증진 등) 이 경우 테스트의 역할은 리팩터링 후에도 시스템의 행위가 달라지지 않았음을 보장하는 것이다. 

    리팩터링 과정에서 테스트를 변경해야 한다면 원인은 둘 중 하나이다.

    1. 시스템의 행위가 달라졌다.(순수 리팩터링이 아니다.)
    2. 테스트의 추상화 수준이 적절하지 않다.

<br>

- 새로운 기능 추가

    새로운 기능이나 행위를 추가할 때는 기존 행위들에 영향을 주지 않아야 한다. 새 기능을 검증할 테스트를 새로 작성해야 하며, 기존 테스트들은 변경되지 않아야 한다. 새로운 기능을 추가했는데 기존 테스트를 변경해야한다면 해당 테스트가 검증하는 기능에 의도치 않은 영향을 주었거나 테스트 자체에 문제가 있음을 알린다.

<br>

- 버그 수정

    버그가 존재한다는 것은 기존 테스트 스위트에 빠진 것이 있다는 신호이다. 따라서 버그 수정과 동시에 바로 그 누락됐던 테스트를 추가해야한다. 기존의 테스트들은 변경되지 않아야 한다.

<br>

- 행위 변경

    시스템의 기존 행위를 변경하는 경우로, 기존 테스트 역시 변경되어야 한다. 앞의 세가지 경우보다 일반적으로 더 비용이 드는 변경이다. 시스템 사용자들은 현재 행위에 의존하고 있을 것이다. 따라서 행위를 변경하려면 혼란에 빠지거나 업무가 중단되는 사용자가 없도록 조치해야한다.

    *테스트를 변경한다는 것은 시스템이 한 약속을 의도적으로 변경한다는 의미이다.


    저수준 라이브러리라면 사용자의 시스템을 망가트릴 일이 없도록, 애초부터 행위를 변경할 일이 없게끔 설계하는 데 엄청난 노력을 해야한다.


<br>

*리팩터링, 새 기능 추가, 버그 수정 시에는 기존 테스트를 손볼 일이 없어야 한다.*

<br>

기존 테스트를 수정해야하는 경우는 시스템의 행위가 달라지는 파괴적인 변경이 일어날 때뿐이다. 그리고 이런 상황에서의 테스트 갱신 비용은 모든 사용자의 코드를 갱신하는 비용보다 대체로 저렴하다.

<br>

> ### **공개 API 를 이용하여 테스트하자**
*공개 API를 정문(front door)에 빗대어 '정문 우선 원칙을 따르라 라고 말하기도 한다.(Use the front door first principle)'*

요구사항이 변하지 않는 한 테스트르 수정 할 필요 없게 만들어주는 방법은 "테스트도 시스템을 다른 사용자 코드와 똑같은 방식으로 호출하기" 이다.

테스트를 다른 사용자코드와 똑같은 방식으로 호출하기 위해서는 내부 구현을 위한 코드가 아닌 공개 API를 호출하면 된다.
즉, 태스트가 시스템을 사용자와 똑같은 방식으로 사용하는 것이다. 이 방법을 사용하게 된다면 테스트가 실패하면 사용자도 똑같은 문제를 겪을 것 이다.그리고 이는 테스트가 사용자에게 유용한 예제 코드와 문서자료가 된다

<br><br>

> **예제 코드: 은행 거래 API**
```java
public void processTransaction(Transaction transaction){
    if (isValid(transaction)) {
        saveToDataBase(transaction);
    }
}

private boolean isValid(Transaction t) {
    return t.getAmount() < t.getSender().getBalance();
}

private voidsaveToDataBase(Transaction t) {
    String s = t.getSender() + "," + t.getRecipient() + "," + t.getAmount();
    database.put(t.getId(), s);

public void setAccountBalance(String accountName, int balance) {
    // 잔고를 데이터베이스에 직접 기록한다.
}

public void getAccountBalance(String accountName) {
    // 계좌 잔고를 확인하기 위해 데이터베이스로부터 거래 정보를 읽어온다.
}
}
```

<br>

> **거래 API의 구현을 바로 검증하는 경솔한 테스트**
```java
@Test
public void emptyAccountShouldNoBeValid() {
    asserThat(processor.isValid(newTransaction().setSender(EMPTY_ACCOUNT))).isFalse();
}

@Test public void shouldSaveSerializedData() {
    processor.saveToDatabase(newTransaction()
        .setId(123)
        .setSender("me")
        .setRecipient("you")
        .setAmount(100));
    assertThat(database.get(123)).isEqualTo("me,you,100");    
}

```

이 테스트는 거래 시스템을 실제 사용자와는 매우 다른 방식으로 사용한다.(시스템 내부로 들어가 공개되지 않은 메서드를 호출하고 있다.) 결과적으로 이 테스트는 깨지기 쉬워진다.(내부 메서드의 이름을 바꾸거나 일부 로직을 도우미 클래스(helper class)로 빼내거나 직렬화 포맷을 바꾸는 등)

<br>

하지만 공개 API만 사용해서도 같은 수준의 테스트커버리지를 달성할 수 있다.

<br>

> **공개 API로 테스트**
```java
@Test
public void shouldTransferFunds() {
    processor.setAccountBalance("me", 150);
    processor.setAccountBalance("you", 20);

    processor.processTransaction(newTransaction()
        .setSender("me")
        .setRecipient("you")
        .setAmount(100));

    assertThat(processor.getAccountBalance("me")).isEqualTo(50);
    assertThat(processor.getAccountBalance("you")).isEqualTo(120);
}

@Test
public void shouldNotPerformInvalidTransactions() {
    processor.setAccountBalance("me", 50);
    processor.setAccountBalance("you", 20);

    processor.processTransaction(newTransaction()
        .setSender("me")
        .setRecipient("you")
        .setAmount(100));
    
    assertThat(processor.getAccountBalance("me")).isEqualTo(50);
    assertThat(processor.getAccountBalance("you")).isEqualTo(20);
}
```

이는 시스템이 명시한 규약을 따르기 때문에 테스트가 더 현실적이고 잘 깨지지 않는다. 만약 이런 테스트가 깨진다면 다른 사용자들도 같은 문제를 겪고 있다는 신호이며, 명시된 규약만을 검증한다면 시스템의 내부는 얼마든지 리팩터링 해도 문제가 없다.

<br>

*어디까지가 공개 API 인지는 명확한 것은 아니다. 이런 맥락에서의 공개 API는  코드 소유자가 서드파티에 노출한 API 를 말한다.*

<br>

<br><hr><hr><br>

