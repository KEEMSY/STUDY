# 테스트 대역(test double)
*테스트 대역이란 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다. 테스트 대역은 영화의 스턴트맨 이라 말 할 수 있다.*

가장 직관적인 유형의 테스트 대역은 실제와 비슷하게 동작하되 더 간단하게 구현한 객체일 것이다.(인메모리 데이터베이스가 대표적!)

테스트 대역은 실제 구현보다 훨씬 가벼워서 여러 프로세스나 기기를 연동시킬 때 마저도 빠르고 안정적인 작은테스트로 부터 대응할 수 있게 해준다.

<br><hr><hr><br>

## 테스트 대역이 소프트웨어 개발에 미치는 영향

테스트 대역을 사용하면 소프트웨어 개발시 필요한 복잡한 문자가 딸려온다.

1. **테스트 용이성(testablility)**

    테스트 대역을 사용하면 코드베이스가 테스트하기 쉽도록 설계 되어있어야 한다. 그래야 테스트에서 실제 구현을 테스트 대역으로 교체할 수 있다. 

    데이터베이스를 호출하는 코드라면 실제 데이터베이스 대신 테스트 대역을 사용해도 괜찮을 만큼 유연해야 한다.

    *테스트를 염두에 두지 않고 설계된 코드라면 상당히 많이 리팩터링 해야할 것이다.*

<br>

2. **적용 가능성(applicability)**

    테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선될 수 있지만, 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전략한다.

    *실제로 테스트 대역을 활용하기에 적절하지 않은 경우가 많아 되도록이면 실제 구현을 이용하도록 하자.*

<br>

3. **충실성(fidelity)**
    
    *충실성이란 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말한다.*
    
    테스트 대역이 실제 구현과 전혀 다르게 동작하거나, 입력 데이터를 무시하고 항상 똑같은 결과만 반환한다면 테스트 대역은 유용하다 말할 수 없다.

    뿐만아니라 100% 충실한 것 역시 현실적이지 않지만, 많은 상황에서 완벽하게 충실하지 못한 대역만으로도 테스트는 충분한 효과를 얻을 수 있다.
    
    하지만, 테스트 대역을 사용하는 단위 테스트만으로 채우지 못하는 부분이 생갈 수 있는데 해당 부분은 실제 구현을 이용하는 더 큰 범위의 테스트로 보완해야한다.

<br><hr><hr><br>


## 테스트 대역의 위험
*테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다.*

모의 객체 프레임워크를는 의존하는 다른 모듈들에 신경쓰지 않고 우너하는 코드 조각에 집중하는 테스틀르 매우 쉽게 만들 수 있게 해준다.

하지만 이런 테스트가 많아지면 많아질 수록 테스트를 작성하기는 쉽지만, 버그를 찾아내기에는 점점 더 어려워진다. 

이러다 결국 모의 객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성하게 된다.

<br>

>### **테스트 대역 예시**

```java
class PaymentProcessor {
    private CreditCardService cericCardService;
    ...
    boolean makePayment(CreditCard creditCard, Money amount) {
        if (creditCard.isExpired()) {return false;}
        boolean success =
            creditCardService.chargeCreditCard(creditCard, amount);
        return success;
    }
}
```

테스트에서 실제 신용카드 서비스를 이용하는 건 어불성설이지만 테스트 대역에서 실제 시스템의 행위를 '흉내' 낼 수 있다.

> **테스트 대역 적용**
```java
@Test public void cardIsExpired_returnFalse() {
    boolean success = paymentProcessor.makePayment(EXPIRED_CARD, AMOUNT);
    assertThat(success).isFalse();
}
```
 
 <br>

 > ### **이어주기**
 *단위 테스트를 고려해 짜인 코드는 테스트 하기 쉽다(testable)고 이야기 할 수 있다.*

 이어주기(seam) 이란 제품 코드 차원에서 테스트 대역을 활용할 수 있는 길을 터, 테스트 하기 쉽게끔 만들어 주는것을 말한다.

 <br>

 *프로던션 환경에서 이용하는 의존 대상을 다른 대상으로 교체할 수 있도록 하면 된다.*

 <br>

대표적인 이어지구 기술로는 의존성 주입(DI: Dependency Injection) 이 있다.

의존성 주입(DI)을 활용하면 필료한 클래스(의존성)을 내부에서 직접 생성하지 않고 외부에서 건내 받는다. (이 덕분에 테스트는 이 클래스의 의존성을 원하는 다른 객체로 대체할 수 있다.)

<br>

> **의존성 주입**
```java
class PaymentProcessor {
    private CreditCardService creditCardService;

    PaymentProcessor(CreditCardService creditCardService) {
        thist.creditCardService = creditCardService;
    }
    ...
}
```
적절한 CreditCardService 인스턴스를 생성할 책임은 생성자를 호출하는 측에 주어진다. 

<br>

*프로덕션 코드에서는 외부 서버와 통신하는 CreditCardService 를 구현하겠지만, 테스트 코드에서는 그렇지 않아도 된다.*

<br>

> **테스트 대역 건내기**
```java
PaymentProcessor paymentProcessor = 
    new PaymentProcessor(new TestDoubleCreditCardService());
```
더 나아가 자동 의존성 주입 프레임워크를 이용하면 테스트 작성자가 생성자를 직접 수정하는 수고를 덜 수 있다. (구글에서는 Guice 와 Dagger 를 사용한다.)



시간이 지날수록 코드베이스를 수정하기 점점 어려워지기 때문에 테스트를 염두에 두지 않고 작성된 코드를 검증하려면 리팩터링부터 하거나 심지어 다시 작성해야 할 수 도 있다.

<br>

*테스트 하기 쉬운 코드를 작성하려면 선행적인 투자가 필요하다.*

<br>

> ### **모의 객체 프레임워크**
*모의 객체 프레임워크(mocking framework)는 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리이다.*

모의 객체 프레임워크는 객체를 대역으로 대체할 수 있게 해준다. 

<br>

*모의 객체(mock) 은 구체적인 동작 방식을 테스트가 지정할 수 있는 객체를 말한다.*

<br>

모의 객체 프레임워크를 사용하면 테스트 대역이 필요할 때마다 새로운 클래스를 정의하지 않아도 되므로 보일러플레이트 코드를 줄일 수 있어, 테스트 대역을 손쉽게 사용할 수 있다.

하지만 모의객체 프레임워크는 과용하면 코드베이스를 유지보수하기 어렵게 된다는 심각한 부작용이 존재하기 때문에 주의해야한다.

<br><hr><hr><br>