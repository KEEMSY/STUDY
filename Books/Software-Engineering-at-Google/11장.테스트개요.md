# **테스트 개요**
*자동화 테스트는 버그가 몰래 숨어들어 고객을 놀라게 하는 사태를 막아준다.*

개발 주기에서 버그를 발견하는 시기가 늦어질수록 고치는 비용이 (기하급수적으로)커진다. 테스트는 이러한 버그를 잡아 줄 수 있다. 뿐만아니라 테스트는 이 외에도 많은 기능을 할 수 있다.(새로운 기능추가, 코드를 리팩토링, 대규모 재설계 시 자동화 테스트를 통한 실수 예방 등)

테스트 체계가 잘 갖춰져 있다면, 변화를 두려워할 이유가 없다.(변화하는 기술, 시장상황, 고개 취향을 더 빠르게 받아들일 수 있다.)

테스트를 작성하는 행위는 시스템의 설계또한 개선시켜준다. 테스트는 시스템 코드의 첫번째 고객이라는 자격으로 선택한 설계에 관한 많은 이야기를 전해준다.

<br>

*데이터베이스에 너무 강하게 묶여 있는지, 이 API 가 필수 유스케이스를 지원하는지, 시스템이 극단적인 상황들에 잘 대처하는지 등을 확인 할 수 있다.*

<br>

자동화 테스트를 작성하면 이런 문제를 개발 주기 초반에 잡아낼 수 있고, 이 결과 모듈화가 더 잘되어 미래의 변화에 훨씬 유연한 소프트웨어를 만들어 낼 수 있다.

<br><hr><hr><br>

## **테스트를 작성하는 이유**
*테스트는 엔지니어에게 신뢰를 줄 때만 가치가 존재한다.*

테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 우리 삶에서 중요한 제품과 서비스의 안전을 보장하는데도 점점 핵심적인 역할을 한다. 

<br>

> ### **테스트 란**
- 테스트하려는 단 하나의 행위(주로 메서드나API)
- 특정한 입력(API에 전달하려는 값)
- 관측 가능한 출력 혹은 동작
- 통제된 조건(하나의 격리된 프로세스 등

<br>

> ### **테스트스위트(test suite)**
*간단한 테스트가 수백에서 수천 개 모인 것을 말한다.*

테스트 스위트는 제품이 전체적으로 의도한 설계대로 잘 작동하는지, 혹은 언제 그렇지 못한지를 이야기 해주며, 코드베이스의 덩치에 비례하여 데스트 스위트의 크기도 커진다. 

테스트의 결과가 일관되지 못하거나 느려는 문제를 해결하지 못한다면 테스트 스위트의 존폐가 위태로워 진다. 우리는 테스트의 가치는 엔지니어에게 신뢰를 줄 떄만 존재한다는 사실을 잊어서는 안된다. 테스트가 생산성을 떨어트리고 고칠 게 계속 나오거나 결과를 믿을 수 없다면 엔지니어들은 더 이상 테스트를 신뢰하지 않고 우회방법을 찾을 것이다.

<br>

*나쁜 테스트 스위트는 테스트가 아예 없는 것만 못하다는 사실을 명심하자.*

<br><hr><hr><br>

## **테스트를 작성하는 법**
*작성하고, 수행하고, 조치하라*

가장 순수한 형태의 자동 테스트는 "테스트 작성", "테스트 수행", "실패한 테스트에 대한 조치" 이렇게 세 가지 활동으로 이루어 진다.

자동화 테스트는 적은 양의 코드로 구성되며, 보통 테스트 대상 시스템의 일부를 호출하는 함수나 메서드 하나로 만들어진다. 

테스트 코드는 환경을 원하는 모습으로 설정하고,( 보통은 이미 알고 있는 데이터를 입력한다.) 시스템을 호출하고, 결과를 검증한다. 

<br>

```java
// 자동화 테스트의 핵심은 아주 단순한 이 예시와 매우 비슷하다.

public void main(String[] args) {
    Calculator calculator = New Calculator();
    int expectedResult = -3;
    int actualResult = calculator.subtract(2,5); // 2에서 5를 뺀다.
    assert(expectedResult == actualResult)
}
```

<br>

테스트 작성은 테스트 자동화 프로세스의 첫 번째 단계일 뿐이다. 테스트를 작성한 후에는 작성한 테스트를 수시로 실행해야 한다.

<br>

*자동화 테스트의 핵심은 같은 동작을 끊임없이 반복하는데 있다.*

<br>

테스트 프로세스의 효율성은 테스트 실패를 어떻게 처리하느냐에 달려있다. 실패하는 테스트가 해결되지 못하고 빠르게 쌓여간다면 테스트에 투자한 노력은 허사되니 이렇게 되지 않는 것이 중요하다.(테스트를 수 분내로 해결하도록 하는 팀이라면 제품과 테스트를 더 신뢰하며 오류를 빠르게 퇴치할 수 있다.(테스트로부터 얻는것이 더 많아진다.))

<br>

*건실한 자동 테스트 문화에서는 모두가 테스트를 작성하고 공유하도록 한다. 작성된 테스트들은 정기적으로 실행하며, 테스트가 실패하면 바로 조치하도록 한다.*

<br><hr><hr><br>

## **테스트 코드가 주는 혜택**
*테스트를 작성하면 생산성과 속도가 높아진다.*

<br>

### **1. 디버깅 감소**
*테스트를 한번 작서해 두면 프로젝트가 살아 있는 내내 값비싼 결함을 예방해주고 디버깅에서 해방시켜준다.*

테스트를 거친 후 submit 되는 코드는 통상적으로 결함이 적다. 결함 대부분이 submit 되기 전에 고쳐지기 때문에 그 코드의 존속 기간전체로 봤을 때 결함이 줄어든고 말할 수 있다.

 프로젝트 자체 혹은 프로젝트가 의존하는 다른 코드가 변경되어 테스트가 실패한다면 테스트 인프라가 곧바로 인지해내어, 프로덕션 환경으로 릴리스되기 전에 정상 상태로 되돌릴 수 있다.

<br>

### **2. 자신 있게 변경 할 수 있다.**
*모든 소프트웨어는 변경된다.*

좋은 테스트로 무장한 팀은 자신감을 가지고 변경들을 리뷰하고 수용할 수 있다. 이는 테스트들이 프로젝트의 주요 기능들을 끊임없이 검증해주기 때문이다. 이런 프로젝트에선 자연스럽게 리팩터링을 권장하며, 리팩터링 시 (이상적으로) 기존 테스트를 수정할 필요조차 없다.

<br>

### **3. 더 나은 문서 자료가 된다.**
한번에 하나의 행위만 집중해 검증하는 명확한 테스트는 마치 실행 가능한 문서와 같다. 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다. 나아가 요구사항이 변경되어 새로운 코드가 기존 테스트를 통과하지 못한다면 문서자료(테스트)가 낡았음을 인지 할 수 있다.

<br>

*테스트는 명확하고 간결해야만 문서자료로서의 역할을 훌륭하게 수행할 수 있다.*

<br>

### **4. 더 단순한 리뷰가 가능하다.**
정확성, 극단 상황, 오류 상황 등 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지를 검증하는 시간을 크게 줄여준다. 각각의 상황을 머리속에서 일일이 그려보는 대신 해당 테스트를 수행해 봄으로써 통과하는지만 보면 되기 때문이다.

<br>

### **5. 더 사려깊은 설계를 하게 된다.**
*테스트하기 어려운 코드는 너무 많은 역할을 짊어지거나 의존성을 관리하기 어렵게 짜여 잇기 때문일 가능성이 크다.*

잘 설계된 코드라면 자고로 모듈화가 잘 되어 있어야한다. 즉 다른 코드와 강하게 결합되어 있지 않고 특정 역할에 집중해야한다. 설계 문제를 조기에 바로잡는다면 훗날 수정할 때 고생을 덜할 수 있다.

<br>

### 6. 고품질의 릴리스를 빠르게 할 수 있다.
*자동화 테스트 스위트를 갖춘 팀은 새로운 버전을 릴리스하며 불안에 떨지 않는다.*

<br><hr><hr><br>

## **테스트 스위트 설계하기**
*시스템 규모의 테스트는 작은 테스트와 비교하여 느리고 신뢰도가 낮으며, 디버깅하기 어렵다.*


더 작은 테스트는 엔지니어의 고통을 줄여준다. 더 작은 테스트가 더 빠르고 안정적이고, 평균적으로 고통이 더 적다.

모든 테스트는 밀폐(hemetic)되어야한다.( 셋업(setup), 실행(execute), 테어다운(tear down) 에 필요한 모든 정보를 담고 있어야한다.)
또한 테스트 수행 순서 같은 외부 환경에 관해서는 가능한 아무것도 가정하지 않아야한다.(테스트 각각을 격리해야한다.)

테스트는 확인하려는 행위를 수행하는데 필요한 정보만을 포함해야한다.(=테스트는 무엇을 검사하는지가 명확해야한다.) 테스트가 깔끔하고 간결하다면 테스트가 의도대로 동작하는지 검증하기 편해진다.

테스트는 오직 실패 했을 때만 다시 들여다 봐야한다.

<br>

> ### **테스트의 크기는 어떻게 정의 할 수 있을까?**
*테스트 케이스에는 "크기(size)"와 "범위(scope)"의 두가지 독립된 요소가 존재한다.*

크기와 범위는 서로 연관되어 있지만 분명히 다른 개념이다.

<br>

**크기(size)**: 테스트 케이스 하나를 실행하는 데 필요한 자원을 의미한다. 
- 모든 테스트는 밀폐(hermetic) 되어야한다.
- ex) 메모리, 프로세스, 시간 등

<br>

**범위(scope)**: 얼마나 많은 코드를 검증하느냐를 말한다.

<br>

테스트의 크기를 가늠하는 기준은 코드 줄 수 가 아니다. 테스트는 어떻게 동작하고, 무엇을 하고, 얼마나 많은 자원을 소비하는지를 통해 평가한다.

작은 테스트는 프로세스 하나에서 동작하고, 중간 크기 테스트는 기기하나에서, 큰 테스트는 자원을 원하는 만큼 사용해서 동작한다.

<br>

![테스트크기](/img/테스트크기.png)

<br>

> ### **작은 테스트**
*작은 테스트는 세가지 테스트 중 제약이 가장 엄격하다.*

작은 테스트는 테스트가 단 하나의 프로세스에서 실행되어야 한다. 즉, 테스트도 테스트 대상 코드와 같은 프로세스에서 실행되어야한다.(서버를 두고 독립된 테스트 프로세스에 연결해 수행하는 방법도 안된다. 또한 데이터베이스와 같은 제 3의 프로그램을 수행해서도 안된다.)

뿐만아니라 sleep, I/O 연산 등 블로킹 호출을 사용해서는 안된다.(네트워크에 디스크에도 접근 할 수 없음을 의미한다.)
블로킹 호출을 수반하는 대상을 검사하는 테스트 코드는 테스트 대역을 사용해야 한다.

<br>

*테스트 대역(test double)은 강한 의존성을 가벼운 인프로세스(in-process) 의존성으로 대체해주는 수단이다.*

<br>

가능한 언제나 테스트 하는 범위와 상관없이 전체 테스트 스위트를 빠르고 안정되게 만들주는  작은 테스트를 작성하도록 하자.

<br>

> ### **중간 크기 테스트**
*중간 크기 테스트는 여러 프로세스와 스레드를 활용할 수 있고, 로컬 호스트로의 네트워크 호출 같은 블로킹 호출도 이용 할 수 있다.(단, 외부시스템과의 통신은 여전히 불허하다.)*

중간 크기 테스트는 여러 프로세스를 사용할 수 있게 되면서 할 수 있는 일이 크게 늘어난다.
- 데이터 베이스 인스턴스를 실행할 수 있다.: 테스트 대상 코드를 더 현실적인 설정 하에 검증 가능
- 웹 UI와 서버 코드 조합 테스트

<br>

유연성이 커지면서 반대급부로 테스트는 느려지고 비결정적이 될 가능성이 높아진다. 여러 프로세스에 걸쳐 있거나 블로킹 호출을 시작하면운영체제나 서드파티 프로세스에 의존하게 된다.

<br>

*외부요안아 개입된다는 것은, 성능과 결정성을 온전히 스스로 보장할 수 없음을 의미한다.*

<br>

원격 호출은 대부분의 시스템에서 속도를 떨어트리고 비결정성을 높이는 가장 독보적인 원흉이다. 따라서 중간 크기 테스트를 작성하는 엔지니어는 작은 테스트를 작성할 때보다 훨씬 주의해야한다.

<br>

> ### **큰 테스트**
*큰 테스트는 테스트와 대상 시스템이 여러 대의 기기를 활용할 수 있다.*

큰 테스트는 중간 크기 테스트 보다 더 유연해지는 만큼 위험도 더 늘어난다. 
여러 기기에 걸쳐 있는 시스템을 네트워크로 연결해 다루게 되면서 단일 기기에서 구동할 때보다 느려지거나 비결정성이 커질 가능성이 훨씬 높아진다.

따라서, 큰 테스트는 용도를 제한하여 사용하여야 한다.
1. 시스템 종간단 테스트(end-to-end): 코드 조각이 아닌 설정을 검증하는 것이 목적인 테스트
2. 테스트 대역을 사용하는 것이 불가능한 레거시 컴포넌트의 테스트

<br>

*큰 테스트를 작은 테스트나 중간 크기 테스트와 분리하여 빌드나 릴리스 할 때만 수행하도록 개발 워크 플로에 영향을 주지 않도록 하자.*


<br>

> ### **불규칙한 테스트**
테스트 결과가 불규칙한 상황이 계속된다면 생산성 저하 뿐만아니라, 테스트를 못믿게 되는 상황에 이르게 된다. 실패하는 테스트의 원인을 몇번만 조사하다보면 테스트 스위트에 대한 믿음이 깨지게 된다. 

대부분의 불규칙한 실패는 테스트 자체에 비결정적으로 동작하는 로직으로 인해 발생한다.

<br>

*비결정적 로직: 클록시간, 스레드 스케줄링, 네트워크 지연시간 등*

<br>

좋은 자동 테스트 인프라라면 이러한 갖가지 비결정적인 동작을 엔지니어가 쉽게 파악하고 완화하는데 도움을 주어야 한다.

<br>

> ### **테스트 범위**
*테스트 범위란 테스트가 얼마나 많은 코드를 검증하느냐를 말한다.*

단위테스트(좁은 범위 테스트)는 빠르고 안정적이며 범위를 극적으로 좁혀줘, 독립된 클래스나 메서드 같이 코드베이스 중 작은 일부 로직을 적은 노력으로도 검증하도록 설계 한다.

통합테스트(중간 범위 테스트)는 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계된다.(서버와 데이터베이스의 상호작용을 검증한다.)

기능테스트(functional test), 종단간 테스트(end-to-end test), 시스템 테스트(system test) [넓은 범위 테스트] 는 시스템의 서로 다른 부분들 사이의 상호작용, 혹은 클래스나 메서드 하나만 실행할 때는 괜찮다가 여럿을 조합해 실행하면 나타나는 예기치 못한 동작을 검증하도록 설계된다. 

<br>

*단위 테스트의 범위가 좁다고 할 때는 '실행' 되는 코드가 아니라 '검증' 되는 코드의 양이 기준이다.*

<br>

일반적으로 좁은 범위 테스트는 작은 테스트가 되고 더 넓은 범위 테스트들은 중간 크기나 큰 테스트가 되는 것이 일반적이다.(절대적인 것은 아니다.)

<br>

*가능한 작고 좁은 범위의 테스트를 작성하자.*

<br>

![테스트비율](/img/테스트비율.png)
*바람직한 테스트스위트 비율, 풍부한 단위테스트는 개발 초기에 빠르게 신뢰도를 높여준다. 더 큰 테스트들의 역할은 제품이 제 모습을 갖춰감에 따른 온정성 검사이다.(버그를 잡기위한 수단으로 보지 말자.)*

<br><br>

![모래시계테스트](/img/잘못된테스트비율.png)
*잘못된 모래시계 테스트스위트 비율, 중간 범위 테스트였다면 더 빠르고 쉽게 해결했을 문제들을 종단간 테스트로 막아내고 있는 상태로 구성요소들이 강하게 커플링되어 각각의 인스턴스를 독립적으로 만들어 낼 수 없을 때 나타난다.*


<br><br>

![아이스크림콘테스트](/img/아이스크림콘.png)
*잘못된 아이스크림 테스트스위트 비율, 이런 테스트는 일반적으로 느리고 신뢰할 수 없으며, 고치기도 어렵다. 이러한 패턴은 프로토타입에서 시작하여 급하게 프로덕션으로 이전하느라 테스트부채를 미처 해결하지 못한 프로젝트에서 자주 나타나는 안티패턴이다.*

<br>

통합 테스트 비율을 늘리면 테스트 스위트의 전체 수행시간은 길어지지만 구성 요소 사이의 문제를 더 많이 잡아 낼 수 있다. 단위테스트 비율을 늘리면 테스트 스위트가 매우 빠르게 완료되고 일반적인 로직 버그를 많이 잡아 낼 수 있다. 하지만 단위 테스트는 구성요소간 상호작용은 검증 할 수 없다.

<br>

***따라서 다양한 크기와 범위의 테스트가 시스템 아키텍처와 조직의 현실에 맞게끔 조화롭게 혼합되어 있다면 이상적인 테스트 스위트라 이야기 할 수 있다.***

<br>

> ### **무엇을 테스트해야할까?(비욘세 규칙)**
*네가 좋아했다면 (CI) 테스트를 준비해뒀어야지*

테스트를 그래서 "어떤 행위나 속성을 테스트 해야할까?" 에 대한 대답은 "깨트려보고 싶은 모든 것을 테스트 하라" 이다.

<br>

*시스템이 특정 행위를 올바로 수행하는지 확신하고 싶다면, 그 행위를 검증하는 자동 테스트를 작성하는 것만이 유일한 선택지 이다.*

실패는 시스템이 고려해야하는 가장 중요한 상황 중 하나이다. 시스템이 재난에 잘 대응하는지 보기 위해 실제로 재난이 일어날 때 까지 기다리는 것은 어리석다. 대신 흔한 유형의 실패 상황을 시물레이션하는 자동 테스트를 작성하자.

단위테스트라면 예외나 에러를 시뮬레이션 해볼 수 있고, 통합 테스트나 종단간 테스트라면 원격 프로시저 호출(RPC) 오류를 주입하거나 지연시간을 늘려볼 수 있다. 

신뢰하는 시스템이라면 부정적인 조건을 예측하고 대응 방식을 통제 할 수 있어야 한다.

<br><hr><hr><br>

## **코드 커버리지**
*코드 커버리지는 어느 테스트가 기능 코드의 어느 라인을 실행하는지를 측정하는 수단이다. 즉, 테스트되지 않은 코드가 어디인지 알려줄 수 있지만, 시스템이 얼마나 제대로 테스트되었느냐를 판가름하는 지표로는 적합하지 않다.*

코드 커버리지는 테스트 품질을 파악하는 표준 지표로 간주되기도하는데, 이는 잘못된것이라고 이랴기 할 수 있다. 적은 수의 테스트 만으로도 상당량의 라인을 실행하면서도 의미있는 동작을 돌려보지 않았을 수도 있기 때문이다.

코드 커버리지는 호출된 라인 수만 셀 뿐, 실행 결과로 어떤 일이 벌어졌는지는 고려하지 않는다.
따라서 코드 커버리지가 테스트 품질을 파악하는 표준 지표로 사용되서는 안된다.

<br>

*큰 테스트는 커버리지 인플레이션을 일으키므로 커버리지는 작은 테스트에서만 측정하도록 하자*

<br>

테스트 스위트의 품질을 높이기 위해서는 검사 할 행위에 집중하는 것이다. 행위에 집중하여 테스트를 작성하면, 고객이 이용할 모든 기능이 제대로 동작한다 확신할 수 있다. 또한 외부 시스템이나 모듈에 관해 호환성이 깨졌을 때 바로 인지하고 대응할 수 있다.

<br><hr><hr><br>

## **대규모 테스트 스위트의 함정**
*깨지기 쉬운 테스트와 같은 품질낮은 테스트는 테스트 스위트가 커질 수록 문제로 들어난다.*

테스트를 많이 작성한다고, 좋은 테스트라고는 할 수 없다. 깨지기 쉬운 테스트로 가득한 거대한 테스트 스위트는 수행 시간이 길어지고 비결정적이게 되며 이로인해 자연스럽게 실행빈도는 줄어들 것이다.(결국 테스트는 퇴화될 것이다.)

거대한 테스트 스위트를 잘 관리하는 비결은 테스트를 존중하는 문화를 만들어 나가는 것이다. (엔지니어들이 테스트에 관심을 갖도록 장려하는 것이다.)

적절한 성능 목표를 설정하고, 느리고나 중요하지 않은 테스트는 리팩터링한다. 기본적으로 테스트도 제품 코드처럼 다뤄야한다. 

<br>

*간단한 코드변경에도 시간이 제법 소요된다면 테스트를 더 견고하게 만든느데 노력을 하자*

<br>

> ### **깨지기 쉬운 테스트**

예상 결과를 너무 세세하게 표현하거나 광범위하고 복잡한 상용구의 테스트는 품질 낮은 테스트라 이야기할 수 있다. 품질낮은 테스트는 약간의 코드만 변경되어도 실패할 수 있으며, 이런 테스트는 테스트의 장점을 모두 상쇄시켜버린다.


<br><hr><hr><br>

## **테스트 인증(test cerified)**
*테스트인증의 목적은 각 팀이 자신의 테스트 프로세스 수준(성숙도)를 알게하고 한 단계 올라서기 위한 지침을 제공하기 위함이다.*

테스트 레벨은 총 5레벨로 구성되며, 해당 레벨렬로 인정받는 데 필요한 조건이 존재한다.

테스트 인증 레벨 1을 만족하기 위한 조건은 다음과 같다.
- 지속적 빌드 구축
- 코드 커버리지 추적
- 모든 테스트를 작은/중간크기/큰 테스트로 구분
- 불규칙한 테스트 식별(꼭 수정할 필요는 없음)
- 빠른 테스트 마련

<br>

레벨이 높아질수록 다음과 같이 같이 더 어려운 조건이 추가된다.
- 실패하는 테스트가 없어야 릴리스 가능 
- 비결정적인 테스트 모두 제거 

<br>

레벨 5가 되기위한 조건은 다음과 같다.
- 모든 테스트를 자동화한다.
- 모든 커밋 전에 빠른 테스트 스위트가 수행되도록한다.
- 비결정성을 완전히 제거하고, 모든 행위를 테스트 한다.

<br><hr><hr><br>

## 자동 테스트의 한계
*모든 종류의 테스트를 모두 자동화 할 수는 없다. 검색결과의 품질을 테스트하려면 사람의 판단이 개입되어야한다.*

창의력이 필요한 분야에서는 인간이 더 뛰어날 수 있다. 예를 들어 복잡한 보안 취약점을 찾는 일은 자동 시스템보다 사람이 더 뛰어난 영역이다. 사람이 특정 결점을 발견하고 이해한 다음에는 자동 보안 검사 시스템에 테스트를 추가해 지속적으로 수행하고 확장한다. 그리고 이를 탐색적 테스팅(exploratory testing) 이라 말한다.

<br>

> ### **탐색적 테스팅**
*기본적으로 창으력을 요구하며, 검사 대상을 마치 고장내야 할 퍼즐로 취급한다.*

탐색적 테스팅은 무슨 문제를 찾아내는 것을 목표로 시작하지 않는다. 간과되던 코드 실행 경로에서 시작한다. 혹은 정상적이지 않았던 응답을 조사하며 점진적으로 문제를 알아가기도 한다.

탐색적 테스팅으로 문제를 발견하는 즉시 자동 테스트를 추가하여 문제가 재발하지 않도록 예방한다.

<br>

*탐색적 테스팅을 통해 파악한 문제의 행위들을 자동 테스트에 맡겨 놓으면 몸값이 비싼 인간 테스터들은 지루한 반복 작업에서 벗어나 인간이 가장 잘할 수 있는 영역에 집중할 수 있게 된다.*

<br><hr><hr><br>

## **정리**
- 자동화 테스트는 소프트웨어를 변경할 수 있게 해주는 토대이다.
- 테스트를 확장하려면 반드시 자동화 해야한다.
- 테스트 커버리지를 건실하게 유지하려면 균형 잡힌 테스트 스위트가 필요하다.
- "네가 좋아했다면 테스트를 준비해뒀어야지."
- 조직의 테스트 문화를 바꾸는데느 시간이 걸린다.
