# **테스트 개요**
*자동화 테스트는 버그가 몰래 숨어들어 고객을 놀라게 하는 사태를 막아준다.*

개발 주기에서 버그를 발견하는 시기가 늦어질수록 고치는 비용이 (기하급수적으로)커진다. 테스트는 이러한 버그를 잡아 줄 수 있다. 뿐만아니라 테스트는 이 외에도 많은 기능을 할 수 있다.(새로운 기능추가, 코드를 리팩토링, 대규모 재설계 시 자동화 테스트를 통한 실수 예방 등)

테스트 체계가 잘 갖춰져 있다면, 변화를 두려워할 이유가 없다.(변화하는 기술, 시장상황, 고개 취향을 더 빠르게 받아들일 수 있다.)

테스트를 작성하는 행위는 시스템의 설계또한 개선시켜준다. 테스트는 시스템 코드의 첫번째 고객이라는 자격으로 선택한 설계에 관한 많은 이야기를 전해준다.

<br>

*데이터베이스에 너무 강하게 묶여 있는지, 이 API 가 필수 유스케이스를 지원하는지, 시스템이 극단적인 상황들에 잘 대처하는지 등을 확인 할 수 있다.*

<br>

자동화 테스트를 작성하면 이런 문제를 개발 주기 초반에 잡아낼 수 있고, 이 결과 모듈화가 더 잘되어 미래의 변화에 훨씬 유연한 소프트웨어를 만들어 낼 수 있다.

<br><hr><br>

## **테스트를 작성하는 이유**
*테스트는 엔지니어에게 신뢰를 줄 때만 가치가 존재한다.*

테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 우리 삶에서 중요한 제품과 서비스의 안전을 보장하는데도 점점 핵심적인 역할을 한다. 

<br>

> ### **테스트 란**
- 테스트하려는 단 하나의 행위(주로 메서드나API)
- 특정한 입력(API에 전달하려는 값)
- 관측 가능한 출력 혹은 동작
- 통제된 조건(하나의 격리된 프로세스 등

<br>

> ### **테스트스위트(test suite)**
*간단한 테스트가 수백에서 수천 개 모인 것을 말한다.*

테스트 스위트는 제품이 전체적으로 의도한 설계대로 잘 작동하는지, 혹은 언제 그렇지 못한지를 이야기 해주며, 코드베이스의 덩치에 비례하여 데스트 스위트의 크기도 커진다. 

테스트의 결과가 일관되지 못하거나 느려는 문제를 해결하지 못한다면 테스트 스위트의 존폐가 위태로워 진다. 우리는 테스트의 가치는 엔지니어에게 신뢰를 줄 떄만 존재한다는 사실을 잊어서는 안된다. 테스트가 생산성을 떨어트리고 고칠 게 계속 나오거나 결과를 믿을 수 없다면 엔지니어들은 더 이상 테스트를 신뢰하지 않고 우회방법을 찾을 것이다.

<br>

*나쁜 테스트 스위트는 테스트가 아예 없는 것만 못하다는 사실을 명심하자.*

<br><hr><br>

## **테스트를 작성하는 법**
*작성하고, 수행하고, 조치하라*

가장 순수한 형태의 자동 테스트는 "테스트 작성", "테스트 수행", "실패한 테스트에 대한 조치" 이렇게 세 가지 활동으로 이루어 진다.

자동화 테스트는 적은 양의 코드로 구성되며, 보통 테스트 대상 시스템의 일부를 호출하는 함수나 메서드 하나로 만들어진다. 

테스트 코드는 환경을 원하는 모습으로 설정하고,( 보통은 이미 알고 있는 데이터를 입력한다.) 시스템을 호출하고, 결과를 검증한다. 

<br>

```java
// 자동화 테스트의 핵심은 아주 단순한 이 예시와 매우 비슷하다.

public void main(String[] args) {
    Calculator calculator = New Calculator();
    int expectedResult = -3;
    int actualResult = calculator.subtract(2,5); // 2에서 5를 뺀다.
    assert(expectedResult == actualResult)
}
```

<br>

테스트 작성은 테스트 자동화 프로세스의 첫 번째 단계일 뿐이다. 테스트를 작성한 후에는 작성한 테스트를 수시로 실행해야 한다.

<br>

*자동화 테스트의 핵심은 같은 동작을 끊임없이 반복하는데 있다.*

<br>

테스트 프로세스의 효율성은 테스트 실패를 어떻게 처리하느냐에 달려있다. 실패하는 테스트가 해결되지 못하고 빠르게 쌓여간다면 테스트에 투자한 노력은 허사되니 이렇게 되지 않는 것이 중요하다.(테스트를 수 분내로 해결하도록 하는 팀이라면 제품과 테스트를 더 신뢰하며 오류를 빠르게 퇴치할 수 있다.(테스트로부터 얻는것이 더 많아진다.))

<br>

*건실한 자동 테스트 문화에서는 모두가 테스트를 작성하고 공유하도록 한다. 작성된 테스트들은 정기적으로 실행하며, 테스트가 실패하면 바로 조치하도록 한다.*

<br><hr><br>

## **테스트 코드가 주는 혜택**
*테스트를 작성하면 생산성과 속도가 높아진다.*

<br>

### **1. 디버깅 감소**
*테스트를 한번 작서해 두면 프로젝트가 살아 있는 내내 값비싼 결함을 예방해주고 디버깅에서 해방시켜준다.*

테스트를 거친 후 submit 되는 코드는 통상적으로 결함이 적다. 결함 대부분이 submit 되기 전에 고쳐지기 때문에 그 코드의 존속 기간전체로 봤을 때 결함이 줄어든고 말할 수 있다.

 프로젝트 자체 혹은 프로젝트가 의존하는 다른 코드가 변경되어 테스트가 실패한다면 테스트 인프라가 곧바로 인지해내어, 프로덕션 환경으로 릴리스되기 전에 정상 상태로 되돌릴 수 있다.

<br>

### **2. 자신 있게 변경 할 수 있다.**
*모든 소프트웨어는 변경된다.*

좋은 테스트로 무장한 팀은 자신감을 가지고 변경들을 리뷰하고 수용할 수 있다. 이는 테스트들이 프로젝트의 주요 기능들을 끊임없이 검증해주기 때문이다. 이런 프로젝트에선 자연스럽게 리팩터링을 권장하며, 리팩터링 시 (이상적으로) 기존 테스트를 수정할 필요조차 없다.

<br>

### **3. 더 나은 문서 자료가 된다.**
한번에 하나의 행위만 집중해 검증하는 명확한 테스트는 마치 실행 가능한 문서와 같다. 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다. 나아가 요구사항이 변경되어 새로운 코드가 기존 테스트를 통과하지 못한다면 문서자료(테스트)가 낡았음을 인지 할 수 있다.

<br>

*테스트는 명확하고 간결해야만 문서자료로서의 역할을 훌륭하게 수행할 수 있다.*

<br>

### **4. 더 단순한 리뷰가 가능하다.**
정확성, 극단 상황, 오류 상황 등 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지를 검증하는 시간을 크게 줄여준다. 각각의 상황을 머리속에서 일일이 그려보는 대신 해당 테스트를 수행해 봄으로써 통과하는지만 보면 되기 때문이다.

<br>

### **5. 더 사려깊은 설계를 하게 된다.**
*테스트하기 어려운 코드는 너무 많은 역할을 짊어지거나 의존성을 관리하기 어렵게 짜여 잇기 때문일 가능성이 크다.*

잘 설계된 코드라면 자고로 모듈화가 잘 되어 있어야한다. 즉 다른 코드와 강하게 결합되어 있지 않고 특정 역할에 집중해야한다. 설계 문제를 조기에 바로잡는다면 훗날 수정할 때 고생을 덜할 수 있다.

<br>

### 6. 고품질의 릴리스를 빠르게 할 수 있다.
*자동화 테스트 스위트를 갖춘 팀은 새로운 버전을 릴리스하며 불안에 떨지 않는다.*

<br><hr><br>