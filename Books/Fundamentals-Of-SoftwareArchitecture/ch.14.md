# **CHAPTER 14 이벤트 기반 아키텍처 스타일**

**이벤트 기반 아키텍처(event-driven-architecture)** 는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 **비동기 분산 아키텍처 스타일**이다.

- 이벤트기반 아키텍처는 `적응성`이 매우좋아, 소규모 애플리케이션 부터 **크고 복잡한 애플리케이션 까지 두루 사용할 수 있다.**
- 이벤트를 비동기 수신/처리하는 별도의 **이벤트 처리 컴포넌트들로 구성**한다.
- **스탠드얼론 아키텍처 스타일로 사용하거나 다른 아키텍처 스타일에 내장할 수 있다.**

<br>

![modelBasedOnRequest](/img/modelBasedOnRequest.png)

대부분 **요청 기반 모델(request-based model)** 을 따른다.

- 액션을 수행하도록 시스템에 요청하면 **요청 오케스트레이터(request orchestrator)가 접수** 한다.
- **요청 오케스트레이터**는 보통 **유저 인터페이스** 이지만 **API레이어** 나 **엔터프라이즈 서비스** 로도 구현할 수 있다.

*요청 오케스트 레이터(컴포넌트)의 임무는 다양한 요청 프로세서(request processor)에 확정적으로(deterministically), 동기적으로(synchronously) 요청을 전달하는 일이다. 요청 프로세서는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행하는 식으로 요청을 처리한다.*

<br>

시스템에서 **유저가 주문이력을 요청** 할 경우 주문 이력 조회는 특정한 콘텍스트에서 시스템에 데이터를 달라고 전달된, 데이터 기반의 확정적인 요청이지, **시스템이 반응해야할 이벤트가 발생한 것은 아니다.**

<br>

이벤트 기반 모델은 **특정한 상황에 대응하여 그 이벤트에 알맞게 액션을 취한다.**

- 경매사이트에서 **입찰자가 어떤 항목에 입찰을 할 경우**, 입찰을 하는 행위는 시스템에 무엇인가 **요청을 하는 것보다는, 현재 가격이 발표된 직후에 발생하는 이벤트에 더 가깝다.**
- **시스템은 이 이벤트에 반응하여** 동시 발생한 다른 입찰가와 비교 후 현재까지 **누가 가장 높은 가격을 부른 입찰자인지 결정**할 수 있다.

<br><hr><hr>

## **토폴로지**

이벤트 기반 아키텍처의 주요 토폴로지는 다음과 같다. 두 토폴로지의 아키텍처 특성과 구현 전략은 서로 다르기 때문에 주어진 상황에 가장 알맞은 것은 선택하기위해 각각의 특징을 잘 파악하도록한다.

- **중재자 토폴로지(mediator topology)**: 이벤트 처리 **워크플로를 제어** 해야 할 경우 사용한다.
- **브로커 토폴로지(broker topology)**: **신속한 응답과 동적인 이벤트 처리 제어**가 필요할 경우 사용된다.

<br>

### **브로커 토폴로지**

![brokerTopology](/img/brokerTopology.png)

브로커 토폴로지는 **중앙에 이벤트 중재자가 없다는 점에서 중재자 토포롤지와 다르다.**

- 메시지는 **경량 메시지 브로커** 를 통해 **브로드캐스팅** 이 되어 **이벤트 프로세서 컴포넌트에 분산** 되어 들어간다.
- 비교적 이벤트 처리 흐름이 단순하고 굳이 **중앙에서 이벤트를 조정할 필요가 없다.**

<br>

브로커 토폴로지는 다음 4개의 기본 아키텍처 컴포넌트로 구성된다.

- 시작 이벤트
- 이벤트 브로커
- 이벤트 프로세서
- 처리 이벤트

<br>

> ### **시작 이벤트**

단순한 이벤트 또는 복잡한 이벤트와 같이 **전체 이벤트 흐름을 개시하는 이벤트** 를 말한다.

- 시작 이벤트는 **이벤트 이벤트 브로커의 이벤트 채널로 전송되어 처리된다.**
- 이벤트를 관리/제어하는 중재자가 브로커 토포롤지에 없어 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리작업을 마친 뒤 **처리이벤트(processing event)를 생성** 하고 **시스템의 나머지 부분에 자신이 한 일을 비동기**로 알린다.

*처리 이벤트는 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기로 전송된다.*

**다른 이벤트 프로세서**는 **처리 이벤트를 리스닝** 하고 있다가 **이벤트가 들어오면 그에 맞는 작업을 수행한 뒤 다시 새로운 처리 이벤트를 발행**함으로써 자신이 한 일을 모두에게 알린다.

**이 과정은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 떄 까지 되풀이된다.**

**이벤트 브로커 컴포넌트**는 보통 **연합체(도메인 기반으로 클러스터링 된 다수의 인스턴스)로 구성**된다.

- 연합된 **각 브로커에는 주어진 도메인의 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어있다.**
- 일반적으로 **발행-구독 메시징 모델을 사용하는 브로커 토폴로지에서는 토픽을 사용**한다.
- 다른 이벤트 프로세서의 관심 여부와는 무관하게 **각 이벤트 프로세서가 자신이 한 일을 항상 모두에게 알리는 것이 바람직하다.**(아키텍처 `확장성`을 위해 필요하다.)

*기존의 기능에 새로운 요구사항이 발생하더라도 기존의 기능 토픽 안에 해당 정보가 들어 있어, 따로 인프라를 추가하거나, 다른 이벤트 프로세서를 변경하지 않아도 최소한의 작업으로 전체 시스템에 필요한 새로운 기능 이벤트 프로세서를 추가할 수 있다.*

<br>

브로커 토폴로지는 릴레이 경주 같다고 생각하면 이해하기 쉽다.

- **이벤트 프로세서는 이벤트 전달 후** 더 이상 그 이벤트 처리에 관여하지 않고 **다른 시작 이벤트 또는 처리 이벤트에 반응할 준비** 를 한다.
- **각 이벤트 프로세서**는 이벤트 처리 도중 **가변적인 부하**나 **백업 조건**을 처리하기 위해 **서로 독립적으로 확장할 수 있다.**
- 어떤 환경 문제로 인해 **이벤트 프로세서가 느려지거나 실패하면 그 프로세서가 구독하는 토픽이 배압(back pressure)지점이 된다.**

<br>

> ### **브로커 토폴로지의 장단점**

| 장점 | 단점 |
|---|---|
| `확장성`이 높다. | `에러처리`가 힘들다.|
|이벤트 프로세서가 `디커플링`된다.| `워크플로제어`가 어렵다.|
| `응답성`이 우수하다. | `복구성`이 떨어진다.|
| `성능`이 우수하다. | `재시작` 능력이 떨어진다. |
| `내고장성`이 뛰어나다. | 데이터의 `일관성`이 떨어진다.(비일관성)|

브로커 토폴로지는 `성능`, `응답성`, `확장성` 측면에서 장점이 많다. 하지만, 무엇보다 **시작이벤트와 연관된 전체 워크플로를 제어할 수 없다는 큰 단점**을 갖고 있다.

- 다양한 조건에 따라 상황이 매우 유동적이고 **트랜잭션이 언제 끝났는지 알 수 없다.**
- **비즈니스 트랜잭션을 관찰/통제하는 중재자가 없으므로, 처리가 실패해도 다른 파트는 실패 사실을 모른다.(에러처리가 어렵다.)**
- **비즈니스 트랜잭션을 재시작하는 기능(복구성)이 지원되지 않는다.**(시작 이벤트를 처리할 때부터 이미 다른 작업이 비동기로 수행되었기 때문이다.)

<br><hr>

## **중재자 토폴리지**

![mediatorTopology](/img/mediatorTopology.png)

**중재자 토폴리지(mediator topology)** 는 여러 이벤트 프로세서 간의 조정이 필요한 **시작 이벤트에 대하여 워크플로를 관리/제어하는 이벤트 중재자(event mediator)** 가 핵심이다.

- 총 5개(**시작 이벤트**, **이벤트 큐**, **이벤트 중재자**, **이벤트 채널**, **이벤트 프로세서**)의 아키텍처 컴포넌트로 구성된다.

<br>

시작 이벤트가 전체 이벤트 프로세스를 개시하는 이벤트인 점은 브로커 토폴리지와 동일하나, 중재자 토폴로지에서는 **시작 이벤트 큐를 거쳐 이벤트 중재자로 전달되는 (차이점1)** 과 **이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않는다(차이점2)** 는 점을 이야기 할 수 있다.

- **이벤트 중재자**는 **이벤트 처리에 대한 정보만** 갖고 있으므로 **점대점 메시징으로 각각의 이벤트 채널(대부분 큐)로 전달되는 처리 이벤트를 발행**한다.
- **이벤트 프로세서** 는 자신의 **이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답**한다.

<br>

중재자 토폴로지 구현체에는 대부분 **특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재**하므로, **토폴로지의 단일 장애점(Single Point of Failure;SPF)을 줄이고 전체 처리량 및 성능을 높일 수 있다.**

- 전체 **고객에 관한 이벤트** 는 **고객 중재자** 가 처리하며, **주문 관련된 이벤트**는 **주문 중재자** 가 처리한다.

<br>

이벤트 중재자는 처리하는 **이벤트의 특성과 복잡도에 따라서 다양한 방법으로 구현할 수 있다.** 알맞은 이벤트 중재자 구현체를 선택하도록 하자.

- 중재자를 통해 **어떤 종류의 이벤트를 처리할 것** 인가 고려한다.
- **간단한 에러처리와 오케스트레이션이 필요한 이벤트** 는 **아파치 카멜(Apache Camel)**, **뮬(Mule)**, **ESB**, **스프링 인티그레이션(Spring Integration)** 등의 중재자를 사용한다.
- **조건부 처리가 많고 동적 경로가 많아 에러처리가 복잡** 하다면, **아파치ODE** 나 **오라클 BPEL 프로레스관리자(Oracle BPEL Process Manager)** 을 사용한다.

*BPEL(Business Process Execution Language)는 에러 처리, 리다이렉션, 멀티 캐스팅 기능을 하는 요소들이 체계적으로 구현되어 있다. BPEL은 복잡하고 동적인 워크플로에는 적합하지만, 이벤트 처리 중 사람이 개입하는, 실행 시간이 긴 트랜잭션이 필요한 워크플로에는 적합하지 않다.*

<br><br>

![mediatorTopologyPattern](/img/mediatorTopologyPattern.png)

이벤트 복잡도를 한 가지 기준으로 평가하는 경우는 거의 없으므로, `단순함`, `어려움`, `복잡함` 정도로 **분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하자.**

- 중재자는 **이벤트 등급에 따라 이벤트를 직접 처리하거나 더 복합한 이벤트 중재자에게 위임**하여 모든 종류의 이벤트를 그에 **알맞은 중재자가 효과적으로 처리** 할 수 있도록 할 수 있다.
- 이벤트 워크플로가 **단순 중재자로 처리할 수 있는 경우** 에는 **Simple Evnet Mediator** 가 이벤트를 생성하여 전달하고, 시작이벤트가 **어려움 또는 복잡함 등급** 으로 분류될 경우에는 원시작 이벤트를 **BPEL** 또는 **BMP** 같은 중재자로 바로 넘긴다.
- **Simple Evenet Mediator** 는 **원 이벤트를 가로채 해당 이벤트의 완료 시점을 알아내거나**, **전체 워크플로를(클라이언트 알림까지 포함하여) 다른 중재자에게 위임**하는 등의 일을 한다.
- 중재자 컴포넌트는 **이벤트 상태를 유지하면서 필요시 에러 처리, 복구, 재시작**을 할 수 있다.

<br>

> ### **중재자 토폴로지의 장단점**

| 장점 | 단점 |
|---|---|
| 워크플로제어가 가능하다. | 이벤트 프로세서가 커플링된다.|
|에러처리가 가능하다.| `확장성`이 낮다.|
| `복구성`이 뛰어나다.| `성능`이 낮다.|
| 필요시 재시작 할 수 있다.| `내고장성`이 좋지 않다.|
| 데이터의 `일관성`을 유지할 수 있다. |워크플로 모델링이 복잡하다.|

중재자 토폴로지에서 **이벤트는 사건(incident, 이미 일어난일)이 아니라 커맨드(command, 일어나야 할 일)이다.**

- **중재자 토폴로지**에서 **처리 이벤트**가 **반드시 처리 되어야할 이벤트(커멘드)** 인 반면, **브로커 토폴로지** 에서는 **무시해도 무방하다.(반응)**
- **복잡한 이벤트 흐름 내**에서 발생하는 **동적인 처리를 선언적으로 모델링 하기가 어렵다.**
- 이벤트 프로세서는 브로커 토폴로지와 동일한 방식으로 **쉽게 확장할 수 있지만**, **중재자도 함께 확장** 해야하므로, 전체 이벤트 처리 흐름에 **병목 지점이 생기기 쉽다.**
- 중재자가 제어함으로써 **이벤트 프로세서가 상대적으로 더 많이 커플링** 되어 성능은 브로커 토폴로지보다 좋지 않다.

<br>

*브로커 토폴로지와 중재자 토폴로지를 고민한다면, **워크플로 제어와 에러처리 기능이 우선인가?(중재자) 고성능과 확장성이 우선인가?(브로커)** 에 대한 트레이드오프를 잘 따져 선택한다.*

<br><hr><hr>

## **비동기 통신**

이벤트 기반 아키텍처 스타일은 (이벤트 컨슈머의 응답을 받아야하는) **요청/응답 처리** 뿐만아니라 (응답이 필요없는)파이어 엔드포켓(Fire-and-forget) 처리 **모두 비동기로 통신한다** 는 점에서 다른 아키텍처 스타일과 차별화 된다.

- 시스템 `응답성`을 전반적으로 높이는 기법으로 사용할 수 있다.
- `응답성`은 어떤 **액션이 접수되어 곧 처리될 것이라는 사실을 유저에게 알리는 것** 을 말하며, `성능`은 **종단간 프로세스가 더 빨리 수행되게끔 만드는 것** 을 말한다.
- 비동기통신에서는 **에러 처리가 가장 큰 문제이다.** 에러를 제대로 처리하기 쉽지 않기 때문에 **이벤트 기반 시스템의 복잡도가 가증된다.**

<br>

> ### **댓글 게시 웹사이트**

![synchronousAndAsynchronous](/img/synchronousAndAsynchronous.png)

- 댓글 하나를 게시하는데 **3,000ms**가 걸린다.
- **REST 동기 호출 시**, 서비스가 댓글을 수신하는데 50ms, 댓글게시 3000ms, 유저에게 응답하는데 50ms **총 3100ms 가 소요된다.**
- **비동기 호출 시**, 최종 유저 입자에서  웹사이트에 댓글을 게시하는 **25ms밖에 걸리지 않는다.**(실제 = 메시지 수신 25ms + 댓글게시 3000ms이지만 최종 유저 관점에서는 이미 댓글의 처리는 완료된 샘이다.)
- 비동기 호출은 **언젠가 댓글이 게시될 예정이라는 미래의 약속과 함께 확인 응답을 받은 것** 뿐이다.
- 최종 유저 눈에는 댓글은 이미 게시가 끝난 것 처럼 보이지만, 댓글에 문제(비속어 등) 댓글 게시는 거부되지만, 이는 최종 유저에게 돌아갈 방법이 없다.

<br><br>

>### **워크플로 이벤트 패턴**

![workflowEvnetPattern](/img/workflowEvnetPattern.png)

**워크플로 이벤트 패턴(리액티브 아키텍처의 일종**)은 비동기 워크플로에서 에러 처리 문제를 해결하는 한 문제를 해결할 수 있다.

- 워크플로 이벤트 패턴은 시스템을 `응답성`에 영향을 미치지 않고 **탄력적으로 에러를 처리할 수 있게 만드는 패턴** 을 말한다.
- **워크플로 대리자(workflow delegate)**을 통해 **위임(delgation)**, **봉쇄(containment)**, **수리(repair)** 작업을 한다.
- 아밴트 프로듀서는 **메시지 채널을 통해 데이터를 이벤트 컨슈머에게 비동기 전송** 하고, 이벤트 컨슈머가 **데이터를 처리하는 도중 에러가 발생하면 즉시 해당 에러를 워크플로 프로세서에게 위임** 한 뒤 **이벤트 큐에 있는 다음메시지로 넘어간다.**(전체 `응답성`은 영향을 받지 않는다.)
- 워크플로 프로세서는 (사람의 개입없이) 프로그래밍 방식으로 원데이터를 변경해서 조치 한뒤 원래 큐로 돌려보낸다. 이벤트 컨슈머는 이 **메시지를 새로운 메시지로 간주하여 재처리를 시도한다.**
- 워크플로 프로세스가 **메시지의 문제점을 파악할 수 없는 경우** 에는 메시지를 다른 큐로 보내 대시보드(dashboard)애플리케이션이 받는다. **대시보드를 통해 담당자가 직접 메시지를 확인하여 조치하고 원래 큐로 다시 전송한다.**

<br><hr><hr>

## **데이터 소실 방지**

비동기 통신 시에는 **데이터 소실(data loss)** 을 항상 염두해두어야한다.

- 데이터 소실은 **메시지가 도중에 삭제되거나 최종 목적지에 도달하지 못한 상태**를 말한다.
- 이벤트 기반 아키텍처에서는 **데이터가 소실될만한 곳이 많다.**

<br>

![WhereDataLoss CanOccur](/img/WhereDataLossCanOccur.png)

다음과 같은 상황에서 데이터 소실이 일어날 수 있다.

- 이벤트 프로세서 A에서 메시지가 큐로 전달되지 않는다. 아니면 전달되어도 다음 이벤트 프로세서가 메시지를 가져오기 전에 브로커가 다운된다.
- 이벤트 프로세서 B가 큐에서 다음 메시지를 꺼내 이벤트를 처리하기 전에 장애가 발생한다.
- 데이터 에러로 인해 이벤ㅌ 프로세서 B가 데이터베이스에 메시지를 저장할 수 없다.

<br>

> **데이터 소실문제 해결 방법**

![preventDataLossInEventBasedArchitecture](/img/preventDataLossInEventBasedArchitecture.png)

기본적인 메시징을 통해 어느정도 해결이 가능하다.

- **메시지가 큐에 전달되지 않는 경우**

    **동기 전송(synchronous send)**와 **퍼시스턴스 메시지 큐**를 통해 쉽게 해결할 수 있다.

    동기전송은 브로커가 메시지를 저장했다는 확인응답을 줄 때까지 메시지 프로듀서를 차단하여 기다리게한다.

    **퍼시스턴스 메시지 큐**는 **전달보장(guarnteed delivery)** 를 지원하여, 메시지브로커가 메시지를 수신하면 신속한조회를 위해 메모리에 저장하는 동시에 물리적인 **데이터 저장소에도 메시지를 저장한다.**

    이를 통해 메시지 브로커가 다운되어도 메시지가 디스크에 물리적으로 저장되어 브로커가 다시 살아날 때까지 메시지를 계속 처리할 수 있다.

    **동기 전송**과 **퍼시스턴스 메시지 큐**를 이용하면, **메시지는 프로듀서 또는 퍼시스턴스 메시지 큐에 있기 때문에 이 둘 사이에 메시지가 소실될 일은 없다.**

    <br>

- **이벤트 프로세서 B가 큐에서 다음 메시지를 꺼내 이벤트를 처리하기 전에 고장 나는 경우**

    **클라이언트 확인응답 모드(client acknowledge mode)**인 기본적인 메시징 기술을 이용하면 해결 가능하다.

    메시지는 큐에서 빠져나가는 즉시 삭제되는데(자동 확인응답 모드,auto acknowledge mode), **클라이언트 확인응답 모드는 메시지를 큐에 보관한 채 다른 컨슈머가 메시지를 읽을 수 없게 클라이언트 ID를 메시지에 부착한다.** 따라서 **이벤트 프로세서 B가 잘못돼도 메시지는 큐에 계속 남아있어 데이터 소실을 방지**할 수 있다.

    <br>

- **데이터 에러 때문에 이벤트 프로세서 B가 메시지를 데이터베이스에 저장할 수 없는 경우**

    **데이터베이스 본연의 ACID(원자성, 일관성, 격리성, 내구성)트랜잭션의 커밋으로 해결** 가능하다.

    데이터베이스에 커밋이 일어나면 데이터가 확실하게 저장된다. **최종 참여자 지원(last participant support;LPS)**를 활용하면 **메시지 처리가 끝나 데이터베이스에 저장됬음을 확인한 이후에 큐에서 메시지가 삭제** 된다.

    따라서 이벤트 프로세서 A에서 데이터베이스로 가는 도중에 메시지가 소실될 일은 없다.

<br><hr><hr>

## **브로드캐스팅**

![broadCasting](/img/broadCasting.png)

이벤트 기반 아키텍처는 **메시지를 누가 받든 (컨슈머가 있다면)**, 그 메시지로 무슨일을 하든 상관없이 **이벤트를 브로드캐스트(broadcast, 전파) 할 수 있다.**

- 브로드캐스팅은 여러 이벤트 프로세서를 가장 높은 수준으로 **디커플링 하는 수단**이며, 최종 일관성, **복잡한 이벤트 처리(complex event processing;CEP)등 다양한 쓰임새를 지닌 필수 기능** 이다.
- 메시지 프로듀서는 **자신이 보낸 메시지를 어느 이벤트 프로세서가 수신할지, 또 메시지를 받아 무슨일을 할지 모른다.**

<br><hr><hr>

## **요청-응답**

이벤트 프로세서 간 통신 중 확인 번호가 필요한 것과 같은 **동기 통신이 필요한 경우가 존재**한다.

- 이벤트 기반 아키텍처는 **동기 통신**을 **요청-응답 메시징(request-response messaging, 의사 동기 통신;pseudosynchronous communication 이라고도함)으로 수행한다.**

<br>

![request-responseMessagingProcess](/img/request-responseMessagingProcess.png)

요청-응답 메시징 내부의 각 **이벤트 채널** 은 **요청 큐**, **응답 큐**로 구성된다.

- 처음 정보를 요청하면 **요청 큐에 비동기 전송** 된 후 **메시지 프로듀서에게 제어권을 반환** 되며, **메시지 프로듀서는 응답 큐에 응답이 도착하길 기다리며 차단 대기(blocking wait)상태** 가 된다.
- **메시지 컨슈머가 메시지를 받아 처리한 후 응답 큐에 응답**을 보내면 **이벤트 프로듀서는 응답 데이터가 포함된 메시지를 수신**한다.

<br>

> ### **요청-응답 메시징을 구현하는 주요한 기술**

요청-응답 메시징을 구현하는 주요한 기술은 **상관(correlation)ID** 를 사용하는 방법과 **임시 응답 큐(temporary response queue)** 를 사용하는 방법을 이야기 할 수 있다.

기술적으로는 **임시 큐**가 훨씬 간단하지만 메시지 브로커는 **매번 요청을 할 때마다 임시 큐를 생성/폐기하는 일을 반복** 해야하기 때문에 **대용량 메시지 처리** 시 메시지 브로커의 속도가 크게 떨어지고 전체 `성능`과 `응답성` 역시 영향을 받을 수 있다.

- **메시지 헤더에 상관(correlation) ID를 사용한다.**

    ![request-responseWithcorrelation](/img/request-responseWithcorrelation.png)

    *메시지 ID는 ID, 상관 ID는 CID를 의미한다.*

    상관ID는 응답 메시지의 필드로, 대부분 원요청 메시지 ID로 세팅된다.

    1. 이벤트 프로듀서는 요청 큐에 메시지를 보내고 고유한 메시지ID(124)를 기록한다. 아직 상관ID(CID)는 null이다.
    2. 이벤트 프로듀서는 메시지 필터(message filter(메시지 셀렉터로 불리기도한다.)로 응답 큐를 차단 대기한다. 이때 메시지 헤더에는 원 메시지ID(124)와 동일한 상관ID가 존재한다. 현재 응답큐에는 이벤트 컨슈머가 찾고 있는 상관ID(124)와 일치하지 않는 메시지들도 존재한다.(ID:855|CID:120, ID:856|CID:122)
    3. 이벤트 컨슈머는 메시지(ID:124)을 받아 요청을 처리한다.
    4. 이벤트 컨슈머는 응답 메시지를 생성하고 메시지 헤더의 상관ID(CID)를 원 메시지ID(124)로 세팅한다.
    5. 이벤트 컨슈머는 새 메시지(ID:857)을 응답 큐로 보낸다.
    6. 2단계의 메시지 셀렉터와 상관ID(124)가 일치하여 이벤트프로듀서는 메시지를 수신한다.

<br>

- **응답 큐에 임시 큐(temporary queue)를 사용한다.**

    ![request-responseWithTemporayResposeQueue](/img/request-responseWithTemporayResposeQueue.png)

    임시큐는 지정된 요청에만 사용되는데, 요청이 들어오면 생성되고 요청이 종료되면 삭제된다.

    임시 큐는 각 요청별로 이벤트 프로듀서만 알고 있는 전용 큐이므로 상관ID는 필요하지 않다.

    1. 이벤트 프로듀서는 임시 큐를 생성하고(또는 메시지 브로커에 따라 자동 생성됨) reply-to 헤더(또는 사전 정의된 다른 커스텀 헤더)에 임시 큐 이름을 세팅하여 요청 큐에 메시지를 보낸다.
    2. 이벤트 프로듀서는 임시 응답 큐를 차단 대기하면서 응답이 도착하길 기다린다. 이 큐에 전달된 메시지는 원메시지를 보낸 이벤트 프로듀서에게만 속하므로 따로 메시지 셀렉터는 필요없다.(상관ID가 필요없다.)
    3. 이벤트 컨슈머는 메시지를 받아 요청을 처리한 후 reply-to 헤더에 세팅된 이름을 가진 응답 큐로 응답 메시지를 보낸다.
    4. 이벤트 프로세서는 메시지를 수신한 다음 임시 큐를 삭제한다.

<br><hr><hr>

## **요청기반 VS 이벤트 기반**

요청 기반 모델과 이벤트 기반 모델 모두 소프트웨어 시스템을 설계하는 유효한 접근 방식이다. 그러나 시스템이 전체적으로 성공하려면 당연하게도 가장 알맞은 모델을 선택해야 한다.

- 워크플로의 `확장성`과 `제어`가 중요하면 체계적인 데이터 기반의 요청에 특화된 **요청 기반 모델** 을 사용한다.
- **복잡하고 동적인 유저 처리** 등 주로 고도의 `응답성`과 `확장성`을 요하는, 유연한 액션 단위의 이벤트를 처리한다면 **이벤트 기반 모델** 을 선택한다.

<br>

> ### **이벤트기반 모델의 장단점**

| 장점 | 단점 |
|---|---|
| 동적인 유저 컨텐츠의 응답성이 좋다 | 최종 일관성만 지원된다.|
|확장성, 탄력성이 우수하다. | 처리 흐름을 제어하기 곤란하다.|
| 민첩성과 변화 관리가 우수하다. | 이벤트 흐름의 결과를 예측하기 어렵다.|
| 적응성과 확장성이 뛰어나다. | 테스팅, 디버깅이 어렵다. |
| 응답성과 성능이 좋다. | |
| 실시간 의사결정이 가능하다. | |
| 솽황 인지에 따른 반응성이 좋다.  | |

<br><hr><hr>

## **하이브리드 이벤트 기반 아키텍처**

하이드리드 아키텍처는 **아키텍처 스타일을 혼합한 아키텍처**를 말한다.

- 이벤트 기반 아키텍처를 다른 아키텍처 스타일의 일부로 활용하는 아키텍처 스타일로는 **마이크로서비스 아키텍처**, **공간 기반 아키텍처**가 대표적으로 이야기할 수 있으며, **이벤트 기반 마이크로커널 아키텍처**, **이벤트 기반 파이프라인 아키텍처** 를 이야기 할 수 있다.

*마이크로서비스 아키텍처, 공간 기반 아케텍처는 데이터 펌프에 메시징을 활용하며, 다른 프로세서에 데이터를 비동기 전송하여 데이터베이스 데이터를 업데이트 한다. 또한 서비스 간에 메시지를 주고받으며 통신할 때 마이크로 서비스 아키텍처의 서비스와 공간 기반 아키텍처의 처리 장치 모두 이벤트 기반 아키텍처를 활용함으로써 프로그래밍 방식의 확장성을 달성할 수 있다.*

<br>

어떤 아키텍처든, 이벤트 기반 아키텍처를 추가하면 다음과 같은 장점들이 존재한다.

- **병목 지점을 제거** 하고 이벤트 요청을 백업하는 **배압 지점(back pressure point)을 확보** 하는데 유용하다.
- 다른 아키텍처스타일 에서는 찾아볼 수 없음 높은 유저 `응답성`이 보장된다.

<br><hr><hr>

## **정리**

*별의 갯수가 적을수록 해당 특성이 별로 좋지 않음을 의미하며, 별의 갯수가 많을수록 이 아키텍처의 강점임을 의미한다.*

|아키텍처 특성|별점|
|---|---|
|**분할 유형**| 기술|
|**퀀텀 수**|하나 또는 여러 개|
|**배포성**|⭐⭐⭐|
|**탄력성**|⭐⭐⭐|
|**진화성**|⭐⭐⭐⭐⭐|
|**내고장성**|⭐⭐⭐⭐⭐|
|**모듈성**|⭐⭐⭐⭐|
|**전체비용**|⭐⭐⭐|
|**성능**|⭐⭐⭐⭐⭐|
|**신뢰성**|⭐⭐⭐|
|**확장성**|⭐⭐⭐⭐⭐|
|**단순성**|⭐|
|**시험성**|⭐⭐|

이벤트 기반 아키텍처는 **특정 도매인**이 여러 **이벤트 프로세서에 분산**되어 있고, **중재자**, **큐**, **토픽** 을 통해 **서로 묶여 있는, 기술 분할된 아키텍처** 이다.

- 한 도메인에 변경이 발생하면 많은 이벤트 프로세서, 중재자, 다른 메시징 아티팩트에도 영향을 미치므로 이벤트 기반 아키텍처는 **도메인 분할 아키텍처라고 말할 수 없다.**

<br>

각 이벤트 프로세서의 **데이터베이스 상호작용** 및 **요청-응답** 처리를 기반으로 하므로 **퀀텀 수는 1개 이상 가능**하다.

- 모든 통신은 **비동기** 로 이루어지지만 여러 이벤트 프로세서가 단일 데이터베이스 인스턴스를 공유하는 경우 전부 동일한 아키텍터 퀀텀 내에 포함된다.
- **요청-응답 처리** 도 마찬가지라서 이벤트프로세서 끼리는 여전히 **비동기** 통신을 주고받지만 이벤트 컨슈머에게 직접 요청을 받아야 하는 구조라면 결국 해당 이벤트 프로세서는 동기적으로 함꼐 묶여 동일한 퀀텀에 소속된다.

<br>

`성능`, `확장성`, `내고장성`은 이벤트 기반 아키텍처의 주요 강점이다.

- **이벤트 프로세서(경쟁 컨슈머 competing consumer 라고도 말함)** 은 프로그래밍 방식의 **로드밸런싱이 가능**하며, `확장성`이 매우 뛰어나다.
- **요청부하가 증가** 하면 프로그래밍 방식으로 **이벤트프로세서를 추가하여 증가된 요청을 처리** 할 수 있다.
- 이벤트 워크플로의 최종 `일관성` 및 최종 처리를 제공하는 고도로 **분리된 비동기 이벤트프로세서** 를 통해 `내고장성`을 실현할 수 있다.
- 유저 인터페이스나 이벤트 프로세서를 제공하는 행위는 **즉시 응답을 필요로 하지 않으며**, 다른 다운스트림 프로세서를 사용할 수 없을 경우 **나중에 이벤트를 처리할 목적** 으로 **프로미스(Promise)**와 **퓨처(Future)** 를 이용한다.

<br>

이벤트 기반 아키텍처는특유의 `비결정적`, `동적인` 이벤트 흐름 때문에 `단순성`과 `시험성`은 상대적으로 낮은 편이다.

- **요청 기반 모델의 확정적인 흐름**은 경로와 결과가 잘 알려져 있으므로 **비교적 테스트 하기 쉽지만**, **이벤트 기반 모델**은 이벤트 프로세서가 **동적 이벤트에 어떻게 반응할지, 어떤 메시지를 생성할지 알 수 없는 때**가 많아 **테스트하기 어렵다.**

<br>

신규 이벤트 프로세서를 통해 **새로운 기능을 추가하는 것**은 특히 브로커 토폴로지에서 **비교적 간단한 일** 이다.

- **발행된 메시지** 를 통해 **훅(hook)** 을 제공하면 데이터를 바로 사용할 수 있으니 **신기능을 추가하려고 인프라 또는 기존 이벤트 프로세서를 변경할 필요가 전혀 없다.**
