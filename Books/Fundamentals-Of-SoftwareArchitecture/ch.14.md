# **CHAPTER 14 이벤트 기반 아키텍처 스타일**

이벤트 기반 아키텍처(event-driven-architecture) 는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍처 스타일이다.

- 이벤트기반 아키텍처는 적응성이 매우좋아, 소규모 애플리케이션 부터 크고 복잡한 애플리케이션 까지 두루 사용할 수 있다.
- 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성한다.
- 스탠드얼론 아키텍처 스타일로 사용하거나 다른 아키텍처 스타일에 내장할 수 있다.

<br>


![modelBasedOnRequest](/img/modelBasedOnRequest.png)

대부분 요청 기반 모델(request-based model)을 따른다.

- 액션을 수행하도록 시스템에 요청하면 요청 오케스트레이터(request orchestrator)가 접수한다.
- 요청 오케스트레이터는 보통 유저 인터페이스 이지만 API레이어나 엔터프라이즈 서비스로도 구현할 수 있다.

*요청 오케스트 레이터(컴포넌트)의 임무는 다양한 요청 프로세서(request processor)에 확정적으로(deterministically), 동기적으로(synchronously) 요청을 전달하는 일이다. 요청 프로세서는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행하는 식으로 요청을 처리한다.*

<br>

시스템에서 유저가 주문이력을 요청할 경우 주문 이력 조회는 특정한 콘텍스트에서 시스템에 데이터를 달라고 전달된, 데이터 기반의 확정적인 요청이지, 시스템이 반응해야할 이벤트가 발생한 것은 아니다.

<br>

이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞게 액션을 취한다.

- 경매사이트에서 입찰자가 어떤 항목에 입찰을 할 경우, 입찰을 하는 행위는 시스템에 무엇인가 요청을 하는 것보다는, 현재 가격이 발표된 직후에 발생하는 이벤트에 더 가깝다.
- 시스템은 이 이벤트에 반응하여 동시 발생한 달느 입찰가와 비교 후 현재까지 누가 가장 높은 가격을 부른 입찰자인지 결정할 수 있다.


<br><hr><hr>

## **토폴로지**

이벤트 기반 아키텍처의 주요 토폴로지는 다음과 같다. 두 토폴로지의 아키텍처 특성과 구현 전략은 서로 다르기 때문에 주어진 상황에 가장 알맞은 것은 선택하기위해 각각의 특징을 잘 파악하도록한다.

- 중재자 토폴로지(mediator topology): 이벤트 처리 워크플로를 제어해야 할 경우 사용한다.
- 브로커 토폴로지(broker topology): 신속한 응답과 동적인 이벤트 처리 제어가 필요할 경우 사용된다.

<br>

### **브로커 토폴로지**

![brokerTopology](/img/brokerTopology.png)

브로커 토폴로지는 중앙에 이벤트 중재자가 없다는 점에서 중재자 토포롤지와 다르다.

- 메시지는 경량 메시지 브로커를 통해 브로드캐스팅이되어 이벤트 프로세서 컴포넌트에 분산되어 들어간다.
- 비교적 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없다.

<br>

브로커 토폴로지는 다음 4개의 기본 아키텍처 컴포넌트로 구성된다.

- 시작 이벤트 
- 이벤트 브로커 
- 이벤트 프로세서
- 처리 이벤트


<br>

> ### 시작 이벤트

단순한 이벤트 또는 복잡한 이벤트와 같이 전체 이벤트 흐름을 개시하는 이벤트를 말한다.
시작 이벤트는 이벤트 이벤트 브로커의 이벤트 채널로 전송되어 처리된다. 이벤트를 관리/제어하는 중재자가 브로커 토포롤지에 없어 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리작업을 마친 뒤 처리이벤트(processing event)를 생성하고 시스템의 나머지 부분에 자신이 한 일을 비동기로 알린다.

이 처리 이벤트는 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기로 전송된다.

다른 이벤트 프로세서는 처리 이벤트를 리스닝 하고 있다가 이벤트가 들어오면 그에 맞느 작업으 수행한 뒤 다시 새로운 처리 이벤트를 발행함으로써 자신이 한 일을 모두에게 알린다.

이 과정은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 떄 까지 되풀이된다.

이벤트 브로커 컴포넌트는 보통 연합체(도메인 기반으로 클러스터링 된 다수의 인스턴스)로 구성된다.

- 연합된 각 브로커에는 주어진 도메인의 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어있다.
- 일반적으로 발행-구독 메시징 모델을 사용하는 브로커 토폴로지에서는 토픽을 사용한다.
- 다른 이벤트 프로세서의 관심 여부와는 무관하게 각 이벤트 프로세서가 자신이 한 일을 항상 모두에게 알리는 것이 바람직하다.(아키텍처 확장성을 위해 필요하다.)

*기존의 기능에 새로운 요구사항이 발생하더라도 기존의 기능 토픽 안에 해당 정보가 들어 있어, 따로 인프라를 추가하거나, 다른 이벤트 프로세서를 변경하지 않아도 최소한의 작업으로 전체 시스템에 필요한 새로운 기능 이벤트 프로세서를 추가할 수 있다.*

<br>


브로커 토폴로지는 릴레이 경주 같다고 생각하면 이해하기 쉽다.

- 이벤트 프로세서는 이벤트 전달 후 더 이상 그 이벤트 처리에 관려하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 준비를 한다.
- 각 이벤트 프로세서는 이벤트 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있다.
- 어떤 환경 문제로 인해 이벤트 프로세서가 느려지거나 실패하면 그 프로세서가 구독하는 토픽이 배압(back pressure)지점이 된다.

<br>

> ### **브로커 토폴로지의 장단점**

| 장점 | 단점 |
|---|---|
| 확장성이 높다. | 에러처리가 힘들다.|
|이벤트 프로세서가 디커플링된다.| 워크플로제어가 어렵다.|
| 확장성이 높다. | 에러처리가 힘들다.|
| 응답성이 우수하다. | 복구성이 떨어진다.|
| 성능이 우수하다. | 재시작 능력이 떨어진다. |
| 내고장성이 뛰어나다. | 데이터의 일관성이 떨어진다.(비일관성)|


브로커 토폴로지는 성능, 응답성, 확장성 측면에서 장점이 많다. 하지만, 무엇보다 시작이벤트와 연관된 전체 워크플로를 제어할 수 없다는 큰 단점을 갖고 있다. 

- 다양한 조건에 따라 상황이 매우 유동적이고 트랜잭션이 언제 끝났는지 알 수 없다.
- 비즈니스 트랜잭션을 관찰/통제하는 중재자가 없으므로, 처리가 실패해도 다른 파트는 실패 사실을 모른다.(에러처리가 어렵다.)
- 비즈니스 트랜잭션을 재시작하는 기능(복구성)이 지원되지 않는다.(시작 이벤트를 처리할 때부터 이미 다른 작업이 비동기로 수행되었기 때문이다.) 

<br><hr>

## **중재자 토폴리지**

![mediatorTopology](/img/mediatorTopology.png)

중재자 토폴리지(mediator topology)는 여러 이벤트 프로세서 간의 조정이 필요한 시작 이벤트에 대하여 워크플로를 관리/제어하는 이벤트 중재자(event mediator)가 핵심이다. 

- 총 5개(시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서)의 아키텍처 컴포넌트로 구성된다.

<br>

시작 이벤트가 전체 이벤트 프로세스를 개시하는 이벤트인 점은 브로커 토폴리지와 동일하나, 중재자 토폴로지에서는 시작 이벤트 큐를 거쳐  이벤트 중재자로 전달되는 차이점1과 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않는다는 차이점2도 이야기 할 수 있다.

- 이벤트 중재자는 이벤트 처리에 대한 정보만 갖고 있으므로 점대점 메시징으로 각각의 이벤트 채널(대부분 큐)로 전달되는 처리 이벤트를 발행한다.
- 이벤트 프로세서는 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답한다.

<br>

중재자 토폴로지 구현체에는 대부분 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재하므로, 토폴로지의 단일 장애점(Single Point of Failure;SPF)을 줄이고 전체 처리량 및 성능을 높일 수 있다.

- 전체 고객에 관한 이벤트는 고객 중재자가 처리하며, 주문 관련된 이벤트는 주문 중재자가 처리한다.

<br>

이벤트 중재자는 처리하는 이벤트의 특성과 복잡도에 따라서 다양한 방법으로 구현할 수 있다. 알맞은 이벤트 중재자 구현체를 선택하도록 하자.

- 중재자를 통해 어떤 종류의 이벤트를 처리할 것인가 고려한다.
- 간단한 에러처리와 오케스트레이션이 필요한 이벤트는 아파치 카멜(Apache Camel), 뮬(Mule), ESB, 스프링 인티그레이션(Spring Integration)등의 중재자를 사용한다.
- 조건부 처리가 많고 동적 경로가 많아 에러처리가 복잡하다면, 아파치ODE 나 오라클 BPEL 프로레스관리자(Oracle BPEL Process Manager)을 사용한다.

*BPEL(Business Process Execution Language)는 에러 처리, 리다이렉션, 멀티 캐스팅 기능을 하는 요소들이 체계적으로 구현되어 있다. BPEL은 복잡하고 동적인 워크플로에는 적합하지만, 이벤트 처리 중 사람이 개입하는, 실행 시간이 긴 트랜잭션이 필요한 워크플로에는 적합하지 않다.*

<br>

이벤트 복잡도를 한 가지 기준으로 평가하는 경우는 거의 없으므로, 단순함, 어려움, 복잡함 정도로 분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하자.

- 중재자는 이벤트 등급에 따라 이벤트를 직접 처리하거나 더 복합한 이벤트 중재자에게 위임하여ㅛ 모든 종류의 이벤트를 그에 알맞은 중재자가 효과적으로 처리할 수 있도록 할 수 있다.