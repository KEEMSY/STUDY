# **ch.4 컨텍스트 매핑과 전략적 설계**

핵심 도메인을 다른 바운디드 컨텍스트와 통합하는 것을 **컨텍스트 매핑** 이라고 한다.

- 컨텍스트 사이에는 통합뿐만 아니라 팀 간의 다양한 관계도 존재할 수 있다.
- 두 바운디드 컨텍스트 안에 각각의 보편언어가 있다는 것을 생각해보면, **컨텍스트 매핑**은 두 언어 사이의 통역을 나타낸다.
- **컨텍스트 매핑**에는 여러 좋유릐 **컨텍스트 매핑**이 있을 수 있다.(팀, 기술 등 모든 관계)

<br><hr><hr>

## **매핑의 종류**

**컨택스트 매핑**을 통해 다음과 같은 관계와 통합을 표현할 수 있다.

- **[파트너십](#파트너십)**
- **[공유 커널](#파트너십)**
- **[고객-공급자](#고객-공급자)**
- **[준수자](#준수자)**
- **[반부패 계층](#반부패-계층)**
- **[공개 호스트 서비스](#공개-호스트-서비스)**
- **[공표된 언어](#공표된-언어)**
- **[각자의 길](#각자의-길)**
- **[큰 진흙덩어리](#큰-진흙-덩어리)**

<br>

> ### **파트너십**

![partnership](/img/partnership.png)

두 팀 사이에 파트너십 관계에서, 각 팀은 하나의 **바운디드 컨텍스트**를 책임진다. 두 팀은 일련의 목표에 대한 의존성을 맞추기 위해 **파트너십**을 구성한다.

- 두 팀이 함께 성공하거나 다같이 실패한다.
- 상호 의존적인 작업이나 여러 일정들을 조율하고, 통합을 적절하게 유지하기 위해 지속적으로 통합에 노력한다.
- 이러한 형태의 동기화는 두 팀 사이에 굵은 매핑 선으로 표시한다.(굵은 선은 필요한 약속의 수준이 꽤 높음을 의미한다.)

<br><br>

> ### **공유 커널**

![sharedKernel](/img/sharedKernel.png)

두 **바운디드 컨텍스트**의 교차 지점으로 표시한 **공유 커널(Shared Kernel)** 은 팀 사이에 작지만 공통인 모델을 공유하는 관계를 나타낸다. **공유 커널**은 팀 사이에 열린 의사소통이 가능해야하고, 공유하는 모델에 대한 지속적인 합의가 있어한다.

- 각 팀은 공유하는 모델 요소에 대해 서로 협의해야한다.
- 공유하는 모델의 코드, 빌드를 관리하고 테스트 하는 것은 한 팀에서 맡아 수행한다.
- 관련된 모든 팀들이 각자 저마다의 길을 가는 것 보다 **공유 커널**이 더 좋은 생각이라고 여긴다면 좋은 결과를 얻을 수 있다.

<br><br>

> ### **고객-공급자**

![Upstream-Downstream](/img/Upstream-Downstream.png)

고객-공급자는 2개의 바운디드 컨텍스트와 각 팀들의 관계를 나타내는데, **공급자(Upstream; U)**, **고객(Downstream; D)** 로 표현한다. 고객-공급자는 팀 사이에 매우 일반적이고 현실적인 관계이며, 같은 조직 내에서도 마찬가지로 적용된다.

- 공급자는 고객이 뭔하는 것을 제공해야 때문에 관계를 주도한다.
- 고객은 다양한 기대를 충족시키기 위해 공급자와 함께 계획한다.
- 고객이 언제 무엇을 받게될지는 공급자가 결정한다.

<br><br>

> ### **준수자**

![conformist](/img/conformist.png)

**준수자(Conformist)** 관계는 **상류**와 **하류** 팀이 있고, 상류 팀이 하류 팀의 특정 요구에 지원할 동기가 없는 경우에 나타난다.

- 하류 팀이 자기들의 특정 요구에 맞춰 상류 모델의 보편언어를 계속 변화시는 것이 쉽지 않아 상류팀 모델을 그대로 따른다.
- 확실하게 자리잡은 매우 거대하고 복잡한 모델과의 통합이 필요할 때 이러한 유형이 나타난다.

<br><br>

> ### **반부패 계층**

![AnticorruptionLayer](/img/AnticorruptionLayer.png)

**반부폐 계층(Anticorruption Layer)** 은 가장 방어적인 **컨텍스트 매핑** 관계로, 하류 팀이 그들의 보편언어 모델과 상류 팀의 보편언어 모델 사이에 번역 계층을 만드는 것을 말한다.

- 하류 팀과 상류 팀 사이의 번역계층은 상류 모델로 부터 하류모델을 독립시키고 둘 사이를 번역한다.
- 가능하다면 하류모델과 상류 통합 모델 사이에 반부패 계층을 만들어 통합에 용이한 모델 개념들을 만들고, 원하는 형태의 특정 비즈니스 요구도 맞추며, 외부의 이질적인 개념으로부터 독립성을 유지시키는 것이 좋다.

<br>

> ### **공개 호스트 서비스**

![OpenHostServic](/img/OpenHostServic.png)

**공개 호스트 서비스(Open Host Service)** 는 일련의 서비스 처럼 **바운디드 컨텍스트**에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다.

- 프로토콜은 **바운디드 컨텍스트**와 통합하고자 하는 모두가 용이하게 사용할 수 있도록 "공개" 한다.
- API(애플리케이션 프로그래밍 인터페이스)로 제공하는 서비스는 문서화가 잘되어있어야한다.
- 공개 호스트는 서드파티에게 최상의 통합 경험을 줄 수 있는 **공표된 언어**를 제공한다.

<br>

> ### **공표된 언어**

![publishedLanguage](/img/publishedLanguage.png)

**공표된 언어**는 이를 사용하는 **바운디드 컨텍스트**의 규모에 관계없이, 모두 간단한 사용과 번역을 가능하게 하는 잘 문서화된 정보 교환을 말한다.

- 공표 문서는 `XML`, `JSON` 또는 `Protobuf`, `Avro` 와 같이 최적화된 작성 방식으로 정의할 수 있다.
- 이 결합은 매우 편리하게 두 **보편언어** 사이에 번역을 제공한다.

<br>

> ### **각자의 길**

![seperateWays](/img/seperateWays.png)

**각자의 길(Seperate Ways)** 은 1개 이상의 **바운디드 컨텍스트**를 통합으로, 다양한 **보편언어**를 사용하는 것이 유의미한 결과를 제공하지 못하는 상황을 말한다.
이 경우 현재의 **바운디드 컨텍스**트 내에서 이를 위한 해결방안을 만들고, 통합은 잊어버리는 것이 좋다.

- 찾는 기능을 다른 보편언어에서 완전히 제공하지 않는경우에 해당한다.

<br>

> ### **큰 진흙 덩어리**

우리는 **큰 진흙 덩어리**를 만드는 일은 기를쓰고 절대적으로 피해야한다.
**큰 진흙 덩어리**를 만들고 있다면 다음 상황들을 직면할 수 있다.

- 부적절한 연결과 의존으로 인해 문제를 확산 시키는 **애그리게잇**이 증가한다.
- 일부를 관리할 때, "두더지 잡기" 처럼 한 가지 문제가 해결돼도 또 다른 문제를 계속 야기 시킬 수 있다.
- 우리의 소중한 모델이 이해할 수 없는 늪에 빠지게 된다.
- 오직 전반적 지식과 모든 언어를 한 번에 다룰 수 있는 영웅 같은 사람이 있어야 시스템을 완전한 붕괴로 부터 지킬 수 있다.

<br>

만약 1개 이상의 **큰 진흙 덩어리**와 반드시 통합해야 한다면, 각 레거시 시스템에 대응한 **반부패 계층**을 만들어 우리들의 모델을 보호해야 한다.

<br><hr><hr>

## **컨텍스트 매핑 활용하기**

**바운디드 컨텍스트**를 통합할 때, 우리는 **컨텍스트 매핑**을 사용하여 통합할 것이다. 이 때 제공할 수 있는(제공받을 수 있는) 인터페이스는 다음과 같다.

- **[SOAP(Simple Object Access Product)를 이용한 RPC(Remote Procedure Call; 원격 프로시저 호출)](#rpcremote-procedure-call-원격-프로시저-호출)**
- **[RESTful](#레스트풀-http)**
- **[Messageing](#메시징)**

상황이 나쁜경우 데이터베이스나 파일 시스템의 통합을 강요 받을 수 있는데, 이런 일은 정말 피해야한다.

- 통합을 피할 수 없다면, 반드시 **반부패 계층**을 사용하여 우리의 모델을 독립시키자.

<br>

> ### **RPC(Remote Procedure Call; 원격 프로시저 호출)**

![SOAP](/img/SOAP.png)

원격 프로시저 호출의 방법으로 잘 알려진 방법으로는 `SOAP`를 이용하는 방법이다.

- `SOAP`를 이용한 **RPC**는 다른 시스템이 서비스를 사용할 때 마치 단순히 로컬 프로시저나 메서드를 호출하는 것처럼 사용한다는 개념을 말한다.
- `SOAP`은 네트워크를 통한 결과 반환을 보장해야한다. 그리고 이것은 첫 통합 수행 시점에 예기치 못한 결과 반환을 보장해야 한다.
- `SOAP`을 이용한 **RPC**는 클라이언트 바운디드 컨텍스트와 서비스를 제공하는 바운디드 컨텍스트 사이의 강한 결합을 암시한다.

<br>

`SOAP`나 다른 방식으로 **RPC**를 사용하는 것의 견고함이 떨어지는 문제가 발생할 수 있다.

- 네트워크나 `SOAP API`를 호스팅하는 시스템에 문제가 생기면, 간단한 프로시저 호출은 에러 결과만 받은 채 완전히 실패한다.

<br>

하지만 **RPC**가 재대로 동작하기만 한다면, 통합하기에 매우 좋은 방법이 될 수 있다.

- 공표된 언어로 공개 호스트 서비스를 제공하는 잘 설계된 API와 함께라면, 아주 좋을 것 같다.

<br>

외부의 잘 설계된 API가 있든 없든 원치 않는 외부의 영향으로부터 우리의 클라이언트 **바운디드 컨텍스트**를 분리할 필요가 있다면, **반부패 계층**을 정의하도록 하자.

<br>

> ### **레스트풀 HTTP**

![REST](/img/REST.png)

**레스트풀 HTTP**를 사용한 통합은 **바운디드 컨텍스트** 간에 교환되는 리소스뿐만 아니라 `POST`, `GET`, `PUT`, `DELETE` 이렇게 네 가지 주요 오퍼레이션들이 관여된다.

- **REST**방식은 분산 컴퓨팅에 적합한 API를 정의하는데 도움을 준다.
- **REST** 인터페이스를 제공하는 서비스 **바운디드 컨텍스트**는 공개 호스트 서비스와 공표된 언어를 제공해야 한다.
- **공표된 언어**로 리소스를 정의하고 **REST** URI로 구성하여 온전한 공개 호스트 서비스를 구성한다.

<br>

**레스트풀 HTTP는** 네트워크나 서비스 제공자의 장애 또는 예기치 않은 지연 등 **RPC**에서의 실패 원인과 동일한 사유로 실패 할 수 있다.
하지만 **레스트풀 HTTP** 는 인터넷의 전제에 기반을 두고 있고, 여태까지 웹이 보여준 신뢰성, 확장성 그리고 지금까지의 성공에 대해 흠을 잡을 상황은 아니라고한다.(불쌍한 RPC..)

<br>

**REST**를 사용할 때에는 다음을 주의한다.

- 도메인 모델 안에 직접적으로 **애그리게잇**을 반영하는 리소스를 설계하지 않는다.

     *모든 클라이언트에게 **준수자** 관계를 강요하지 않고, 모델 변화가 리소스 형태에 변화를 주지 않는다.*

<br>

- 리소스가 클라이언트 주도의 유스케이스를 지원할 수 있도록 종합적으로 설계한다.

    *실제 있는 그대로의 도메인 모델이 아니라 클라이언트에게 제공하는 리소스가 그들이 원하는 것에 대한 구성과 형태를 갖도록 고려한다.*

<br>

- 모델의 지금 현재 구성이 아니라 리소스의 설계를 활용한다.

    *클라이언트가 원하는 것의 모습을 띄도록 노력한다.*

<br>

> ### **메시징**

통합에 비동기 메시징을 사용하면 우리의 **바운디드 컨텍스트** 또는 다른 **바운디드 컨텍스트**가 발생하는 **도메인 이벤트**를 구독하는 클라이언트 **바운디드 컨텍스트**가 많은 것을 할 수 있게 한다.
메시징을 사용한 통합은 가장 견고한 형태 중 하나인데, 즉각적인 결과가 필수적이지 않을 때에는 메시징을 사용하여 견고한 시스템을 구축하는 것도 좋은 방법이다.

- **RPC**나 **REST**와 달리, 분절된 형태와 일시적인 결합을 대부분 제거할 수 있다.
- 클라이언트 **바운디드 컨텍스트**(C1)를 서비스 **바운디드 컨텍스트**(S1)와 통합할 때 비동기적으로 처리를 하여, 열차 사고를 막을 수 있다.

    *C1과 S1의 사이를 동기적으로 처리하면, 다른 클라이언트(C0)가 C1으로 요청한 것이 막혔을 때, 열차가 충돌하듯 C0, C1, S1 까지의 모든 요청이 막힐 수 있다.(이를 열차 사고라고 한다.)*

<br>

점점 증가하는 리소스들에 대해 **REST** 기반으로 폴링(polling)하는 방식으로 비동기 메시징을 구현해 처리할 수도 있다.
이 방법은, 서비스에서 계속 이벤트가 발생하는 상황일 경우 서비스와 클라이언트 사이에 비동기 오퍼레이션을 유지하는 매우 안전한 방식이다.

- 클라이언트는 백그라운드 프로세싱을 사용하여 계속하여 증가하는 **도메인 이벤트**를 제공하는 아톰피드(Atom feed) 리소스를 지속적으로 폴링한다.
- 서비스가 어떤 사유로 이용이 불가능하게 되면 클라이언트는 특정한 주기로 재시도하거나 리소스를 다시 이용할 수 있는 상황이 될 때 까지 재시도 할 수 있다.

    *더 많은 내용은 **도메인 주도 설계 구현**을 참고하자*

<br>

일반적으로 **바운디드 컨텍스트** 내의 **애그리게잇**은 **도메인 이벤트**를 만들 때 관심 있는 다른 컨텍스트들은 발생된 이벤트를 사용한다.

- 구독 **바운디드 컨텍스트**가 **도메인 이벤트**를 받으면, 이벤트의 형태와 값을 토대로 동작을 수행한다.
- 다른 **바운디드 컨텍스트**가 **도메인 이벤트**를 소비할 수 있게 하고, 소비하는 **바운디드 컨텍스트**에게 **준수자** 관계를 강요하지 않기위해, 소비자들은 이벤트 발행자의 이벤트 형태(예: 클래스)를 사용하지않고, 오직 이벤트 스키마(공표된 언어)에만 의존한다.

<br>

![at-least-once-delivery](/img/at-least-once-delivery.png)

통합에 **메시징** 을 사용하는 모든 경우, 전체 솔류션의 품질은 사용한 메시징 메커니즘의 품질에 크게 좌우된다. 메시징 메커니즘은[Reactive] 책에 설명한 **적어도 한번의 전달(At-least-onece delivery)** 을 통해 모든 메시지의 수신을 보장해야 한다.

- 구독 바운디드 컨텍스트는 **멱등 수신자(idempotent Receiver)** 로 구현돼야한다.
- 적어도 한 번의 전달은 메시징 메커니즘이 특정 메시지를 주기적으로 재전달하는 메시징 패턴을 말하며, 이것은 메시지 손실, 느린 반응, 수신자 장애, 수신자가 수신 사실을 알리는 데 실패하는 상황에서도 적용된다.
- 메시지가 한 번 이상 전달되면 수신자는 언제든지 이 상황을 제대로 처리할 수 있도록 **멱등 수신자**를 설계한다.
- **멱등 수신자**는 오퍼레이션이 여러 번 수행되더라도 동일한 결과가 되도록 만드는 방식을 말한다.
- **멱등 수신자**를 통해 수신자가 중복 제거 사용, 반복 메시지 무시 또는 이전에 전달된 메시지의 결과와 정확히 동일한 결과가 되도록 오퍼레이션 재수행을 안전하게 처리한다는 것을 의미한다.

<br>

메시징 메커니즘은 항상 비동기 **요청-응답** 통신을 사용하기 때문에 어느정도의 지연은 일반적이도 당연하다. 서비스가 종료되기 전에는 서비스에 대한 요청이 절대(거의) 막힐 일이 없기 때문에, 어느정도의 지연 발생을 감내할 수만 있다면, 메시징으로 설계하는 것은 전체 솔루션을 처음부터 매우 견고하게 만들 수 있다는 것을 의미한다.

<br><hr><hr>

## **컨텍스트 매핑 사례**

![policyIssued](/img/policyIssued.png)

**계약 심사 컨텍스트** 에서 **정책(Policy)** 컴포넌트가 만들어지면, **정책 발행(PolicyIssued)** 이라는 이름의 도메인 이벤트를 발생시킬 수 있다.

- **메시징** 구독을 통해 이를 제공받은 다른 **바운디드 컨텍스트**들이 이 도메인 이벤트에 반응하여, 구독 **바운디드 컨텍스트** 안에 이 정책에 상응하는 **정책 컴포넌트**를 만들 수 있다.
- 정책 발행 도메인 이벤트는 공식적으로 정책의 식별성(정책 ID)을 담아 정책들을 식별한다.

<br>

![domainEvnet](/img/domainEvnet.png)

모든 컴포넌트는 발신 주체인 계약 심사 컨텍스트로의 역추적을 위해 그 식별자를 보유한다.

- 정책 발행 도메인 이벤트가 제공하는 것 이상의 정책 데이터가 필요하면, 구독 바운디드 컨텍스트는 언제든지 계약 심사 컨텍스트 로부터 정책 발행 ID를 사용을 통해 더 많은 정보를 가져올 수 있다.

<br>

도메인 이벤트에 충분한 데이터를 담아 무겁게(혹은 가볍게)유지해야할 때에 대한 그 가이드는 다음으로 이야기할 수 있다.

- 모든 소비자를 만족시키기 위할 때, 자율성이 핵심 요구사항이라면, 우리는 도메인 이벤트에 충분한 데이터를 모두 담는다.
- 모든 소비자가 도메인 이벤트에 요구할 모든 데이터를 예측하는 것이 너무 어렵고, 모든 것을 제공하려면 너무 많은 것을 담아야 할 경우, 가벼운 도메인 이벤트와 소비자들이 높은 보안 수준에서 요청할 수 있는 풍부한 쿼리 모델을 설계한다.
- 물론 이 두가지 방식을 혼합해야 하는 상황도 존재함을 인지해야한다.

<br>

**계약 심사 컨텍스트**에서 재쿼리는 **계약 심사 컨텍스트**에 레스트풀 **공개 호스트 서비스**와 공표된 언어를 통해 이뤄 낼 수 있다.

- 간단한 HTTP GET와 `정책 발행 ID` 로 정책 발행 데이터를 검색할 수 있다.
