# **ch.4 컨텍스트 매핑과 전략적 설계**

핵심 도메인을 다른 바운디드 컨텍스트와 통합하는 것을 **컨텍스트 매핑** 이라고 한다.

- 컨텍스트 사이에는 통합뿐만 아니라 팀 간의 다양한 관계도 존재할 수 있다.
- 두 바운디드 컨텍스트 안에 각각의 보편언어가 있다는 것을 생각해보면, 컨텍스트 매핑은 두 언어 사이의 통역을 나타낸다.
- 컨텍스트 매핑에는 여러 좋유릐 컨텍스트 매핑이 있을 수 있다.(팀, 기술 등 모든 관계)

<br><hr><hr>

## **매핑의 종류**

컨택스트 매핑을 통해 다음과 같은 관계와 통합을 표현할 수 있다.

- **파트너십**
- **공유 커널**
- **고객-공급자**
- **준수자**
- **반부패 계층**
- **공개 호스트 서비스**
- **공표된 언어**
- **각자의 길**
- **큰 진흙덩어리**

<br>

> **파트너십**

![partnership](/img/partnership.png)


두 팀 사이에 파트너십 관계에서, 각 팀은 하나의 바운디드 컨텍스트를 책임진다. 두 팀은 일련의 목표에 대한 의존성을 맞추기 위해 파트너십을 구성한다.

- 두 팀이 함께 성공하거나 다같이 실패한다.
- 상호 의존적인 작업이나 여러 일정들을 조율하고, 통합을 적절하게 유지하기 위해 지속적으로 통합에 노력한다.
- 이러한 형태의 동기화는 두 팀 사이에 굵은 매핑 선으로 표시한다.(굵은 선은 필요한 약속의 수준이 꽤 높음을 의미한다.)

<br><br>

> **공유 커널**

![sharedKernel](/img/sharedKernel.png)

두 바운디드 컨텍스트의 교차 지점으로 표시한 공유 커널(Shared Kernel) 은 팀 사이에 작지만 공통인 모델을 공유하는 관계를 나타낸다. 공유 커널은 팀 사이에 열린 의사소통이 가능해야하고, 공유하는 모델에 대한 지속적인 합의가 있어한다.

- 각 팀은 공유하는 모델 요소에 대해 서로 협의해야한다.
- 공유하는 모델의 코드, 빌드를 관리하고 테스트 하는 것은 한 팀에서 맡아 수행한다.
- 관련된 모든 팀들이 각자 저마다의 길을 가는 것 보다 공유 커널이 더 좋은 생각이라고 여긴다면 좋은 결과를 얻을 수 있다.

<br><br>

> **고객-공급자**

![Upstream-Downstream](/img/Upstream-Downstream.png)

고객-공급자는 2개의 바운디드 컨텍스트와 각 팀들의 관계를 나타내는데, 공급자(Upstream; U), 고객(Downstream; D)로 표현한다. 고객-공급자는 팀 사이에 매우 일반적이고 현실적인 관계이며, 같은 조직 내에서도 마찬가지로 적용된다.

- 공급자는 고객이 뭔하는 것을 제공해야 때문에 관계를 주도한다.
- 고객은 다양한 기대를 충족시키기 위해 공급자와 함께 계획한다.
- 고객이 언제 무엇을 받게될지는 공급자가 결정한다.

<br><br>

> **준수자**

![conformist](/img/conformist.png)

준수자(Conformist) 관계는 상류와 하류 팀이 있고, 상류 팀이 하류 팀의 특정 요구에 지원할 동기가 없는 경우에 나타난다.

- 하류 팀이 자기들의 특정 요구에 맞춰 상류 모델의 보편언어를 계속 변화시는 것이 쉽지 않아 상류팀 모델을 그대로 따른다.
- 확실하게 자리잡은 매우 거대하고 복잡한 모델과의 통합이 필요할 때 이러한ㄴ 유형이 나타난다.

<br><br>

> **반부패 계층**

![AnticorruptionLayer](/img/AnticorruptionLayer.png)

반부폐 계층(Anticorruption Layer)은 가장 방어적인 컨텍스트 매핑 관계로, 하류 팀이 그들의 보편언어 모델과 상류 팀의 보편언어 모델 사이에 번역 계층을 만드는 것을 말한다.

- 하류 팀과 상류 팀 사이의 번역계층은 상류 모델로 부터 하류모델을 독립시키고 둘 사이를 번역한다.
- 가능하다면 하류모델과 상류 통합 모델 사이에 반부패 계층을 만들어 통합에 용이한 모델 개념들을 만들고, 원하는 형태의 특정 비즈니스 요구도 맞추며, 외부의 이질적인 개념으로부터 독립성을 유지시키는 것이 좋다.

<br>

> **공개 호스트 서비스**

![OpenHostServic](/img/OpenHostServic.png)

공개 호스트 서비스(Open Host Service)는 일련의 서비스 처럼 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다.

- 프로토콜은 바운디드 컨텍스트와 통합하고자 하는 모두가 용이하게 사용할 수 있도록 "공개" 한다.
- API(애플리케이션 프로그래밍 인터페이스)로 제공하는 서비스는 문서화가 잘되어있어야한다.
- 공개 호스트는 서드파티에게 최상의 통합 경험을 줄 수 잇는 공표된 언어를 제공한다.

<br>

> **공표된 언어**

![publishedLanguage](/img/publishedLanguage.png)

공표된 언어는 이를 사용하는 바운디드 컨텍스트의 규모에 관계없이, 모두 간단한 사용과 번역을 가능하게 하는 잘 문서화된 정보 교환을 말한다.

- 공표 문서는 XML, JSON 또는 Protobuf, Avro 와 같이 최적화된 작성 방식으로 정의할 수 있다.
- 이 결합은 매우 편리하게 두 보편언어 사이에 번역을 제공한다.

<br>

> **각자의 길**

![seperateWays](/img/seperateWays.png)

각자의 길(Seperate Ways)은 1개 이상의 바운디드 컨텍스트를 통합으로, 다양한 보편언어를 사용하는 것이 유의미한 결과를 제공하지 못하는 상황을 말한다.
이 경우 현재의 바운디드 컨텍스트 내에서 이를 위한 해결방안을 만들고, 통합은 잊어버리는 것이 좋다.

- 찾는 기능을 다른 보편언어에서 완전히 제공하지 않는경우에 해당한다.

<br>

> **큰 진흙 덩어리**

우리는 큰 진흙 덩어리를 만드는 일은 기를쓰고 절대적으로 피해야한다.
큰 진흙 덩어리를 만들고 있다면 다음 상황들을 직면할 수 있다.

- 부적절한 연결과 의존으로 인해 문제를 확산 시키는 애그리게잇이 증가한다.
- 일부를 관리할 때, "두더지 잡기" 처럼 한 가지 문제가 해결돼도 또 다른 문제를 계속 야기 시킬 수 있다.
- 우리의 소중한 모델이 이해할 수 없는 늪에 빠지게 된다.
- 오직 전반적 지식과 모든 언어를 한 번에 다룰 수 있는 영웅 같은 사람이 있어야 시스템을 완전한 붕괴로 부터 지킬 수 있다.

<br>

만약  1개 이상의 큰 진흙 덩어리와 반드시 통합해야 한다면, 각 레거시 시스템에 대응한 반부패 계층을 만들어 우리들의 모델을 보호해야 한다.


<br><hr><hr>

## **컨텍스트 매핑 활용하기**

바운디드 컨텍스트를 통합할 때, 우리는 컨텍스트 매핑을 사용하여 통합할 것이다. 이 때 제공할 수 있는(제공받을 수 있는) 인터페이스는 다음과 같다.

- SOAP(Simple Object Access Product)를 이용한 RPC(Remote Procedure Call; 원격 프로시저 호출)
- RESTful
- Messageing

상황이 나쁜경우 데이터베이스나 파일 시스템의 통합을 강요 받을 수 있는데, 이런 일은 정말 피해야한다.

- 통합을 피할 수 없다면, 반드시 반부패 계층을 사용하여 우리의 모델을 독립시키자.

<br>

>**RPC(Remote Procedure Call; 원격 프로시저 호출)**

원격 프로시저 호출의 방법으로 잘 알려진 방법으로는 SOAP를 이용하는 방법이다.

- SOAP를 이용한 RPC는 다른 시스템이 서비스를 사용할 때 마치 단순히 로컬 프로시저나 메서드를 호출하는 것처럼 사용한다는 개념을 말한다.
- SOAP은 네트워크를 통한 결과 반환을 보장해야한다. 그리고 이것은 첫 통합 수행 시점에 예기치 못한 결과 반환을 보장해야 한다.
- SOAP을 이용한 RPC는 클라이언트 바운디드 컨텍스트와 서비스를 제공하는 바운디드 컨텍스트 사이의 강한 결합을 암시한다.

<br>

SOAP나 다른 방식으로 RPC를 사용하는 것의 견고함이 떨어지는 문제가 발생할 수 있다.

- 네트워크나 SOAP API를 호스팅하는 시스템에 문제가 생기면, 간단한 프로시저 호출은 에러 결과만 받은 채 완전히 실패한다.

<br>

하지만 RPC가 재대로 동작하기만 한다면, 통합하기에 매우 좋은 방법이 될 수 있다.

- 공표된 언어로 공개 호스트 서비스를 제공하는 잘 설계된 API와 함께라면, 아주 좋을 것 같다.

<br>

외부의 잘 설계된 API가 있든 없든 원치 않는 외부의 영향으로부터 우리의 클라이언트 바운디드 컨텍스트를 분리할 필요가 있다면, 반부패 계층을 정의하도록 하자.

<br>

> **레스트풀 HTTP**

레스트풀 HTTP를 사용한 통합은 바운디드 컨텍스트 간에 교환되는 리소스뿐만 아니라 POST, GET, PUT, DELETE 이렇게 네 가지 주요 오퍼레이션들이 관여된다.

- REST방식은 분산 컴퓨팅에 적합한 API를 정의하는데 도움을 준다.
- REST 인터페이스를 제공하는 서비스 바운디드 컨텍스트는 공개 호스트 서비스와 공표된 언어를 제공해야 한다.
- 공표된 언어로 리소스를 정의하고 REST URI로 구성하여 온전한 공개 호스트 서비스를 구성한다.

<br>

레스트풀 HTTP는 네트워크나 서비스 제공자의 장애 또는 예기치 않은 지연 등 RPC에서의 실패 원인과 동일한 사유로 실패 할 수 있다.
하지만 레스트풀 HTTP는 인터넷의 전제에 기반을 두고 있고, 여태까지 웹이 보여준 신뢰성, 확장성 그리고 지금까지의 성공에 대해 흠을 잡을 상황은 아니라고한다.(불쌍한 RPC..)

<br>

REST를 사용할 때에는 다음을 주의한다.

- 도메인 모델 안에 직접적으로 애그리게잇을 반영하는 리소스를 설계하지 않는다. 

     *모든 클라이언트에게 준수자 관계를 강요하지 않고, 모델 변화가 리소스 형태에 변화를 주지 않는다.*

<br>

- 리소스가 클라이언트 주도의 유스케이스를 지원할 수 있도록 종합적으로 설계한다.

    *실제 있는 그대로의 도메인 모델이 아니라 클라이언트에게 제공하는 리소스가 그들이 원하는 것에 대한 구성과 형태를 갖도록 고려한다.*

<br>

- 모델의 지금 현재 구성이 아니라 리소스의 설계를 활용한다.

    *클라이언트가 원하는 것의 모습을 띄도록 노력한다.*

<br>

