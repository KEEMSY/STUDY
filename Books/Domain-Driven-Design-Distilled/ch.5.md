# **ch.5 애그리게잇과 전술적 설계**

![5.topic](/img/5.topic.png)

이번 장에서는 2개의 **바운디드 컨텍스트**를 가지고 이야기한다.

- 1: 애자일 프로젝트 관리 컨텍스트 라는 이름의 **핵심도메인**
- 2: 다른 컨텍스트 매핑 통합 기반의 협업 도구를 제공하는 **지원 서브 도메인**

각각의 도메인 안에 **애그리게잇** 들은 다음과 같다.

- `Product`
- `BacklogItem`
- `Release`
- `Sprint`
- `Forum`
- `Discussion`
- `Post`
- `Calendar`
- `CalendarEntry`

*Discussion은 **값 객체(Value Object)** 이다.*

<br>

![aggregate](/img/aggregate.png)

각 **애그리게잇** 은 1개 이상의 **엔터티**로 구성되고, 그 중 한 **엔터티** 는 **애그리게잇 루트** 라고 부른다.

- **애그리게잇** 은 그 구성에 **값 객체**를 포함할 수 있다.
- 각 **애그리게잇**의 **루트 엔터티**는 **애그리게잇** 안의 다른 모든 요소를 소유한다.
- **애그리게잇** 은 개념적으로 완전하게 모델링해야 한다.
- 각 **애그리게잇** 은 일관성 있는 트랜잭션 경계를 형성한다.
- 한 **애그리게잇** 내의 모든 구성 요소는 반드시 비즈니스 규칙을 따르면서 일관성 있게 처리 되어야 한다.(**애그리게잇** 내에 트랜잭션 이후 일관성이 지켜질 필요가 없는 다른 요소를 포함해서는 안된다는 것은 아니다.)

<br>

**엔터티(Entity)** 란 같은 형태를 띄거나 다른 형태의 **엔터티** 들과의 특성을 구별할 수 있는 고유한 식별성을 갖는 것을 말한다.

- **엔터티**는 변할 수 있다.(항상 그 상태는 계속해서 변할 수 있음을 명심한다.)
- **엔터티**를 구분해주는 주 요인은 독립성에 있다.
- **루트 엔터티**의 명칭은 **애그리게잇**의 개념적 명칭으로, **애그리게잇** 이 모델링 하는 개념적 완전성을 적절하게 표현할 수 있는 것으로 지정한다.

<br>

**값 객체(Value Object)** 란 불변의 개념적 완전성을 모델링 한다.

- 모델에서 **값** 은 그말 그대로 값을 의마한다.
- **엔터티** 와 달리 고유한 식별성이 없으며, 값 형태로 캡슐화된 속성을 비교함으로써 동일함이 결정된다.
- **값 객체** 가 어떤 것을 나타낸다기 보다, **엔터티**를 서술하고, 수량화 하거나 측정하는데 사용된다.

<br>

애플리케이션에 대한 트랜잭션의 사용은 어느 정도 구현에 관한 세부 사항이다. 트랜잭션이란 **애그리게잇** 에 대한 변경을 독립시키고, 소프트웨어가 언제나 충실히 준수해야 하는 규칙인 비즈니스 불변성을 각 비즈니스 오퍼레이션에 맞게 일관성을 보장한다.

- 액터 모델과 같은 다른 아키텍처 활용 사례에서는 각 **애그리게잇** 을 액터로 구현하고, 트랜잭션은 데이터베이스에 대한 원자적(ATOMIC) 트랜잭션을 지원하지 않는 **이벤트 소싱** 을 사용한다.
- **애그리게잇** 의 상태나 이벤트 소싱은 항상 안전하고 정확하게 트랜잭션으로 처리하고 관리해야 한다.
- **애그리게잇** 이 완전하고 유효한 상태로 저장되지 않는다면, 수행된 비즈니스 오퍼레이션은 비즈니스 규칙에 어긋난것으로 간주한다.

<br>

**애그리게잇** 은 별로 분리된 트랜잭션으로 수정, 커밋된다. 이러한 이유로 **애그리게잇**을 트랜잭션의 일관성을 만드는 경계라고 부른다.

- **애그리게잇** 구성 요소들은 트랜잭션의 일관성과 성공을 보장하도록 설계해야한다.
- 예를 들어, "`애그리게잇 형태1`" 인스턴스는 "`애그리게잇 형태2`" 인스턴스로 부터 분리된 트랜잭션으로 제어되어야 한다.

<br>

<br><hr><hr>

## **애그리게잇 경험 법칙**

효과적으로 동작하는 **애그리게잇** 을 설계하는데 도움을 줄 수 있는 **애그리게잇** 설계의 기본 규칙은 다음과 같다.

1. **[애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라.](#규칙-1-애그리게잇-경계-내의-비즈니스-불변사항을-보호하라)**
2. **[작은 애그리게잇을 설계하라.](#규칙-2-작은-애그리게잇을-설계하라)**
3. **[오직 ID를 통해 다른 애그리게잇을 참고하라.](#규칙-3-오직-식별자로만-다른-애그리게잇을-참고하라)**
4. **[결과적 일관성을 사용해 다른 애그리게잇을 갱신하라](#규칙-4-결과적으로-일관성을-사용해-다른-애그리게잇을-갱신하라)**

<br>

> ### **규칙 1: 애그리게잇 경계 내의 비즈니스 불변사항을 보호하라**

![agrregateRule](/img/agrregateRule.png)

규칙 1은 트랜잭션이 커밋될 때 비즈니스의 일관성이 지켜지는 것에 기반을 두고 **애그리게잇** 구성요소를 결정해야한다는 것을 의미한다.

- Product 는 트랜잭션의 끝에 ProductBacklogItem 인스턴스로 구성되는 모든 것이 반드시 Product의 루트와 일관되게 처리되도록 설계한다.
- Sprint 는 트랜잭션의 끝에 CommitedBacklogItem 인스턴스로 구성되는 모든 것이 반드시 Sprint 루트와 일관되게 처리하도록 설계한다.

<br>

![agrregateRule1](/img/agrregateRule1.png)

`BacklogItem`의 애그리게잇을 예시로 설명한다.

- `Task(작업)` 인스턴스의 `hoursRemaining(남은시간)`이 0일 때, `BackligItem`의 `Status(상태)`는 반드시 `DONE(완료)`으로 설정해야한다는 비즈니스 규칙이 존재한다.
- 이는 트랜잭션 후 반드시 부합되어야 하는 매우 명확한 비즈니스 불변사항을 의미하낟.

<br>

> ### **규칙 2: 작은 애그리게잇을 설계하라**

![agrregateRule2Bad](/img/agrregateRule2Bad.png)

규칙 2는 각 **애그리게잇** 의 메모리 사용량과 트랜잭션 범위가 비교적 작아야 함을 강조한다. 위의 다이어그램은 작은 **애그리게잇** 이 아니다.

- `Product`는 문자 그대로의 `BacklogItem` 인스턴스를 그리고, `Sprint`의 가능한 가장 큰 모음을 담고 있다.
- 이러한 모음들은 시간이 지나면서, 엄청나게 크게 불어날 수 있다.
- 애그리게잇이 너무 많은 일을 한다면 `SRP`를 따르지 않는 것이며, 이후 애그리게잇의 크기에 대해 재논의할 가능성이 크다.

<br>

![agrregateRule2Good](/img/agrregateRule2Good.png)

`Product` **애그리게잇**을 4개의 **애그리게잇**으로 분해하면 다음과 같은 장점이 존재한다.

- 빠르게 로드되고, 더 작은 메모리를 차지하며, 가비지 컬렉션이 빠르다.
- 이전의 큰 클러스터의 `Product` 애그리게잇보다 훨씬 더 자주, 성공적인 트랜잭션을 수행할 것이다.

     *`BacklogItem`, `Release`, `Sprint` 모두가 `ProductId` 를 유지함으로써 `Product` 를 참고하는 것을 확인할 수 있는데, 이를 통해 **애그리게잇**을 작게 유지하고, 동일한 트랜잭션 내에 여러 **애그리게잇**을 수정하려는 접근을 방지해준다.*

- 연관된 각 작업이 한 명의 개발자가 관리할 수 있을 만큼 작기 때문에 각 **애그리게잇**이 좀 더 쉬워지는 부가적인 이득이 존재한다.
- 테스트가 쉬워진다.

<br>

> ### **규칙 3: 오직 식별자로만 다른 애그리게잇을 참고하라**

![agrregateRule3](/img/agrregateRule3.png)

작은 분해된 **애그리게잇**은 식별자를 통해서만 다른 **애그리게잇**을 참조해야한다.

- 이를 통해 동일한 트랜잭션 내에 다른 **애그리게잇**을 수정하지 않는 규칙이 잘 지켜질 수 있도록 해준다.
- 오직 **애그리게잇**의 식별자를 통해서만 접근이 가능하고, 그 이외의 방법으로 다른 **애그리게잇** 내의 객체 래퍼런스를 얻어낼 수 있는 방법은 없다.
- **애그리게잇**을 `관계형 데이터베이스`, `문서 데이터베이스`, `키/밸류 리포지토리` 그리고 `데이터 그리드/패브릭(grids/fabrics)`와 같은 다른 형태의 저장 매커니즘으로 쉽게 저장할 수 있다.

<br>

> ### **규칙 4: 결과적으로 일관성을 사용해 다른 애그리게잇을 갱신하라**

![agrregateRule4](/img/agrregateRule4.png)

`BacklogItem` 은 `Sprint` 와 연계되어 수행되어, `BacklogItem` 과 `Sprint` 모두 이것에 맞춰 설계가 이루어진다.

- `BacklogItem` 은 관여된 `SprintId` 를 알아야한다. 이는 `BacklogItem` 의 상태가 `Sprint` 의 `SprintId` 를 갖도록 정의하는 하나의 트랜잭션 안에서 관리된다.

<br>

![aggregateMessaging](/img/aggregateMessaging.png)

다음의 과정을 통해 `Sprint` 관점에서 새롭게 할당된 `BacklogItem` 의 `BacklogItemId` 로 연계되어 제대로 실행됨을 확신할 수 있다.

- `BacklogItem` **애그리게잇**의 트랜잭션의 일부로, **BacklogItemCommited** 라는 도메인 이벤트를 발행한다. `BacklogItem` 트랜잭션을 완료한 후의 상태는 `BacklogItemCommited` **도메인 이벤트**를 통해 유지된다.
- `BacklogItemCommited` 가 로컬 구독자에게 전달되면, 트랜잭션이 시작되고 `Sprint` 의 상태는 할당된 `BacklogItem` 의 `BacklogItemId` 를 보유하도록 수정된다.
- `Sprint는` 새로운 `ÇommitedBacklogtItem` **엔터티** 안에 `BacklogItemId` 를 보유한다.

<br>

`BacklogItem` **애그리게잇** 과 `Sprint` **애그리게잇** 의 경우, 발행자와 구독자가 같은 **바운디드 컨텍스트** 안에 있어, 굳이 이런 상황을 위해 메시징 미들웨어를 사용할 필요는 없지만, 다른 **바운디드 컨텍스트**에 이벤트를 발행시키기 위한 용도로 **메시징** 을 사용한다면, 이 경우에도 사용하는 것이 좋다.

<br><hr><hr>

## **애그리게잇 모델링**

도메인 모델 관련, **애그리게잇** 구현에 대한 작업을 할 때, 만나기 쉬운 문제들이 존재한다.

- **빈약한 도메인 모델(Anemic Domain Model)**

    : 객체지향 도메인 모델을 사용하면서, 모든 애그리게잇이 비즈니스 행위가 아닌 읽고(getters) 쓰는(setters) 공개 접근자만 을 갖는데, 이는 모델링을 하면서 비즈니스 모델보다는 기술적인 부분에 초점을 맞췄을 때 발생한다.

- **비즈니스 로직을 도우미(helper)나 유틸리티(utility)클래스에 위임하는 경우**

    : 비즈니스 로직이 도메인 모델을 넘어 애플리케이션 서비스까지 새어나간 경우로, 원하는대로 작동하지 않을 확률이 높다. 서비스 유틸리티는 항상 정체성에 혼란을 주고, 요구사항을 올바르게 유지시키지도 못한다.

<br>

![baseAggregateType](/img/baseAggregateType.png)

기초적인 애그리게잇 설계를 구현할 때 참고해야할 사항들은 다음과 같다.

- [**애그리게잇 루트 엔터티 클래스 생성하라.**](#애그리게잇-루트-엔터티-클래스-생성하라)
- [**추상화를 조심스럽게 선택하라.**](#추상화를-조심스럽게-선택하라)
- [**올바른 크기의 애그리게잇을 지정하자.**](#올바른-크기의-애그리게잇을-지정하자)
- [**테스트 가능한 단위**](#테스트-가능한-단위)

<br>

> ### **애그리게잇 루트 엔터티 클래스 생성하라.**

표준 Entity 타입을 나타낸다. *좀 더 상세한 **엔터티** 와 **에그리게잇** 의 설계 및 구현 관련 사항은 **도메인 주도 설계 구현** 에서 확인할 수 있다.*

모든 **애그리게잇 루트 엔터티**는 전체 시스템에서 고유한 식별성을 가져야한다. 제공되는 서비스를 구독하는 모든 조직은 해당 고유한 식별성을 갖고 있어야 한다.

본질적 속성을 위해 읽기 접근자(getter)와 같은 간단한 행위를 추가할 수 있다. 단 속성 쓰기 메서드를 공개로 공개한다면, 로직이 모델 밖에 구현될 것이기 때문에 **빈약한 도메인** 으로 쉽게 빠질 수 있다.

<br>

> ### **추상화를 조심스럽게 선택하라.**

효과적인 소프트웨어 모델은 항상 일을 하는 비즈니스 방식을 고려한 일련의 추상화에 기반을 두고 있다. 이 때 모델링하는 각 개념마다 적절한 추상화를 선택해야 한다.

부적절한 추상화 수준은 기술적인 측면으로 구현을 생각하는 상황에서 자주 등장하므로 주의하자.
높은 수준의 추상화 구현이라는 덫에 현혹되지 않고, 팀이 정의한 도메인 전문가의 멘탈 모델에 따라 보편언어를 모델링 해야한다.

비즈니스가 지금 당장 요구하는 것을 모델링하면 상당한 시간, 예산, 코드를 아낄 수 있다. 더 나아가 정확하고 유용한 바운디드 컨텍스트에 효과적인 설계를 반영한 모델링을 이뤄 낼 수 있다.

<br>

> ### **올바른 크기의 애그리게잇을 지정하자.**

일관성 경계 목표에 달성하기 위해 아래의 설계단계들을 기억하자.

1. **우리는 애그리게잇 설계의 두 번째 규칙인 "`작은 애그리게잇을 설계하라`"에 집중해야한다. **애그리게잇 루트** 로 제공될 오직 1개의 **엔터티** 만을 갖는 **애그리게잇** 을 생성한다. 각 **엔터티** 들은 단일 **루트 엔터티** 와 관련이 가장 깊다고 생각되는 필드/속성/프로퍼티로 채운다.**

    가장 주의할 점은 **애그리게잇** 을 식별하고 찾는 데 필요한 모든 필드/속성/프로퍼티를 정의하는 것 뿐만아니라 **애그리게잇** 을 초기에 만들 때 유요한 초기 상태를 구성하는 데 필요한 모든 추가적인 필드/속성/프로퍼티를 정의하는 것이다.

    즉, 단일 **엔터티 애그리게잇**을 저장할 때 모든 필드/속성이 반드시 최신의 정보를 포함된 상태어야한다는 것이다.

    <br>

2. **애그리게잇 설계의 첫 번째 규칙인 "애그리게잇 경계 내의 비즈니스 불변사항을 보호하라."를 신경쓴다.**

    **애그리게잇** `A1`을 살펴볼 때, 이미 정의한 다른 **애그리게잇** 들 중에 `A1` **애그리게잇** 이 변경될 때 함께 갱신돼야 하는 것이 있는지 도메인 전문가에게 확인한다.

    **애그리게잇** `A1`을 ***목록***의 가장 앞에 위치 시키고, `A1`의 변경에 따라 바뀌어야할 다른 **애그리게잇** 들을 그 아래에 위치시킨다.

    ***목록**은 애그리게잇의 행위에 관련된 모든 갱신에 걸리는 시간을 파악할 수 있는 관련된 각 애그리게잇의 목록을 말한다.*

     <br>

3. **반응에 맞춘 갱신이 일어나는 시간은 얼마나 걸릴지 도메인 전문가에게 확인한다. 만약 각각의 애그리게잇들이 즉시 처리돼야 할 경우, 동일한 애그리게잇 경계안에 그 2개의 엔터티를 구성하는 것을 긍정적으로 검토한다.**

    이는 **애그리게잇** `A1`와 **애그리게잇** `A2`를 새로운 **애그리게잇** `A[1,2]`로 구성한다는 것이다. 이렇게 변경할 경우, 이전에 정의했던 **애그리게잇** `A1`과 `A2`는 더이상 존재하지 않고 오직 **애그리게잇** `A[1.2]`만 존재한다.

     <br>

4. **각각의 애그리게잇들이 주어진 시간에 따라 각각 반응하는 경우, 애그리게잇 설계의 네 번째 규칙인 "결과적 일관성을 사용해 다른 애그리게잇을 갱신하라"를 사용하여 갱신한다.**

<br>

이러한 활동은 결과적 일관성이 기술 주도가 아닌, 비즈니스 주도라는 것을 보여준다.

- 즉시 또는 적절한 트랜잭션으로 처리되야 하는 것들은 동일한 **애그리게잇**으로 관리해야한다.
- 결과적인 일관성이 필요한 경우 메시징과 같은 **도메인 이벤트**를 통해 관리해햐한다.
- 실제 비즈니스가 어떤 일을 수행해야하는지를 생각하는 것은 다양한 도메인 오퍼레이션들이 비즈니스 행위를 모델링한 소프트웨어에 통찰을 주며, 이는 비즈니스에 가치를 전달해준다.

<br>

> ### **테스트 가능한 단위**

단위 테스트를 위해 **애그리게잇** 을 철저하게 캡슐화되도록 설계한다. 복잡한 **애그리게잇** 은 테스트하기도 힘들다.

- 테스트는 **애그리게잇** 이 수행하길 기대하는 대로 정확하게 수행되는지 테스트하는 것이다.
- **애그리게잇** 의 모든 오퍼레이션이 정확성, 품질, 안성성을 보장해야한다.
