# **ch.2 바운디드 컨텍스트 및 보편언어와 전략적 설계**

DDD는 명확하게 **바운디드 컨텍스트** 내에서 **보편언어**를 모델링 하는 것에 대한 것이다.

> **바운디드 컨텍스트**

**바운디드 컨텍스트**는 의미적으로 동일한 컨텍스트의 범위를 표현한다.

- 이것은 그 범주 내에서 소프트웨어 모델의 각 컴포넌트는 특정한 의미를 갖고, 특정한 일을 수행한다는 것을 의미한다.
- **바운디드 컨텍스트** 내에 존재하는 컴포넌트들은 컨텍스트에 특화돼 있으며, 컨텍스트 안에서 의미가 살아난다.
- **바운디드 컨텍스트** 마다 소스코드와 데이터베이스 스키마도 명확히 분리한다.(메인 소스 코드와 함께 인수 테스트와 단위테스트를 유지해야한다.)

<br>

**바운디드 컨텍스트**는 모델이 구현되는 곳이며, **바운디드 컨텍스트**마다 각각 분리된 소프트웨어 산출물이 나온다.

- 컨텍스트 범위 내의 소프트웨어 모델은 **바운디드 컨텍스트** 안에서 일하는 팀이 생성하고, 그 안에서 가능하는 소프트웨어 모델을 만드는 모든 팀 구성원이 사용하는 언어를 반영한다.
- 소프트웨어 모델 안에 구현되기 때문에 ***보편언어*** 라고 부른다.

<br>

각각의 **바운디드 컨텍스트**는 단일 팀에만 할당 돼야하고, 각 **바운디드 컨텍스트**마다 독립적인 소스 코드 리포지토리가 있어야한다.

- 한 팀은 다수의 **바운디드 컨텍스트**에 대해 일을 할 수 있지만, 다수의 팀이 하나의 **바운디드 컨텍스트**를 수행할 수는 없다.
- 하나의 **바운디드 컨텍스트**를 한 팀이 수행한다는 것은 다른 팀이 소스 코드를 변경할 때 반갑지 않은 문제가 발생할 가능성을 완전히 제거 할 수 있음을 의미한다.
- 각 팀은 각자의 소스 코드와 데이터베이스를 소유하고, 공식 인터페이스를 정의하여 **바운디드 컨텍스트**를 다른 팀이 사용할 수 있게 허용한다.(DDD의 이점)

<br>

![diffPolicies](/img/diffPolicies.png)
DDD는 서로 다른 개념들을 각기 다른 **바운디드 컨텍스트** 안으로 분리해 놓음으로써 개념 간 차이를 더욱 중시한다.

- 각기 다른 언어와 그에 따른 기능이 존재하는 것을 인정한다.
- 정책에 3가지 의미가 존재한다면, 3개의 **바운디드 컨텍스트**가 존재하고, 각 컨텍스트들은 그들만의 고유한 정책적 특성을 포함한 정책을 갖는다.
- **바운디드 컨텍스트**의 이름으로 범위를 관리한다.

<br>

> **보편언어**

**보편언어**는 소프트웨어 모델을 만드는 팀 구성원들이 사용하는 언어를 말한다.

- **보편언어**는 엄격하고, 정확하고, 엄중하며, 단호해야한다.
- 팀의 누군가 **보편언어** 표현을 사용하면, 팀 모두가 그 표현이 가진 제약사항가 정확한 의미를 이해한다.
- 대표적인 기록의 형태는 소프트웨어 모델의 소스코드 이다.
- 최고의 **보편언어**는 서로 협업하며 나오는 거듭된 피드백에 의해 만들어지며, 이 과정에서 팀의 화합된 멘탈 모델을 만들 수 있다.

<br>

> **핵심도메인**

**바운디드 컨텍스트**가 조직의 핵심 전략적 계획으로 개발 되고 있을 때, 이를 ***핵심 도메인*** 이라고 한다.

- **핵심 도메인**은 가치 있는 것들을 달성하는 수단으로 가장 중요한 소프트웨어 모델 중 하나 이다.
- **핵심 도메인**은 다른 조직과의 경쟁에 대한 차별화를 위해 개발한다.
- 기업의 올바른 전략적 결정을 위해 무엇이 핵심 도메인이어야하고, 어떤 것을 제외시켜야 하는지 현명하게 선택해야한다.(이는 DDD의 주된 가치 제안이다.)
- 즉, 핵심 도메인에 최적의 자원을 투여하여 적절하게 투자해야한다.

<br>

> **기본적인 전략적 설계**

**바운디드 컨텍스트**를 사용하는 것은 "핵심은 무엇인가?" 라는 질문을 유도한다. **바운디드 컨텍스트**는 전략적 계획의 핵심이 되는 모든 개념들을 밀접하게 포용해야하고, 나머지는 모두 제외시켜야한다.

- **바운디는 컨텍스트**에 남은 개념들은 팀이 사용하는 보편언어의 일부가 된다.
- 엄격하게 핵심만 걸러낸 후 살아남은 개념들은 해당 바운디드 컨텍스트를 소유하는 팀의 보편언어 일부가 된다. 경계는 그 안의 엄격함을 강조한다.

<br>

핵심을 파악하기 위해 필수적으로 도메인 전문가와 소프트웨어 개발자를 하나로 묶어 협업하는 팀을 만들어야한다.

- 도메인 전문가는 비즈니스 문제에 좀 더 집중한다. 이들의 생각은 비즈니스가 동작하는 방법에 대한 비전에 의미를 둔다.
- 스크럼 도메인에서는 스크럼이 프로젝트에서 어떻게 실행되는지 완벽하게 이해하고 있는 스크럼 마스터가 도메인 전문가이다.
- 도메인 전문가는 다양한 비즈니스 영역들마다 존재한다. 이것은 직책이 아니라 주로 비즈니스에 중점을 두는 사람들을 지칭한다.

- 개발자는 소프트웨어 개발에 중점을 둔다. DDD 프로젝트를 수행하는 개발자는 핵심 전략 목표의 비즈니스 초점을 받아들이지 못하는 기술 중심의 주장을 하지 않도록 주의한다.
- 근거 없는 간결성은 피하고, 해당 팀의 바운디드 컨텍스트 안에 팀이 점진적으로 개발하는 보편언어를 수용할 수 있어야 한다.

<br>

> **기술적 복잡도가 아닌 비즈니스 복잡도에 집중하라.**

DDD를 사용하는 이유는 비즈니스 모델의 복잡도가 높기 때문이다. 그렇다고 해서 도메인 모델이 가져야 하는 복잡도 이상으로 더 복잡한 모델을 만들어야한다는 의미는 아니다. **프로젝트의 기술적 측면보다 비즈니스 모델이 더 복잡하기 때문에 DDD를 사용한다.**(이것이 개발자가 도메인 전문가와 함께 비즈니스 모델을 파고들어야하는 이유이다.)

<br>

개발자와 도메인 전문가 모두 문서가 대화를 지배하는 상황을 피해야한다.

- 문서 자체는 도메인 모델이 아니다. 더 정확히 말하자면 도메인 모델 개발을 도와주는 도구일 뿐이다.
- 열려있는 대화, 탐구 그리고 현재의 지식 기반에 대한 도전의 결과는 핵심 도메인에 대한 더 깊은 통찰로 이어질 수 있다.

<br>

> **도전과 통합**

가장 간단한 도전은 거대한 모델의 각 개념들이 스크럼의 **보편언어**를 따르는지 되묻는 것이다.

- 모델 관련 여러 가지 시도를 통해 더 깔끔하고 명확한 **보편언어** 모델을 만들 수 있다.
- 이런 단계들을 거처, 한층 간결해진 실제 **핵심 도메인** 만을 추려낼 수 있다.
- **핵심 도메인**에서 제외시킨 다른 모델링 개념들은 각각의 **바운디드 컨텍스트** 내에 정의되거나, 각각의 **보편언어**에 연결된다. 그리고 **컨텍스트 매핑**을 이용하여 그들을 통합 할 수 있다.

<br>

> **행위 주도 개발(BDD; Behavior-Driven Development)**

작성된 시나리오를 팀의 명세서와 비교해 어떻게 도메인 모델을 검증하는데 사용할 산출물로 전환하는 방법으로, **사례를 통한 명세** 라고 부른다.

- 공유된 이해를 기반으로 보편언어와 모델을 협업을 통해 개발 및 정제하고 모델이 명세서를 준수하고 있는지를 확인한다.
- 이는 인수 테스트를 만들어보면서 수행할 수 있다.
- Given, When, Then 등의 표현을 통해 시나리오 검증을 유용하게 할 수 있다.
- **도메인 모델**을 검증할 때 인수테스트(단위테스트가 아님)를 생성해 검증할 수도 잇지만, 단위테스트 프레임워크를 사용하여 이와 거의 비슷한 결과를 달성할 수도 있다.
- 인수테스트에 대한 단위테스트 기반 접근법은 실행 가능한 명세와 동일한 목적을 달성시켜준다. 이런 방식을 통해 좀 더 신속하게 시나리오를 검증할 수 있다.

<br>

> **아키텍처**

![contextArchitecture](/img/contextArchitecture.png)

**바운디드 컨텍스트** 안에는 도메인 모델 이상의 다양한 요소들로 구성된다.

- 사용자 인터페이스 컨트롤러
- 레스트 엔드포인트(REST endpoints)
- 인풋 어댑터(input Adapter): 메시지 리스너(message listenter)가 이에 속한다.
- 애플리케이션 서비스(Application Service): 유스케이스를 조율하고 트랜잭션을 관리한다.
- 아웃풋 어댑터(output Adapter): 도메인 모델, 영속성 관리(persistence management)나 메시지 발송기(message senders)가 이에 속한다.

등등.. 더 알고 싶다면 도메인주도 설계 구현(DDD) 4장을 참고하자.

<br>

기술은 전반에 걸쳐 산재해 있지만, 도메인 모델은 기술로부터 최대한 자유로워야한다.

- 트랜잭션은 애플리케이션 서비스에 의해 관리되는 것이지, 도메인 모델에 의해 관리되는 것이 아니다.

<br>

필요하다면 다른 아키텍처나 아키텍처 패턴도 목적에 따라 조합하여 사용할 수 있다.

- 이벤트 주도 아키텍처: 이벤트 소싱(IDDD)
- 커맨드-쿼리 책임 분리(CQRS; Command Query Responsibility Segregation)(IDDD)
- 반응 및 액터 모델: DDD와 함께 액터 모델에서 사용하는 액터모델(Reactive) 에서 반응 메시징 패턴을 참고하자.
- REST(Respresentational State Transfer)(iDDD)
- 서비스 지향 아키텍처(SOA)(IDDD)
