# **ch.6.도메인이벤트와 전술적 설계**

![6.topic](/img/6.topic.png)

도메인 이벤트가 전략적 설계를 위해 매우 중요한 도구이다.

- 도메인 이벤트를 사용함으로써, 분산된 시스템의 동일한 요청 내에 존재하는 모든 의존적인 노드들에게 보여지는 경우, 의존관계 일관성을 보여준다.
- 특정한 오퍼레이션이 다른 애그리게잇에서 명확하게 발생하기 전에는 한 애그리게잇이 생성되거나 수정될 수 없다.
- 이벤트에 관심이 있는 이벤트 리스너들에게 관련 상황을 알리는데 매우 유용하다.

<br>

<br><hr><hr>

## **도메인 이벤트를 설계, 구현, 사용하기**

```C#
public interface DomainEvent
{
    public Date OccurredOn
    {
        get;
    }
}
```

이 C# 코드는 모든 도메인 이벤트가 반드시 지원해야하는 최소한의 인터페이스를 말한다.

- 일반적으로 도메인이벤트가 발생할 때, 그 날짜와 시각을 전달한다.(이를 위해 OccurredOn 프로퍼티를 제공한다.)

<br>

도메인 이벤트에 이름은 세심한 주의가 필요하다.

- 사용되는 단어들은 도메인 모델의 보편언어를 반영한다.
- 이 단어들은 도메인 모델안에서 발생하는 사건과 밖을 이어주는 다리 역할을 한다.
- 이런 다리들은 이벤트를 통해 모델들이 원활히 의사소통하는데 필수적이다.

<br>

![domainEventExamples](/img/domainEventExamples.png)

도메인 이벤트 타입을 나타내는 이름은 과거에 발생한 것을 서술하는데, 이는 과거형 동사로 표현할 수 있다.

*ProductCreated: 어떤 과거 시점에 스크럼 제품이 생성됐음을 나타낸다.*

- 각 이름들은 핵심 도메인에서 발생한 사건을 명확하고 간결하게 서술한다.
- 도메인 모델에서 발생한 사건의 기록을 온전히 전달하기 위해선, 도메인 이름과 프로퍼티가 모두 필요하다.

<br>

![domainEvent_Command](/img/domainEvent_Command.png)

CreateProduct 명령은 다음과 같은 프로퍼티를 갖고 있다.

- tenantId: 구독 테넌트를 식별한다.
- productId: 생성되는 고유한 Product를 식별한다.
- Product name
- Product description

<br>

ProductCreated 도메인 이벤트는 이벤트가 만들어지는 시점에 명령이 제공하는 모든 프로퍼티들을 담고 있어야 한다.

- tenantId, productId, name, description 을 통해 모든 이벤트 구독자들에게 모델안에서 무슨일(Product가 생성됬다.)이 발생했는지 온전하고 정확하게 알릴 수 있다.
- 테넌트는 tenantId로, Product는 productId로 고유하게 식별한다.
- 도메인 이벤트가 풍부한 추가 데이터를 담을 수 있으나, 도메인 이벤트에 그 의미를 잃을 정도로 너무 많은 데이터를 담지 않도록 주의한다.

<br>

![aggregateWithDomainEvent](/img/aggregateWithDomainEvent.png)

수정된 애그리게잇과 도메인 이벤트가 같은 트랜잭션에서 함께 저장될 필요가 있음을 인지한다.

- 도메인 이벤트를 이벤트 리포지토리에 유지하는 것은 도메인 모델 간에 발생한 것에 대한 인과관계의 순서를 지속시켜준다.
- 객체-관계 매핑 도구를 사용한다면, 애그리게잇을 하나의 테이블에 그리고 도메인 이벤트를 리포지토리에 테이블에 저장하고 난 후, 트랜잭션을 설정할 수 있다.
- 이벤트 소싱(Event Sourcing)을 사용한다면, 애그리게잇의 상태는 도메인 이벤트 자체로 온전히 표현할 수 있다.

<br>

![savedAndPublishedDomainEvent](/img/savedAndPublishedDomainEvent.png)

도메인 이벤트가 이벤트 리포지토리에 한 번 저장되면, 이벤트에 관심있는 어떤 대상에게든지 전달 될 수 있다.

- 도메인 이벤트는 도메인에 주목할 만한 무언가가 발생했다는 것을 다른 모두에게 알리는 방법이다.
- 도메인 이벤트 자체는 인과관계를 나타내거나 시퀀스나 인과관계 식별자처럼 도메인 이벤트와 관계된 메타데이터 형태가 인과관계를 나타내기도 한다.

<br>

도메인 이벤트와 명령은 다르다는 것을 인지해야한다.

- 명령은 거부할 수 있지만, 도메인 이벤트는 실제로 발생하는 것이며 논리적으로 부정할 수 없다는 점에서 명령과 도메인 이벤트는 다르다.

<br>

<br><hr><hr>

## **이벤트 소싱**

![eventSourcing](/img/eventSourcing.png)

이벤트 소싱은 애그리게잇 인스턴스에 대해 변경된 것에 대한 기록으로, 발생했던 모든 도메인 이벤트를 저장하는 것을 말한다.

- 애그리게잇 상태 전체를 저장하는 대신, 발생했던 각 도메인 이벤트 모두를 저장한다.
- 하나의 애그리게잇 인스턴스에 발생했던 모든 도메인 이벤트를 발생한 순서대로 이벤트 스트림에 구성한다.

    *이벤트 스트림은 애그리게잇에 가장 처음 발생했던 도메인 이벤트로 시작해서 마지막 도메인 이벤트까지 계속된다.*

- 애그리게잇 인스턴스에 새로운 도메인 이벤트가 발생하면 이벤트 스트림의 마지막에 추가한다.

    *애그리게잇에 이벤트 스트림을 재적용하면 저장된 정보가 메모리로 환원된다. 이는 이벤트 소싱을 사용하면 어떤 사유로 인해 메모리에서 삭제됬던 애그리게잇들을 이벤트 스트림을 통해 온전히 환원 시킬 수 있음을 의미한다.*

- 이벤트 소싱을 사용하면 핵심도메인에서 계속 발생하는 모든 기록을 개별적인 발생 수준으로 저장할 수 있어, 비즈니스 및 기술적인 도움이 될 수 있다.

    *법적 기준에 대한 준수 및 분석 하거나, 개발자가 소스코드를 디버깅하거나 이벤트 사용 추세를 조사할 때 등등 도움이 될 수 있다.*

<br>

이벤트 레포지토리는 모든 도메인 이벤트를 추가하는 순차적인 리포지토리 컬렉션 또는 테이블을 말한다.

- 이벤트 스토어는 오직 추가만 가능하다.

    *이 특성으로 인해 리포지토리 매커니즘은 매우 빠르게 동작한다. 그래서 매우 높은 처리량, 낮은 대기 시간, 높은 확장성을 위해 이벤트 소싱을 사용하는 핵심도메인을 만들 수 있다.*

<br>

이벤트 소싱을 이야기하면 `CQRS(Command Query Responsibility Segregation)`을 생각하도록 하자.

<br>

> **CQRS(Command Query Responsibility Segregation)**

CQRS는 "Command and Query Responsibility Segregation"의 약어로, 명령(Command)과 조회(Query)의 책임을 분리하는 패턴을 말한다.

- CQRS 패턴은 데이터의 변경(Command)과 조회(Query)를 분리하여 각각의 역할을 전담하도록 구성한다.
- 읽기(Query)와 쓰기(Command)에 대한 모델이 달라지고, 쓰기 작업과 읽기 작업에 대해 최적화할 수 있다.
- 동일한 데이터 모델을 사용하지만 읽기와 쓰기 작업을 위한 서로 다른 모델을 사용하여 성능, 확장성, 유지보수 등을 개선할 수 있다.
- CQRS 패턴을 적용하면 데이터베이스의 스키마 설계, 비즈니스 로직의 구현, API의 디자인, 테스트 전략 등 여러 측면에서 영향을 받는다.

*더 자세한 내용은 도메인 주도 설계구현을 참고하자.*
