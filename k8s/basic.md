# K8S Basic
*쿠버네티스는 여러 머신을 위한 docker-compose와 유사하다.*

k8s는 자동 배포, 스케일링 조정 및 로드밸런싱, 관리를 한곳에서 할 수 있는 오픈 시스템이다.(컨테이너 조정 및 배포를 위한 시스템이다.)




<br><hr><hr><br>

## **구성요소**

<br>

<br>
    
![API 서버와 컨트롤러 매니저](/img/apiserverWithControllermanager.png)

<br>

*API 서버와 컨트롤러 매니저는 단순히 파드가 생성되는 것을 감시하는 것이 아니라 디플로이먼트처럼 레플리카 셋을 포함하는 오브젝트 생성을 감시한다.*

> ### **마스터 노드**
- **kubectl**
    
    쿠버네티스 클러스터에 명령을 내리는 역할을 한다. 다른 구성요소들과 다르게 바로 실행되는 명령 형태인 바이너리(binary)로 배포되기 때문에 마스터 노드에 있을 필요는 없다. 하지만 통상적으로 주로 API 서버와 통신하므로 API 서버가 위치한 마스터 노드에 구성하는 경우가 존재한다.

    <br>

- **API 서버**

    쿠버네티스 클러스터의 중심 역할을 하는 통로이다. 회사에 비유하자면 모든 직원과 상황을 관리하고 목표를 설정하는 관리자에 해당한다.


    <br>

- **etcd**(etc + distributed(퍼뜨렸다.))

    구성 요소들의 상태 값이 모두 저장되는 곳으로, 회사의 관리자가 모든 보고 내용을 기록하는 노트라고 생각하면 된다. 
    
    etcd의 정보만 백업되어 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스터를 복구 할 수 있다.

    또한 etcd는 분산 저장이 가능한 key-value 저장소 이므로, 복제해 여러 곳에 저장해두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있다.

    <br>

- **컨트롤러 매니저**

    쿠버네티스 클러스터의 오브젝트 상태를 관리한다.

    워커 노드에서 통신이 되지 앟는 경우, 상태 체크와 복구는 컨트롤러 매니저에 속한 노드 컨트롤러에서 이루어진다.

    레플리카셋 컨트롤러는 레플리카셋에 요청받은 파드 개수대로 파드를 생성한다. 

    <br>

- **스케줄러**

    노드의 상태와 자원, 레이블, 요구 조건등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당한다. 스케줄러라는 일므에 걸맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리하는 역할을 담당한다.

<br><hr><hr><br>

## **개념**

- ### **오브젝트(Object)**

    파드와 디플로이먼트를 개별 속성을 포함해 부르는 단위를 말한다. 

    기본 오브젝트에는 다음 네가지가 존재한다.

    1. **파드(Pod)**: 쿠버네티스에서 실행되는 최소 단위, 즉 웹 서비스를 구동하는데 필요한 최소 단위를 말한다. 독립적인 공간과 사용 가능한 IP 를 가지고 있다. 하나의 파드는 1개 이상의 컨테이너를 갖고 있기 때문에 여러 기능을 묶어 하나의 목적으로 사용할 수도 있다. 그러나 범용으로 사용할 때는 대부분 1개의 파드에 1개의 컨테이너를 적용한다.

        ![kubectl get po](/img/kubectl-get-po.png)

        - NAME: 파드의 오브젝트 명
        - READY: 가동 완료 수. 분자는 파드 내의 컨테이너가 가동된 수, 분모는 파드 내의 적의한 컨테이너의 총 수
        - STATUS: 파드의 상태. CrashLoopBackOff 는 컨터이너가 재시작을 반복하며 다음 재시작 전에 대기하고 있는 상태를 의미한다. 컨테이너를 가동할 때 리눅스의 프로세스 관리로 인해 CPU 부하가 많이 발생하기 때문에 계속된 반복에 의한 CPU 과부하를 막기 위해 일정 간격을 두고 재시작을 실행한다.
        - RESTARTS: 파드가 재시작된 횟수
        - AGE: 파드 오브젝트가 만들어진 후 경과 시간
    

    <br>

    2. **네임스페이스(Namespace)**: 쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹을 말한다. 특별히 지정하지 않으면 기본으로 할당되는 defaul, 쿠버네티스 시스템에서 사용되는 kube-system, 온프레미스에서 쿠버네티스를 사용할 경우 외부에서 쿠버네티스 클러스터 내부로 접속하게 도와주는 컨테이너들이 속해 있는 metallb-system이 존재한다.

    <br>

    3. **볼륨(Volume)**: 파드가 생성될 때 파드에서 사용할 수 있는 디렉터리를 제공한다. 기본적으로 파드는 영속되는 개념이 아니라 제공되는 디렉터리도 임시로 사용한다. 하지만 파드가 사라지더라도 저장과 보존이 가능한 디렉터리를 볼륨 오브젝트를 통해 생성하고 사용할 수 있다.

    <br>

    4. **서비스(Service)**: 파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정적일 수 없다. 따라서 파드 접속을 안정적으로 유지하도록 서비스를 통해 내/외부로 연결된다. 그래서 서비스는 새로 파드가 생성될 때 부여되는 새로운 IP를 기존에 제공하던 기능과 연결해 준다. 쉽게 말해, 쿠버네티스 외부에서 쿠버네티스 내부로 접속할 때 내부가 어떤 구조로 돼 있는지, 파드가 살았는지 죽었는지 신경쓰지 않아도 이를 논리적으로 연결하는 것이 서비스 이다. 기존인프라에서 게이트웨이와 비슷한 역할을 한다. 

    
    <br>
    
    ![기본오브젝트](/img/standardobject.png)

    <br>

- ### **디플로이먼트(Deployment)**

    기본 오브젝트만으로 쿠버네티스를 사용할 수 있다. 하지만 한계가 존재하여 이를 좀 더 효율적으로 구현한 것이 디플로이먼트(deployment)이다.

    쿠버네티스에서 **가장 많이 사용되는 오브젝트**이며, 디플로이먼트 오브젝트는 **파드에 기반**을 두고 있으며, **레플리카셋 오브젝트를 합쳐 놓은 형테**이다.

    <br>

    > **디플로이먼트 생성하고 삭제하기(1개의 파드 생성)**
    
    ![kubctl get deploy](/img/kubectl-get-deploy.png)

    ```shell
    # 디플로이먼트 생성
    kubectl create deployment {파드이름} --image={계정이름}/{이미지이름}

    # 생성된 디플로이먼트 확인
    kubectl get deploy
    - NAME: 디플로이먼트의 오브젝트 명
    - DESIRED: 희망 파드의 개수, 디플로이먼트를 만들 때 설정한 파드 수
    - CURRENT: 현재 실행 중인 파드의 개수
    - UP-TO-DATE: 최근에 업데이트 된 파드의 개수. 즉, 컨트롤러에 의해 조정된 파드 수
    - AVAILABLE: 사용 가ㅣ능한 파드 개수. 즉 정상적으로 가동되어 서비스 가능한 파드 수
    - AGE: 오브젝트가 만들어진 후 경과 시간

    # 디플로이먼트 삭제
    kubectl delete deployment {파드이름}
    ```

    <br>

    > **레플리카셋으로 파드 수 관리하기**

    *다수의 파드를 만들 때, 레플리카셋 오브젝트를 사용하여 효율적으로 파드를 생성한다.*

    `create` 에서는 relpicas 옵션을 사용할 수 없으며, `scale` 은 이미 만들어진 디플로이먼트에서만 사용할 수 있다.
    ```shell
    # 배포된 파드의 상태를 확인한다.
    kubectl get pods

    # scale 명령을 통해 파드 수를 증가시킨다. --replicas=3 는 파드의 수를 3개로 맞춘다는 것을 의미한다.
    # 파드의 수를 늘릴 오브젝트를 명시하지 않으면, 리소스를 확인할 수 없다는 에러가 발생한다.
    # Error from server (NotFound): the server could not find the requesetd resource
    kubectl scale pod deployment {파드이름} --replicas=3

    # scale 명령을 통해 생성된 파드를 확인하면 생성시간(AGE)이 짧은 것을 확인 할 수 있다.
    kubectl get pods

    # 생성된 파드 및 이전의 파드 모두 정상적으로 워커 노드에 적용되고 IP가 부여됬는지 확인한다.
    kubectl get pods -o wide

    # 오브젝트(현재 디플로이먼트)에 속한 모든 파드 삭제하기
    kubectl delete {파드이름}
    ```

    <br>

    >**스펙을 지정해 오브젝트 생성하기(다수의 파드 생성)**

    디플로이 먼트를 생성하면서 한번에 다수의 파드를 생성하기 위해 오브젝트 스펙(spec)을 작성한다.
    스펙은 YMAL 문법으로 작성한다.

    ![파일구조](/img/filestructure.png)

    ```ymal
    # API 버전
    # apps/v1 은 여러종류의 kind(오브젝트)를 가지고 있다.
    apiVersion: apps/v1

    # 오브젝트 종류 
    kind: Deployment 
    metadata:
    name: {디플로이먼트의이름}
    labels:
        app: {디플로이먼트의레이블}

    spec:
    # 몇개의 파드를 생성할지 결정
    replicas: {생성할파드의갯수} 

    selector:
        matchLabels:
        app: {셀렉터의레이블}

    template:
        metadata:
        labels:
            app: {템플릿의레이블}

        # 템플릿에서 사용할 컨테이너 이미지 지정
        spec:
        containers:
        - name: {컨테이너이름}}
            image: {계정이름}/{이미지이름}
    ```
    apiVersion은 오브젝트를 포함하는 API의 버전을 의미한다. 
    일반적으로 알파(alpha)와 베타(beta)버전은 안정적이라 보지않지만 그 만큼 풍부한 기능을 갖고 있다.

    <br>

    *사용가능한 API 버전 확인하기: kubectl api-versions*

    <br>

    > **apply 로 오브젝트를 생성하고 관리하기**

    run 을 통해 파드를 간단하게 생성할 수 있지만, run 은 단일파드만 생성이 가능하다.
    
    create는 디플로이먼트를 생성하면 변경사항(파일에서 수정)을 바로 적용할 수 없다. 이fjs결우 apply를 통해 오브젝트를 관리하면 편리하다.

    ```shell
    kubectl apply -f 파일경로/파일이름.yaml
    ```

    ```shell
    |    구분    |  run  | create | apply |
    +-----------+-------+--------+-------+
    | 명령 실행   | 제한적  | 가능함   | 안 됨  |
    +-----------+-------+---------+------+
    | 파일 실행   | 안 됨  |  가능함   | 가능함 |
    +-----------+-------+---------+------+
    | 변경 가능   | 안 됨  |  안 됨   | 가능함 |
    +-----------+-------+---------+------+
    | 실행 편의성  |매우 좋음| 매우좋음  | 좋음  | 
    +-----------+-------+---------+------+ 
    | 기능유지    | 제한적임| 지원됨    | 다양하게 지원됨
    +-----------+-------+---------+------+
    ```

<br>

- ### **데몬셋(DaemonSet)**

<br>

- ### **컨피그맵(ConfigMap)**

<br>

- ### **레플리카셋(ReplicaSet)**

<br>

- ### **PV(Persistent Volume)**

<br>

- ### **PVC(PersistentVolumeClaim)**

<br>

- ### **스테이트풀셋(StatefulSet)**

<br>

- 등등..

<br><hr><hr><br>

## **파드의 컨테이너 자동 복구**

*쿠버네티스의 거의 모든 부분은 자동 복구 되도록 설계되어 있다.*

파드의 자동 복구 기술은 셀프힐링(Self-Healing) 이라고 하는데, 제대로 작동하지 않는 컨테이너를 다시 시작하거나 교체해 파드가 정상적으로 작동하게 하는 것을 말한다.

- 동작을 보증한다.
- 명령한 replicas의 수를 보증한다.(삭제할 경우 선언한 개수를 맞춘다., 이는 AGE를 통해 확인할 수 있다.)