## **DDD(Domain Driven Development)**
도메인 로직과 인프라를 분리하면 소프트웨어를 보다 쉽게 설계, 개발, 테스트, 구축할 수 있다.

도메인 논리를 안정적으로 유지하고 인프라 구성 요소를 변경하고 적응하는데 도움이 된다.

<br><hr>

## **디자인 영역**

디자인을 하는 영역에는 전략적 측면과 전술적 측면이 존재한다.

> **전략적 도메인 주도 설계**

도메인 모델의 경계에 초점을 두고 경계 컨텍스트를 도입한다.

- 도메인 자체는 음식 주문 애플리케이션과 같은 시스템의 운영 영역이며, 해당 도메인 내에서 잘 정의된 경계가 존재해야한다.
- 이러한 경계는 경계 컨텍스트를 사용하여 정의 된다.(이는 시스템의 기능을 그룹화 하는데 도움이 된다.)
- 도메인은 도메인 논리에 따라 하나 이상의 하위 도메인을 가질 수 있다.

<br>

*`Ubiquitous Language`*: 기본적으로 도메인 전문가와 개발자 간의 공통 언어를 정의하여 시스템이 도메인의 기여로 의사소통이 잘되는 환경에서 설계, 개발 및 진화하는데 도움을 준다.

<br>

> **전술적 영역 주도 설계**

세부 사항의 구현에 중점을 둔다.

- **`Entities(엔터티)`**
    
     핵심 도메인 개체로 중요한 비즈니스 논리를 가지고 있으며, 엔티티는 고유해야한다.

     생성될 때, 엔티티의 수명동안 변경되지 않은 상태로 유지 된다.

     다른 모든 속성이 동일하더라도 동일한 식별자를 가진 두개의 엔터티가 동일한 개체로 간주된다.

     마찬가지로, 식별자가 다르면 두 엔터티가 다른 것으로 간주된다.

     인터티 개체는 일부 비즈니스 논리를 실행하고 기반으로 속성을 업데이트 하므로 변경 가능한 개체이다.

     그러나 언터티의 모든 속성에 대해 setter 메서드를 만들어야 한다는 의미는 아니다.(올바른 동사를 사용하여 잘 정의된 이름을 가진 상태 변경 메서드가 있어야 한다.)

    <br>

- **`Aggregates(집계)`**

    논리적으로 관련된 엔터티 개체 그룹을 말한다.
    예를들어 주문을 포함하는 주문 프로세스 집계를 말한 수 있다.

    집계의 중요한 점은 집계가 일관된 방식으로 전체적으로 검색되고 저장되아야 한다는 것이다.

    <br>

- **`Aggregate Root(AR)`**

    집계 루트는 집계를 일관된 상태로 유지하는 책임이 존재한다.
    따라서 집계는 집계 루트가 소유하고 루트의 식별자도 집계를 식별한다.

    집게 루트는 비즈니스 불변성을 적용하는 책임이 있다.

    집계를 일관된 상태로 유지하는 것은 외부로 부터 집계를 동해서만 집계를 참조할 수 있다는 것이다.

    즉, 모든 상태 변경 작업은 루트 엔터티를 거쳐야 한다.
    (집계 경로 이외의 엔터티는 외부 개체에서 참조할 수 없다.)
    
    집계에 대한 모든 상태 변경 작업을 완료하면 데이터를 저장하기 전에 집계를 일관된 상태로 유지하기 위해 매번 엄격한 유효성 검사를 시행해야한다.

    또한 데이터 저장소 제약조건을 적용하고 낙관적으로 보는 것은 여러 위협에 의해 업데이트가 충돌하는 경우에 데이터 손실 또는 손상을 방지할 수 있다.

    다른 집계에서 엔티티가 독립적으로 수정되고 외부에서 식별자에 의해 액세스 되는경우, 어떤 엔터티가 종합 경로가 될 것인지 결정하려면 고려해야한다.
    
    (이 경우 해당 엔터티를 집계의 루트로 선택한다.) 
    
    <br>

- Value Object(값 개체)

    값 개체는 값에 컨텍스트를 가져오는데 사용된다. 
    예를 들어 엔터티의 식별자를 유지하려면 UUID 필드가 있는 것이 좋다.
    그러나 UUID 필드는 도메인에 대해 아무것도 알려주지 않는다.

    개발자 혹은 도메인 전문가로서 도메인 개체를 볼 때, 어떤 필드가 어떤 목적으로 사용되는지 명확해야 한다.

    이렇게 할 경우 가치에 맥락을 부여할 수 있으며, 비즈니스 운영을 가능하게 해준다. 뿐만아니라 필요한 경우 메서드가 있는 값 객체를 통해 생성자에서 값 개체를 만드는 동안 개체의 값을 확인할 수 있다.

    값 개체의 중요한 기능 중 하나는 변경할 수 없다는 것이다.(한번 생성함녀 값을 변경할 수 없다.)
    값을 변경하려면 업데이트된 값으로 새 값 개체를 생성하기만 하면 된다.(이 불변성 덕분에 값 개체는 서로 교환 할 수 있으며, 같은 목적을 위해 값을 같은 값을 가진 두 개의 다른 값 개체를 사용할 수 있음을 의미한다.)

    <br>

- Domain Events(도메인 이벤트)

    도메인 이벤트는 서로 다른 경계 컨텍스트에 있는 도메인을 분리하는 훌륭한 도구이다.
    이벤트에 의존하는 모든 시스템에서와 마찬가지로 도메인 이벤트는 궁극적으로 일관된 시스템으로 이어진다.
    그런 다음 집계 규칙을 통해 도메인에서 일부 비즈니스 논리를 실행한다.
    변경 사할을 저장한 후 일부 이벤트를 실행하여 다른 컨텍스트에 알릴 수 있다.

    같은 방법으로 다른 도메인의 이벤트를 기반으로 비즈니스 로직을 실행하려는 경우 도메인 이벤트를 생성할 수 있다. 리스너를 만들고 해당 도메인의 이벤트를 구독한다.

    이벤트를 배포하고 소비하는 동안 중요한 것은  재시도 작업이 있는 시스템을 갖는 것이다. 이를 달성하기 위해 메시지 큐 또는 이벤트 로그는 도메인 이벤트 구현에 매우 적합한 방법이다. 
    이를 이벤트 소싱이라 하며 시스템 상태를 이벤트의 정렬된 로그로 유지한다.

    하지만 이벤트 소스를 시스템의 유일한 지속성 모델로 사용하지 않는다.
    도메인 이벤트 게시자가 생성한 이벤트를 유지하는 데만 사용된다.
    그리고 나중에 이러한 이벤트는 도메인 이벤트 리스너에서 필요한 비즈니스를 실행하는데 사용된다.

    *kafka 를 사용하면 이벤트 로그 저장소로 사용하고 이벤트 기록을 볼 수도 있다.*

    <br>

- Domain Services(도메인 서비스)

    도메인 서비스는 여러 집계에 걸쳐 있는 비즈니스 논리를 조정한다.
    또한 메서드가 논리적으로 맞지 않으면 비즈니스 로직 메서드를 도메인 서비스에 엔터티로 넣을 수 있다.

    도메인 서비스는 필요한 경우 다른 도메인 서비스와도 통신할 수 있다.
    
    도메인 서비스는 여전히 도메인 논리의 핵심이므로 외부에서 연결할 수 없다.
    그리고 도메인 로직에서 외부와 통신하기 위해 애플리케이션 서비스로 오고 있다.

    필요한 도메인 메서드를 외부에 노출시키는 서비스이다.
    따라서 외부 개체가 필요로 하는 메서드와 인터페이스가 있어야 하고 해당 인터페이스를 노출해야한다.
    그런다음 이 애플리케이션 서비스를 구현하고 요청을 수락해야 한다.

    애플리케이션 서비스는 트랜잭션을 생성 및 관리하고 보안 요구 사항을 적용하는 장소여야 한다.
    이는 리포지토리를 사용하여 데이터 저장소에 도메인 상태를 로드하고 저장한다.
    따라서 일부 비즈니스 로직을 실행하려면 데이터가 필요하다.
    그러나 도메인 서비스나 엔터티는 이 데이터를 로드하거나 변경한 후 데이터를 저장하지 않는다.
    데이터를 가져와 도메인 서비스로 전달하는 것은 애플리케이션 서비스의 책임이다.

    한가지 중요한 것은 애플리케이션 서비스에 비즈니스 로직이 없어야 한다는 것이다.
    (이는 도메인 서비스 및 엔터티의 책임이기 때문이다.)

    도메인 이벤트와 관련하여 도메인 이벤트 리스너는 특별한 종류의 애플리케이션으로 생각할 수 있다.
    유일한 차이점은 도메인 이벤트 리스너는 최종 사용자가 트리거 하는 것이 아니라 도메인 이벤트에 의해 트리거 된다.
    따라서 도메인 이벤트 리스너는 도메인 이벤트가 수신된 첫 번째 접점이 될 것이며, 내부적으로 구성할 이벤트 처리를 위해 관련 도메인 서비스를 구성하고 호출한다.(비즈니스 로직을 실행하기 위해 엔터티를 호출한다.)

