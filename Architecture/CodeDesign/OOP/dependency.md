# Dependency 의존성 관리
객체지향 프로그래밍에서 `의존성`이란, 한 클래스가 다른 클래스의 기능을 사용하거나 필요로 할 때 발생하는 관계를 의미한다.

의존성 관리는 케이크의 층을 쌓는 것과 같다. 잘못하면 케이크가 무너진다.
- 클래스가 모든 작업을 혼자 처리하는 대신 다른 클래스에 의존하는 것이 좋다.
- 한편으로는 클래스가 작업의 일부를 다른 클래스에 위임하려면 다른 클래스가 작업을 제대로 수행할 것이라고 신뢰해야 한다.
- 클래스가 무작위로 다른 클래스에 의존하게 만들어서는 안된다.
  - 특정 클래스에 발생한 버그가 손대지 않은 클래스 코드에 문제가 생길 수 있다.
  - 의존성을 관리하지 못하면 통제력을 잃어버리기 쉽다.

객체지향 프로그래밍에서 적절한 의존성 관리는 시스템의 유지보수성과 확장성을 결정하는 핵심 요소이다.
따라서 객체지향 프로그래밍을 하기 위해서는 `의존성`을 관리하는 방법을 알아야 하며, 항상 `의존성`을 체계적으로 관리할 수 있어야 한다.
- 클래스가 적절한 의존성을 가진다면, 코드의 재사용성과 모듈화가 향상되어 유지보수가 쉬워진다.
- 클래스가 잘 관리된 의존성을 가진다면, 변경에 유연하게 대응할 수 있고, 테스트하기 쉬운 소프트웨어를 만들 수 있다.

> **결합도(Coupling)**
> - 한 클래스가 다른 클래스에 얼마나 의존하는지를 나타내는 개념
> - 낮은 결합도는 클래스 간의 독립성을 의미하며, 높은 결합도는 강한 의존성을 의미한다.

> **응집도(Cohesion)**
> - 한 클래스 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는 개념
> - 높은 응집도는 클래스가 단일 책임을 가진다는 것을 의미한다.


## 의존성을 효과적으로 관리하는 방법

### 1. 고수준 코드와 저수준 코드를 분리한다.
고수준 동작을 수행하는 코드와 저수준 구현 코드를 분리하면 변경의 영향을 최소화 할 수 있다.
- 고수준 코드가 주로 다른 고수준 코드에 의존하도록 디자인하면 저수준 세부 사항의 변경이 미치는 영향을 줄일 수 있다.
- 고수준 코드를 분리하면 더 모듈화된 적응력 좋은 시스템을 만들 수 있으며, 유지보수성을 증진시킬 수 있다.

> **코드를 바라보는 관점: 저수준, 고수준**
> - 고수준 관점: 기능이 `무엇을` 해야하는지를 기술한다.(추상적)
> - 저수준 관점: 작업을 `어떻게` 수행할지를 기술한다.
> - 고수준과 저수준의 관심사를 분리하는 것이 불필요한 추상화를 만드는 것보다 중요하다.

**1.1 안정적인 코드를 디자인 한다.**

인터페이스는 구성요소가 외부 세계에 제공하는 것을 고수준에서 정의하기 때문에, 시간이 지나도 안정적인 코드 단위의 좋은 예시가 된다.
- 인터페이스는 내부 구현의 세부 사항에는 신경쓰지 않는다.
- 인터페이스를 디자인 할 때는 안정성과 정보 은닉을 염두해야 한다.

**1.2 인터페이스**

고수준 인터페이스를 먼저 코딩하면 클래스의 계약이 어떻게 생겨야 하는지와 어떤 기능을 클라이언트에게 제공해야 하는지에 대해 탐색할 수 있다.
- 필요하지 않은 정보를 요구하지 않고 불필요한 메서드를 포함하지 않는 수준까지 인터페이스를 명확하게 유지하도록 보장한다.
- 고수준 기능을 먼저 코딩하고 세부 구현을 나중에 처리하여 생산성을 높일 수 있다.(작업이 막히는 것을 방지할 수 있다.)
- 고수준 코드와 저수준 코드를 명확히 분리할 수 있다.

**1.3 고수준 코드와 저수준 코드를 분리하지 않아도 되는 경우**

모든 기능을 고수준 코드와 저수준 코드로 분리할 필요는 없다.
- 모든 기능이 복잡하지는 않다.
- 복잡성이 증가한다면 그 때 코드를 리팩터링 하는 것이 좋다.

하지만 기능의 복잡성과 관계없이, 인프라 코드와 비즈니스 코드는 절대 섞지 말아야 한다.
- 비즈니스 로직과 SQL쿼리, 웹서비스에서 정보를 가져오는 HTTP 등의 코드와 섞이지 않도록 해야 한다.
- 비즈니스 코드와 인프라 코드를 분리하기 위해, 항상 '무엇'을 설명하는 고수준 인터페이스를 두고, 구현 세부사항을 저수준 클래스에 넣어야 한다.

### 2. 불필요한 세부 사항이나 요소에 의존하는 것을 피하라

다른 요소의 구현 세부 사항에 대한 의존성을 최소화하여 내부 변경의 영향을 줄여야 한다. 구성 요소가 작업을 수행하는 방식에 대해 덜 알수록, 그 구현이 변경될 때 영향도 덜 받는다.
- 클래스 내부의 세부 사항을 숨기는 것은 다른 소프트웨어 구성 요소에 신경 쓰지 않고 소프트 웨어 구성 요소를 독립적으로 발전시키는데 매우 중요하다.
- 무엇을 노출하고 무엇을 감출지 결정해야 하고, 노출하는 세부 사항을 변경하면 클라이언트에게 얼마나 영향을 미칠지 고민해야 한다.

**2.1 소유한 클래스만 요구하거나 반환한다.**

클래스나 인터페이스를 디자인 할 때, 프레임워크나 서드파티 라이브러리의 클래스가 아니라 자신이 소유한 클래스만 요구하거나 반환하는 것이 중요하다.
- 자신이 소유한 클래스: 완전한 통제와 소유권을 가진 클래스 (ex. 도메인 클래스, 엔터티, 리포지터리, 데이터 구조 등)
- 자신이 소유한 클래스만 반환하여, 코드가 특정 라이브러리나 구조 등 외부 의존성과 결합되는 것을 방지한다.
- 결합을 완전히 피할 수는 없지만, 코드가 어떤 것에 결합될지 통제해야한다.
- 결합이 얼마나 나쁜 것인지 개발자는 판단할 수 있어야 한다.

**2.2 클라이언트에게 필요한 것 이상을 제공하지 않는다.**

클라이언트에게 필요한 것만 제공하지 않고 엔터티 전체를 제공하면 다음과 같은 단점이 존재한다.
- 엔터티의 모든 변경 사항이 클라이언트에게 전파된다.
- 보안 문제가 발생할 수 있다.
- 변경이 발생할 경우, 변경으로 인한 영향을 분석하고 엔터티 변경이 클라이언트에게 영향을 미칠지 개발자가 판단해야한다.(판단이 어려움)

클라이언트에게 필요한 것만 제공하는 방법은 다음과 같다.
- 클라이언트가 요청한 것과 엔터티를 분리한다.
- 클라이언트의 필요를 표현하는 더 구체적인 데이터 구조를 생성한다.(정보를 추상화한다.)

### 3. 너무 많은 클래스에 의존하지 않는다.

너무 많은 의존성을 가지는 클래스를 분리하면 잠재적인 변경의 범위를 제한할 수 있다.
- 코드 유지보수성과 유연성을 향상 시킨다.
- 변경되는 시스템 요구 사항에 시스템이 더 잘 적응할 수 있게 만든다.

> **새로운 기능이 추가될 때 선택 할 수 있는 방법**
> 1. 현재 코드 단위를 확장한다.
> - 의존성이 증가하진 않지만, 복잡성이 증가한다.
> 2. 새로운 클래스를 생성하여 기존 클래스와 연결한다.
> - 기능의 복잡성을 증가시키지는 않지만, 결합도가 증가한다. 