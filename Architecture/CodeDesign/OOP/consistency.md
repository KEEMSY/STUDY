# Consistency 일관성
객체지향 프로그래밍에서 `일관성`이란, 객체가 정확하고 신뢰할 수 있는 정보를 가지고 있음을 나타낼 때 사용된다.
- `무결성`(integrity): 데이터 베이스와 같은 다른 컴퓨터 과학분야에서 사용되며, 정보를 정확하게 유지하는 것을 의미한다.
  - 데이터베이스에서의 일관성은 데이터의 `가용성`과 관련이 있다.


객체지향 프로그래밍의 가장 중요한 장점은 객체가 항상 일관된 상태를 유지하도록 보장한다는 것이다.
따라서 객체지향 프로그래밍을 하기 위해서는 `일관성`을 유지하는 방법을 알아야 하며, 항상 `일관성`을 유지해야 할 수 있어야 한다.
- 객체가 `일관성`을 유지한다면, 객체의 내부상태가 프로그램 요구사항이나 사용자 기대에 잘 맞춰 조화를 이룰 수 있게 된다.
- 객체가 `일관성`을 유지한다면, 객체가 올바르게 동작하며 정확한 결과를 제공하므로 고장이 적고, 신뢰할 수 있는 소프트 웨어를 만들 수 있다.

> 캡슐화(encapsulation)
> - 데이터를 객체 안에 저장하고 연산을 통해서만 이를 조작할 수 있게 하는 개념
> - 캡슐화를 통해 코드 기반의 다른 부분에 영향을 주지 않고 클래스 내부의 세부 사항을 변경할 수 있다.


## 요약
- 버그를 방지하고 코딩에 드는 노력을 줄이고 원활한 유지보스를 보장하려면 객체 일관성이 매우 중요하다. 
- 모든 메서드가 유효하지 않은 병경을하지 못하도록 보장함으로써 클래스 내부의 일관성을 유지해야 한다.
- 복잡한 비즈니스 연산에는 외부 검증이 필요할 수 있다. 이를 일관성을 보장하는 서비스를 통해 처리하거나 중심 엔터티와 함께 동작하는 전용 검증 클래스를 통해 처리해야 한다.
- 무작정 게터와 세터를 만들지 말고, 각각의 필요성을 신중히 검토해야 한다.
- 복잡한 엔터티에 대해 애그리게이트 루트를 디자인해서 전체 객체 그래프의 일관성을 보장하고 클라이언트가 애그리게이트 내부 상태를 변경하지 못하게 막아야 한다.
---

## 캡슐화를 유지하는 방법
> 1. 항상 일관성을 유지한다.
> 2. 효과적인 데이터 유효성 검사 메커니즘을 디자인한다.
> 3. 상태 확인을 캡슐화 한다.
> 4. 필요한 게터와 세터만 제공한다.
> 5. 객체 집단의 불변 조건을 보장하도록 애그리게이트를 모델링한다.

### 1. 항상 일관성을 유지한다.
**1.1 클래스가 스스로 일관성을 책임지게 한다.**

어떤 클래스가 데이터 일고나성을 책임져야 할지 확신이 서지 않을 때에는 데이터를 포함하는 클래스가 일관성을 보장하도록 만드는 것이 좋다.
- 클래스는 항상 상태를 일관성 있게 유지해야할 책임이 있다.

**1.2 전체 작업과 복잡한 일관성 검사를 캡슐화 한다.**

객체 내부에 있는 정보만으로는 일관성 검사가 불가능하거나 너무 복잡해서 클래스 밖에 구현해야할 수도 있다. 이런 경우, 일관성 검사와 비즈니스 로직을 별도의 클래스로 캡슐화 하는 것이 필요하다.
- 이 역할을 하는 것이 서비스 클래스 이다.
  - 서비스 클래스는엔터티가 스스로 제공할 수 없는 일관성을 보장한다.

클라이언트는 절대 일관성 검사를 책임지지 않아야하며, 기본적으로 클래스가 일관성을 검사해야 한다.

> **도메인 클래스**
>
>도메인 클래스는 가능한 순수한 상태를 유지해야 하며, 데이터와 그 데이터를 조작하는 메서드만 포함하는 것이 낫다.


### 2. 효과적인 데이터 유효성 검사 메커니즘을 디자인한다.

클라이언트의 데이터 유효성 검사는 예상치 못한 오류를 방지하고 시스템의 이상 동작 위험을 줄인다. 이를통해 시스템이 문제를 보다 잘 처리하고 의사소통 할 수 있게 보장할 수 있다.
- 잘못된 데이터가 야기할 결과를 명확히 정의한다.
- 코드의 신뢰성과 사용자 경험을 증진 시킬 수 있다.

**2.1 사전 조건을 명시적으로 정의한다.**

능동적으로 메서드의 사전 조건과 사후 조건을 명시적으로 정의하고 문서화 해야 클래스가 의도대로 쓰일 가능성을 높이고 일관되지 않은 프로그램 실행을 줄일 수 있다.
- 사전조건: 각 입력이 어떤 값일 때 유효한지를 명확히 정의하는 것을 말한다.
  - 클라이언트가 메서드의 사전 조건을 만족시키지 않을 때 어떤 일을 해야 할지 결정하는 것은 개발자의 책임이다.
  - 코드의 사전 조건을 단순화하면 클라이언트가 처리해야 할 드물게 발생할 수 있는 예외 케이스도 줄어들기 때문에 클라이언트도 더 편해지게 된다.

> 잘못된 데이터의 처리할 방법을 모를 때, 프로그램을 계속 실행하는 것보다는 중단시키는 편이 더 낫다.

> 서비스 클래스: 흐름을 제어하고, 유혀성 검증과 일관성 검사를 동작 전에 실행하도록 보장하는 클래스
> - 어떤 동작을 수행하기 전에 검증 규칙을 호출해야한다는 사실을 알 필요가 없도록 만들 수 있다.
> - 복잡한 비즈니스 동작에 대해 서비스 클래스를 사용하여 조정하는 것은 합리적인 타협안이 될 수 있다.
> - 엔터티는 여전지 자신이 할 수 있는 모든 일관성 검사를 수행해야 한다.

**2.2 유효성 검증 컴포넌트를 만든다.**

검증 컴포넌트는 일관성을 유지하는데 도움이된다.
- 클라이언트가 검증 메서드를 호출할 때 재사용성과 명확성을 높일 수 있다.
- 검증 규칙은 특정 기능이나 서비스에 특화되어 있으므로, 검증 클래스를 과도하게 디자인하는 것은 경계해야 한다.
유연한 검증 규칙을 구축하는 방법으로 명세 패턴(specification Pattern)을 고려할 수 있다.

> 검증 규칙: 비즈니스와 밀접하게 관련이 있는 조건
> - 예시: 직원은 같은 교육 과정을 세 번 이상 수강할 수 없다 등

**2.3 null 사용은 신중하게 하고 피할 수 있다면 피한다.**

null은 예기치 않은 null포인터 예외를 유발하며, null 검사를 과도하게 하면 가독성이 나빠질 수 있다.
- 메서드의 실행 경로 중 아무것도 반환하지 않아야 하는 경우, '값 없음'을 나타내는 객체를 생성하여 반환하는것이 좋다.
- null을 사용하지 않도록 모델링 할 수 없다면, 예상치 못한 놀라움을 피하는 것이 최선이다. 

### 3. 상태 확인을 캡슐화 한다.
복잡도와 관계없이 상태 확인을 캡슐화 한다면, 클라이언트가 클래스의 내부 세부 정보를 알지 못하게 할 수 있고, 클래스 내부의 구현이 변경되어도 클라이언트에 영향을 주지 않을 수 있다.
- 아주 단순한 상태 검사까지 캡슐화하면 시간을 절약하고 유연성을 제공할 수 있다.
- 클라이언트가 클래스의 내부 작동을 이해할 필요를 없앰으로써, 클래스가 내부를 자유롭게 수정할 수 있게 된다


**3.1 질문이 아니라 명령하라**

클라이언트들이 객체에게 정보를 물어보고 그 정보에 대해 수행해야 할 일을 결정해야 한다면 개선할 여지가 있다.
- 객체에게 데이터를 요청하고 이를 처리하기보다는 객체에 무엇을 해야 할지 명령해야 한다.

### 4. 필요한 게터와 세터만 제공한다.
클래스가 속성을 자유롭게 수정할 수 있다면 일관성을 보장할 수 없고, 클래스가 모든 속성에 접근할 수 있다 이후 클래스의 진화(고도화)가 해당 클래스와 결합된 모든 속성에 대하여 클라이언트에게 장애가 일어나지 않을 것임을 보장할 수 없다.
- 클래스의 공개 인터페이스를 클라이언트에게 필요하고 중요한 내용으로 제한함으로써 코드의 명확성과 유지보수성을 높일 수 있다.

**4.1 게터는 상태를 변경하지 않고 클라이언트에게 너무 많은 정보를 노출하지 않는다.**

메서드는 명령(시스템의 상태를 변경하는 작업을 수행)이나 쿼리(호출자에게 데이터를 반환) 중 하나여야 하며, 두가지를 동시에 해서는 안된다.
- 어떤 속성에 게터를 제공할지 신중히 생각해야 한다.
- 리스트를 반환하는 게터를 제공해야 하는 경우, 불변 컬렉션을 반환한다.

**4.2 세터는 객체를 설명하는 속성에만 사용한다.**

부주의한 세터의 사용은 일관성 없는 객체를 초래할 수 있다.
- 일관성 검사가 필요한 속성에는 세터를 제공하지 않는다.
- 설명적 속성에 대한 세터는 미래에 문제를 일으킬 가능성이 적다.
- 하지만 다른 필드에 대해 변경을  허용하면 일관성이 깨질 수 있는지 생각해야 한다.

### 5. 객체 집단의 불변 조건을 보장하도록 애그리게이트를 모델링 한다.
객체 군집을 포함하는 엔터티의 일관성을 보장하기 위해 애그리게이트를 디자인 해야 한다.
- 애그리게이트를 생성하면 코드를 쉽게 이해할 수 있어, 코드의 명확성과 유지 보수성이 증가하게 된다.

> 애그리게이트(루트)
> - DDD 에서 애그리게이트 루트(aggregate root)는 단일 객체로 간주되는 객체들의 집단을 의미한다.
> - 메인 객체 또는 루트는 전체 객체 트리의 일관성르 보장한다.
> - 클리아인터는 루트 객체에만 접근하고, 그 내부 객체에 직접 접근하거나 내부 객체의 연산을 호출할 수 없다.
> - 모든 클라이언트는 애그리게이트에 대한 참조만 유지해야한다.

<br>

**5.1 애그리게이트 루트의 규칙을 깨지 않는다.**

애그리게이트 루트를건너 뛰고, 하위 객체 중 하나를 직접 조작하는 것을 지양해야 한다.
- 일관성과 유지보수성을 다른 이점과 바꿀 정도의 이점이 있는지 다시 한번 고민이 필요하다.

> 애그리게이트 규칙을 깨고 싶을 경울 확인할 체크리스트
> - 애그리게이트 규칙을 깨는 경우의 이점이 유지보수 비용을 낮추고 불변성을 항상 최신 상태로 유지하는 경우의 이점보다 훨씬 큰가?
> - 애그리게이트 루트를 거치지 않고 애그리게이트의 일부를 직접 변경하고 싶다면, 해당 객체가 정말 애그리게이트의 일부분이어야 한다고 확신하는가?(유지해야 할 진정한 불변 규칙이 없다면, 애그리게이트를 더 작은 부분으로 나눠야 한다.)
> - 유지햐야 할 불변 규칙이 있는 경우, 여전지 애그리게이트 루트를 깨고 두 애그리게이트의 최종 일관성(Eventual Consistency)를 받아들여야ㅐ 하는가?