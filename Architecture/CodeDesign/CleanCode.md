# 빈약한 모델을 피하는 방법
## 동적 속성은 사용하지 않는다.
- 동적 속성은 코드를 읽기 어렵게 만들며 범위 정의가 명확하지 않고 오타를 발견하기 어렵게 만든다.
- 잘못된 속성 이름을 사용하기 수비기 때문에 타입 안정성을 악화시킨다.
  - 특성은 대규모 코드베이스에서 디버깅 하기 어려운 런타임 오류로 이어 질 수 있다.
- 클래스나 객체에 이미 정의된 속성과 동일한 이름을 가질 수 있어서 명명 충돌 가능성이 있으며, 예기치 않은 동작을 유발할 수 있다.

# 기본형 사용을 줄여야 하는 이유
## 기본 형타입만 필드로 포함하는 큰 객체 보다는, 작은 객체를 만들고 MAPPER 책임을 부여하여 구체화 한다.
- 핵심 원칙
  - 기본형 타입만 필드로 포함하는 큰 객체보다는, 작은 객체들로 분리하고 각각에 적절한 책임을 부여
  - 의미 있는 객체로 캡슐화하여 도메인 개념을 더 명확하게 표현
- 기본형 사용의 문제점
  - 데이터 유효성 검증이 여러 곳에 분산됨
  - 비즈니스 규칙을 표현하기 어려움
  - 코드 중복이 발생하기 쉬움
  - 도메인 의미를 명확히 전달하기 어려움
- 값 객체 사용의 이점
  - 유효성 검증이 각 값 객체에 캡슐화됨
  - 도메인 개념을 코드로 명확하게 표현
  - 타입 안전성 향상
  - 관련 기능 확장이 용이
- 적용 시 고려사항
  - 과도한 분리는 피하고 적절한 크기의 객체로 설계
  - 도메인에서 의미 있는 개념을 가진 데이터는 값 객체로 분리
  - 재사용 가능한 검증 로직은 값 객체에 포함
- 작은 객체를 찾는 것은 매우 어려운 작업이며, 좋은 작업을 수행하고 과도한 설계를 피하려면 경험이 필요하다.
  - 매핑 방법과 시기를 선택하는 데는 정답이 없다.

```java
// 기본형 타입을 사용하는 경우
public class Person {  
    private final String name;  
    private final String email;  

    public Person(String name, String email) {  
        // 각 필드마다 검증 로직 필요  
        if (name == null || name.trim().isEmpty()) {  
            throw new IllegalArgumentException("이름은 필수입니다.");  
        }  
        if (!email.contains("@")) {  
            throw new IllegalArgumentException("유효하지 않은 이메일입니다.");  
        }  
        
        this.name = name;  
        this.email = email;  
    }  
}  
```

```java
// 값 객체 사용
public class Name {  
    private final String value;  

    public Name(String value) {  
        if (value == null || value.trim().isEmpty()) {  
            throw new IllegalArgumentException("이름은 필수입니다.");  
        }  
        this.value = value;  
    }  
}  

public class Email {  
    private final String value;  

    public Email(String value) {  
        if (!value.contains("@")) {  
            throw new IllegalArgumentException("유효하지 않은 이메일입니다.");  
        }  
        this.value = value;  
    }  
}  

public class Person {  
    private final Name name;  
    private final Email email;  

    public Person(Name name, Email email) {  
        this.name = name;  
        this.email = email;  
    }  
}  
```

<br>

## 문자열 유효성 검사는 문자열의 하위 집합에서 하지 않는다 (값 객체를 사용한다)

### 문제점
1. 문자열 검증이 올바른 위치에 있지 않아서, **모든 객체에서 동일한 유효성 검사를 반복**한다면, 이는 코드의 **재사용성**과 **유지보수성**을 저하시킬 수 있다.
2. 검증 로직이 여러 곳에 분산되거나 반복되어, 코드가 **구조적으로 비효율적**이 되고, **의미적으로 모호한** 모델이 만들어질 수 있다.

### 해결책
- 유효성 검사는 해당 문자열이 속하는 **도메인 개념**에서 수행되어야 하며, 이는 **명확한 클래스** 또는 **값 객체(Value Object)**로 캡슐화되어야 한다.
- 값 객체 도입은 잘못된 값을 가진 **유효하지 않은 객체를 만드는 것을 방지**하며, **빠르게 실패하기(Fail Fast)** 원칙을 준수할 수 있도록 도와준다.


### 값 객체는 섣부른 최적화가 아니다

값 객체를 사용하는 것은 **성능을 우선시하기 위함이 아니라 설계의 표현력, 유지보수성, 코드 안정성**을 개선하기 위함이다. 따라서 값 객체의 사용은 절대 섣부른 최적화라고 할 수 없다.


**1. 값 객체는 "설계 관점"의 최적화이다**
- 값 객체는 단순한 타입(String, int 등)보다 **도메인 개념을 명확하게 표현**할 수 있다.
- 유효성 검증 로직을 **값 객체에 캡슐화**하여 중복된 로직을 제거하고 검증을 집중시킬 수 있다.
- 값 객체는 **빠르게 실패하기(Fail Fast)** 원칙을 준수하며, 잘못된 상태를 초기에 방지할 수 있다.
- 성능이 아니라 설계 품질의 일관성과 가독성을 높이는 **설계적 최선의 선택**이다.

**2. 값 객체는 성능 중심이 아닌 설계 중심의 접근이다**
- 값 객체는 한 번 생성되면 **불변 객체(Immutable Object)**로 설계된다.
- 이는 도메인 모델의 **안정성**과 **일관성**을 크게 높인다.
- 값 객체는 **낮은 수준의 성능 최적화**보다는 **설계 품질 향상과 명확성**을 우선시한다.

**3. 값 객체로 인해 성능이 저하된다는 증거는 없다**
- 값 객체를 사용한다고 해서, 고객의 실제 사용 시나리오에서 성능이 저하되거나 불이익이 발생할 가능성은 극히 낮다.
- 만약 성능에 눈에 띄는 영향이 없다면, **설계 품질을 높이는 방향**(값 객체 도입)을 우선해야 한다.
- 단순히 **메모리 절약**이나 **객체 생성 비용 절감**이라는 이유로 값 객체를 사용하지 않는 것은, **성급한 저수준 최적화**로 간주될 수 있다.

### 결론

### 값 객체 사용의 목적
- 성능 향상이 아니라 **설계의 명확성**, **코드 안정성**, **유지보수성**을 크게 개선하기 위함이다.
- 값 객체는 도메인 모델의 개념을 명확히 표현할 수 있으며, **유효성 검증의 집중화**, **빠르게 실패하기(Fail Fast)**, **중복 제거**를 가능하게 한다.

따라서, 값 객체를 도입하는 것은 **설계를 최적화하는 데 있어 필수적인 접근법**이다. 값 객체의 사용은 절대 섣부른 최적화가 아니며, 오히려 코드의 장기적인 안정성과 품질을 보장하는 바람직한 설계 원칙이다.

<br>

## 불필요한 속성 제거하기(동작기반의 객체를 생성한다, 데이터 중심의 객체를 생성하지 않는다.)

## 문제점

- 동작이 아닌 데이터(속성)에 먼저 집중하여 객체를 설계하는 경우가 많다.
- 실제로 필요하지 않은데도 ID, 이름 등 여러 속성이 미리 무분별하게 추가되는 일이 자주 발생한다.
- 이로 인해 객체가 불필요하게 많은 데이터를 가지게 되고, 결합도가 높아지며 유지보수가 어려워진다.

## 해결책

- 필요한 동작을 먼저 정의하고, 그 동작을 수행하기 위해 꼭 필요한 최소한의 속성만 객체에 추가해야 한다.
- YAGNI(You Aren’t Gonna Need It) 원칙을 따라, 충분한 근거가 있을 때만 속성을 추가해야 한다.

## 설명

- 학교나 입문 과정에서는 객체의 속성(특성)을 우선 정의하고, 그 위에 함수를 추가하는 방식을 가르치는 경우가 많다.
- 하지만 실제로는 필요한 동작이 무엇인지 먼저 고민하고, 동작 중심으로 객체를 설계하는 것이 더 효과적이다.
- 동작에 필요하지 않은 속성은 추가하지 않아야 하며, 객체를 단순 데이터 보유자가 아니라 **의미 있는 행동을 수행하는 주체**로 만들어야 한다.


### 잘못된 예시 (속성 위주 설계)

```java
public class Employee {
    private String id;
    private String name;
    private String address;
    private String phone;

    // 동작은 거의 없고, 단순히 데이터만 보관하는 객체이다.
    // 필요 없는 속성까지 모두 포함되어 있다.
}
```
- 위와 같이 설계하면 객체가 실제 필요하지 않은 많은 속성을 갖게 되어, 향후 유지보수가 힘들어진다.

### 개선된 예시 (동작 중심, 필요한 속성만 추가)

```java
public class Employee {

    // 실제 동작에 필요한 최소한의 속성만 포함한다.
    private String name;

    public Employee(String name) {
        this.name = name;
    }

    // 근무 보고라는 동작을 추가한다.
    public void reportWork(String workDetail) {
        System.out.println(name + "이(가) 업무를 보고했다: " + workDetail);
    }
}
```
- 필요한 동작이 먼저 정의되어 있고, 그 동작에 꼭 필요한 속성만 추가되어 있다.
- 불필요한 속성은 이후 필요성이 명확해질 때 추가하면 된다.

## 결론

- 객체는 단순히 데이터를 보유하는 존재가 아니라, 실제 동작을 수행하는 주체로 설계해야 한다.
- 동작 중심으로 필요한 속성만 추가함으로써, 코드의 의미와 유지보수성을 높일 수 있다.
- YAGNI 원칙에 따라 필요하지 않은 속성은 추가하지 않아야 하며, 실질적으로 요구되는 기능이 있을 때만 추가하는 것이 바람직하다.

<br><hr><hr>

# 가변성 (Mutability)  

객체지향 프로그래밍(OOP)은 현실 세계의 개념과 엔티티를 모델링하여 시스템을 구축하는 방법이다.  
현실 세계의 대상은 시간이 지나며 관찰을 통해 이해가 깊어지지만, 본질은 쉽게 변하지 않는다.  
따라서 객체지향 모델도 가능한 한 **불변성**을 유지하고, 필요한 경우에만 조심스럽게 진화하도록 설계해야 한다.  

객체를 과도하게 변경하거나 남용하면, 모델이 불완전해지고 설계 전체에 파급효과가 생긴다.  
이는 시스템의 일관성과 안정성을 해치며, 장기적으로 유지보수를 어렵게 만든다.  


## 객체는 왜 불변해야 하는가?  

- 객체는 생성 시점부터 **완전하고 유효한 상태**여야 한다.  
- 초기부터 엔티티의 본질을 정확히 표현할 수 있어야 하며, 그래야 이후에도 안정적으로 동작할 수 있다.  
- 현실 세계의 대부분의 엔티티는 불변이며, 변화가 있다 해도 **본질의 수정이 아닌 새로운 상태로의 이행**이다.  
- 객체가 변화한다면, 그 변화는 **우연적(incidental)**이어야 하며, **다른 객체들과의 결합 없이 독립적으로** 이루어져야 한다.  

## 모델의 표현과 일관성을 유지하기 위한 3가지 규칙  

### 규칙 1. 객체는 생성 시 완전해야 한다.  
- 유효하지 않은 상태로 객체를 생성해서는 안 된다.  
- 생성과 동시에 의미 있는 역할을 수행할 수 있어야 하며, 이는 객체의 본질을 훼손하지 않기 위함이다.  

### 규칙 2. 세터(setter)는 존재해서는 안 된다.  
- 세터는 외부에서 객체의 내부 상태를 직접 수정하게 만들어 객체의 일관성을 깨뜨린다.  
- 상태 변경은 객체의 **행위를 통해서만** 이루어져야 하며, 해당 행위는 도메인 내에서 의미 있는 동작이어야 한다.  

### 규칙 3. 게터(getter)도 지양해야 한다.  
- 현실 세계의 엔티티는 자신의 속성을 외부에 직접 노출하지 않는다.  
- 단순히 내부 값을 반환하는 동작은 객체의 책임이 아니며, 객체의 **행위 속에 포함되어야** 한다.  
- getXXX() 같은 접근자는 내부 구현에 대한 관심을 외부로 유출시켜 **캡슐화(encapsulation)**를 해치게 된다.  

## 결론  

객체지향에서 진정한 모델링은 데이터를 저장하는 구조체가 아닌, **의미 있는 개념과 행위를 가진 독립적인 객체**를 만드는 것이다.  
객체는 태어날 때부터 의미 있고 완전해야 하며, 그 상태는 가능하면 불변으로 유지되어야 한다.  
변화가 필요한 경우에도 외부에 영향을 최소화하며, **독립적으로 진화**해야 한다.  

불변성은 단순한 기술적 제약이 아니라, **모델의 일관성과 현실 세계의 정확한 표현을 위한 중요한 설계 원칙**이다.  

