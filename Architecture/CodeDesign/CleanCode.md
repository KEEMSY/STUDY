# 빈약한 모델을 피하는 방법
## 동적 속성은 사용하지 않는다.
- 동적 속성은 코드를 읽기 어렵게 만들며 범위 정의가 명확하지 않고 오타를 발견하기 어렵게 만든다.
- 잘못된 속성 이름을 사용하기 수비기 때문에 타입 안정성을 악화시킨다.
  - 특성은 대규모 코드베이스에서 디버깅 하기 어려운 런타임 오류로 이어 질 수 있다.
- 클래스나 객체에 이미 정의된 속성과 동일한 이름을 가질 수 있어서 명명 충돌 가능성이 있으며, 예기치 않은 동작을 유발할 수 있다.

# 기본형 사용을 줄여야 하는 이유
## 기본 형타입만 필드로 포함하는 큰 객체 보다는, 작은 객체를 만들고 MAPPER 책임을 부여하여 구체화 한다.
- 핵심 원칙
  - 기본형 타입만 필드로 포함하는 큰 객체보다는, 작은 객체들로 분리하고 각각에 적절한 책임을 부여
  - 의미 있는 객체로 캡슐화하여 도메인 개념을 더 명확하게 표현
- 기본형 사용의 문제점
  - 데이터 유효성 검증이 여러 곳에 분산됨
  - 비즈니스 규칙을 표현하기 어려움
  - 코드 중복이 발생하기 쉬움
  - 도메인 의미를 명확히 전달하기 어려움
- 값 객체 사용의 이점
  - 유효성 검증이 각 값 객체에 캡슐화됨
  - 도메인 개념을 코드로 명확하게 표현
  - 타입 안전성 향상
  - 관련 기능 확장이 용이
- 적용 시 고려사항
  - 과도한 분리는 피하고 적절한 크기의 객체로 설계
  - 도메인에서 의미 있는 개념을 가진 데이터는 값 객체로 분리
  - 재사용 가능한 검증 로직은 값 객체에 포함
- 작은 객체를 찾는 것은 매우 어려운 작업이며, 좋은 작업을 수행하고 과도한 설계를 피하려면 경험이 필요하다.
  - 매핑 방법과 시기를 선택하는 데는 정답이 없다.

```java
// 기본형 타입을 사용하는 경우
public class Person {  
    private final String name;  
    private final String email;  

    public Person(String name, String email) {  
        // 각 필드마다 검증 로직 필요  
        if (name == null || name.trim().isEmpty()) {  
            throw new IllegalArgumentException("이름은 필수입니다.");  
        }  
        if (!email.contains("@")) {  
            throw new IllegalArgumentException("유효하지 않은 이메일입니다.");  
        }  
        
        this.name = name;  
        this.email = email;  
    }  
}  
```

```java
// 값 객체 사용
public class Name {  
    private final String value;  

    public Name(String value) {  
        if (value == null || value.trim().isEmpty()) {  
            throw new IllegalArgumentException("이름은 필수입니다.");  
        }  
        this.value = value;  
    }  
}  

public class Email {  
    private final String value;  

    public Email(String value) {  
        if (!value.contains("@")) {  
            throw new IllegalArgumentException("유효하지 않은 이메일입니다.");  
        }  
        this.value = value;  
    }  
}  

public class Person {  
    private final Name name;  
    private final Email email;  

    public Person(Name name, Email email) {  
        this.name = name;  
        this.email = email;  
    }  
}  
```

<br>

## 문자열 유효성 검사는 문자열의 하위 집합에서 하지 않는다 (값 객체를 사용한다)

### 문제점
1. 문자열 검증이 올바른 위치에 있지 않아서, **모든 객체에서 동일한 유효성 검사를 반복**한다면, 이는 코드의 **재사용성**과 **유지보수성**을 저하시킬 수 있다.
2. 검증 로직이 여러 곳에 분산되거나 반복되어, 코드가 **구조적으로 비효율적**이 되고, **의미적으로 모호한** 모델이 만들어질 수 있다.

### 해결책
- 유효성 검사는 해당 문자열이 속하는 **도메인 개념**에서 수행되어야 하며, 이는 **명확한 클래스** 또는 **값 객체(Value Object)**로 캡슐화되어야 한다.
- 값 객체 도입은 잘못된 값을 가진 **유효하지 않은 객체를 만드는 것을 방지**하며, **빠르게 실패하기(Fail Fast)** 원칙을 준수할 수 있도록 도와준다.


### 값 객체는 섣부른 최적화가 아니다

값 객체를 사용하는 것은 **성능을 우선시하기 위함이 아니라 설계의 표현력, 유지보수성, 코드 안정성**을 개선하기 위함이다. 따라서 값 객체의 사용은 절대 섣부른 최적화라고 할 수 없다.


**1. 값 객체는 "설계 관점"의 최적화이다**
- 값 객체는 단순한 타입(String, int 등)보다 **도메인 개념을 명확하게 표현**할 수 있다.
- 유효성 검증 로직을 **값 객체에 캡슐화**하여 중복된 로직을 제거하고 검증을 집중시킬 수 있다.
- 값 객체는 **빠르게 실패하기(Fail Fast)** 원칙을 준수하며, 잘못된 상태를 초기에 방지할 수 있다.
- 성능이 아니라 설계 품질의 일관성과 가독성을 높이는 **설계적 최선의 선택**이다.

**2. 값 객체는 성능 중심이 아닌 설계 중심의 접근이다**
- 값 객체는 한 번 생성되면 **불변 객체(Immutable Object)**로 설계된다.
- 이는 도메인 모델의 **안정성**과 **일관성**을 크게 높인다.
- 값 객체는 **낮은 수준의 성능 최적화**보다는 **설계 품질 향상과 명확성**을 우선시한다.

**3. 값 객체로 인해 성능이 저하된다는 증거는 없다**
- 값 객체를 사용한다고 해서, 고객의 실제 사용 시나리오에서 성능이 저하되거나 불이익이 발생할 가능성은 극히 낮다.
- 만약 성능에 눈에 띄는 영향이 없다면, **설계 품질을 높이는 방향**(값 객체 도입)을 우선해야 한다.
- 단순히 **메모리 절약**이나 **객체 생성 비용 절감**이라는 이유로 값 객체를 사용하지 않는 것은, **성급한 저수준 최적화**로 간주될 수 있다.

### 결론

### 값 객체 사용의 목적
- 성능 향상이 아니라 **설계의 명확성**, **코드 안정성**, **유지보수성**을 크게 개선하기 위함이다.
- 값 객체는 도메인 모델의 개념을 명확히 표현할 수 있으며, **유효성 검증의 집중화**, **빠르게 실패하기(Fail Fast)**, **중복 제거**를 가능하게 한다.

따라서, 값 객체를 도입하는 것은 **설계를 최적화하는 데 있어 필수적인 접근법**이다. 값 객체의 사용은 절대 섣부른 최적화가 아니며, 오히려 코드의 장기적인 안정성과 품질을 보장하는 바람직한 설계 원칙이다.


