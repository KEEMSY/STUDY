### 소프트웨어
- 현실에서 일어나는 가능한 일을 묘사(mimic) 하는 것
- 컴퓨터에서 실행되는 명령어
  - 컴퓨터가 수행할 작업을 지시하는 명령어

---

### Model: Abstract Partial and Programmable Explaining Reality(MAPPER)
- 모델은 부분적 추상화와 프로그래밍을 통해 현실을 묘사해야 한다.

---

### Model
- 현실의 특정 측면을 특별한 패러다임을 사용해 구체적인 시선과 관점에서 바라본 결과물
- 절대적으로 변하지 않는 진리가 아닌 현재 가장 정확하게 이해하고 있는 지식으로 구성된 것
- 실제 행동을 예측하는데 사용되는 것
- 모델의 목표는 어떤 것이 어떻게 작동하지는 이해하는 것
  - 모델링하는 현실에서 행동을 추론하고 예측하는데 도움이 되고, 이에 대한 변화를 관찰할 수 있을 만큼 선언적이여야 한다.
  - 구체적인 단계를 밝히지 않더라도 수행한 작업을 설명할 수 있어야 한다.
  - 관찰 가능한 환경에서 일어나는 상황을 재현해야 한다.
  - 하나의 규칙에 따라 소프트웨어 전체 패러다임을 설계하면 단순하고 우수한 모델을 만들 수 있다.

---

### 튜링 모델(Turing model)
- 일련의 명령어나 알고리즘을 통해 계산 가능한 모든 작업을 수행할 수 있는 이론적인 기계
- 실제 컴퓨터와 프로그래밍 언어의설계와 분석에 모델로 사용 됨

---

### 빈약한 객체(데이터 객체)
- 주로 데이터를 저장하는 역할을 하며, 해당 데이터에 대해 수행할 수 있는 의미 있는 메서드나 연산이 없는 객체를 의미
  - 빈약한 설계 방식은 의미있는 동작들을 포괄하는 객체 캡슐화 보다 데이터를 조작하는데 중점을 두는 프로시저 스타일의 프로그래밍으로 이어질 수 있다.

---

### 풍성한 객체
- 의미있는 연산을 수행할 수 있고, 반복되는 로직은 피하며, 단일 접근 지점을 제공하는 동작과 메서드 집합을 말한다.

---

### 공리
- 증명 없이 명백한 진리로 받아들여지는 진술이나 명제를 의미
- 공리를 통해 추론과 논리적인 틀을 구축할 수 있으며, 이를 통해 더 많은 진리를 도출할 수 있는 일련의 기본 개념과 관계를 설정할 수 있음

---

### 전단사(bijection)
- 두 집합의 요소 간에 일대일 대응을 설정하는 함수
- 동형(isomorphism)은 구조의 동작을 보존하는 전단사 함수
- 소프트 웨어 영역에서는 실제 엔티티를 나타내는 객체가 항상 하나만 존재(전단사 원칙을 준수)한다.
- 전단사 원칙을 준수하지 않을 않을 경우
  - 오류가 제때 드러나지 않는 문제 발생(의미론적인 문제이기 때문에 실패한 지 한참 후에 오류가 발견 됨(빠르게 실패하기 원칙 위반)
  - 다수의 엔터티에 동일한 모델링을 하고 있기 때문에, 다수의 엔터티에 모두 반영되지 않는 경우 추후 불일치 문제가 발생할 수 있음
  - 빈약한 모델(엔티티에 속성이 있는 데이터 구조)이 될 가능성이 높다.

---
 
### 빠르게 실패하기
- 오류가 발생했을 때, 이를 무시하고 결과적으로 나중에 실패하는 것이 아니라, 가능한 초기에 빨리 실행을 중단하는 것

---

### 캡슐화(encapsulation)
- 객체의 책임을 보호하는 것
  - 내부 구현을 추상화 하는 방법을 사용하며, 이를 통해 객체의 메서드에 대한 접근을 제어(보호)한다.
- 캡슐화를 통해, 객체의 내부 구현과 세부 정보를 숨기고, 프로그램의 다른 부분에서 사용되는 필요한 동작만 노출할 수 있다.

---

### 본질적(essential) 복잡성
- 해결하려는 문제에 대한 복잡성
- 비즈니스 요구사항을 충족하기 위해 반드시 구현해야 하는 로직과 규칙들을 의미
- 도메인 자체에서 발생하여, 개발자가 통제할 수 없음
- 불가피 하다는 특징을 갖고 있음

---

### 우발적(accidential) 복잡성
- 시스템이 설계되고 구현되는 방식에서 마주하는 복잡성
- 구현 방식에서 발생 함
- 좋은 설계를 통해 줄일 수 있음(개발자가 통제할 수 있음)

---

### 묻지 말고 말하라(Tell,Don'ask, TDA) 원칙
- 객체 지향 프로그래밍에서 객체의 내부 상태를 직접 조회하여 결정을 내리는 대신, 객체에게 행위를 요청하는 것을 권장하는 원칙
- 객체의 내부 구현을 숨겨 캡슐화를 강화하며, 구현 변경이 용이해질 수 있음
- 비즈니스 로직이 관련 객체에 위치하게 되어 응집도가 향상 됨
- 코드 변경의 영향 범위가 줄어들게 되고 테스트가 하여 유지보수성이 증진 됨

---

### 선언적 코드(declarative code)
- 프로그램이 무엇을 해야하는지를 설명하는 프로그래밍 코드의 한 종류
  - 프로그램이 어떤 일을 성취하기 위해 해야 할 단계를 명시하는 것이 아님에 주의
- 결과를 성취하는 과정(방법)보다는 원하는 결과(무엇)에 초첨을 두어야 함

---

### DTO(data transfer object, 데이터 전송 객체)
- 애플리케이션의 서로 다른 계층 간에 데이터를 전송하는 데 사용되는 객체
- 애플리케이션 클라이언트와 서버 간의 데이터를 전달하고 단순한 직렬화 가능한 불변의 객체
  - 단, 상황(용도)에 따라 가변적일 수 있음
- DTO 는 빈약한 객체이지만, 유일한 목적으로 애플리케이션의 여러 부분 간에 데이터를 교환하는 표준 방법을 제공하는 위해 사용
  - 버전 관리 및 API 문서화로서 사용될 수 있음

---

### 데메테르의 법칙(Demeter's law, 최소 지식의 법칙)
- 객체는 바로 옆의 이웃 객체와만 소통해야 하며 다른 객체의 내부 작동 방식을 알면 안된다는 원칙(한 객체는 다른 객체의 내부에 접근하기 위해 다른 객체에 접근하지 않고, 바로 옆 객체의 메서드에만 접근해야 한다는 원칙)
  - 데메테르의 법칙을 따르기 위해서는 느슨하게 결합 된(서로에게 크게 의존하지 않는) 객체를 만들어야 함
- 객체가 메시지를 보낼 수 있는 대상
  - 객체 자신
  - 메서드의 매개변수
  - 메서드 내에서 생성된 객체
  - 객체의 인스턴스 변수
- 장점
  - 한 객체를 변경해도 다른 객체에 의도하지 않은 결과를 초래할 가능성이 적어짐
  - 시스템을 유연하고 쉽게 유지 관리할 수 있음
  - 캡슐화 강화
  - 코드의 가독성 향상
  - 테스트 용이성 증가
  - 변경의 영향 범위 최소화
- 주의사항
  - 때로는 법칙을 엄격히 적용하면 과도한 래핑이 발생할 수 있음
  - 특히 DTO나 데이터 구조체의 경우 예외가 될 수 있음
  - 상황에 맞는 유연한 적용 필요
  - 과도한 위임 메서드 생성 주의
  - 도메인 모델의 응집도 고려 필요

---
 
### 베이비 스텝((baby step)
- 개발 과정에서 관리하기 쉬운 작업이나 변경을 수행하는 반복적이고 점진적인 접근 방식
- 베이비 스텝의 개념은 애자일 방법론에 뿌리를 두고 있음

---

### 폴터가이스트 객체
- 초기화를 수행하거나 다른 영구적인 클래스의 메서들르 호출하는 데 사용되는 수명이 짧은 객체

---

### 정보 은닉
- 소프트웨어 시스템의 내부 작업과 외부 인터페이스를 분리해 시스템 복잡성을 줄이는 것을 목표로 하는 설계 원칙이다.

- 핵심 특징
  - 구현 분리
    - 시스템의 내부 구현을 외부로부터 숨긴다
    - 내부 구현 변경이 외부 인터페이스에 영향을 주지 않는다
  - 인터페이스 제공
    - 시스템 기능에 대한 단순화된 인터페이스를 제공한다
    - 사용자는 내부 구현을 알 필요 없이 인터페이스만으로 시스템을 활용할 수 있다

- 장점
  - 유지보수성 향상: 내부 구현 변경이 용이하다
  - 의존성 감소: 시스템 간 결합도를 낮춘다
  - 재사용성 증가: 잘 정의된 인터페이스를 통해 다른 시스템에서 재사용하기 쉽다
  - 테스트 용이성: 인터페이스 기반으로 테스트가 가능하다

- 구현 방법
  - 캡슐화를 통한 구현
    - 객체지향 프로그래밍에서 private, protected 등의 접근 제어자 활용
    - getter/setter 메서드를 통한 제어된 접근
  - 추상화를 통한 인터페이스와 구현의 분리
    - 인터페이스나 추상 클래스 활용
    - API 설계를 통한 기능 은닉

---

### 객체 난장판(Object Orgy)
-  객체가 불충분하게 캡슐화 되어 내부에제한 없이 접근한 수 있는 상황
  - 객체들이 서로의 내부 구현에 과도하게 의존하며 직접 겁근하는 상황
-  객체 지향 설계에서 흔히 볼 수 있는 안티패턴이며, 유지 관리 횟수와 복잡성이 증가할 수 있음

-  문제점
  - 캡슐화 위반
    - 객체의 내부 상태가 외부에 과도하게 노출
    - 정보 은닉 원칙 훼손
  - 강한 결합도
    - 객체들이 서로 긴밀하게 얽혀있어 변경이 어려움
    - 한 객체의 변경이 다른 객체에 큰 영향을 미침
  - 책임 분산
    - 객체의 책임과 역할이 불분명
    - 유지보수 복잡성 증가
  - 재사용성 저하
    - 높은 결합도로 인한 컴포넌트 재사용 어려움
    - 코드 중복 발생 가능성 증가

- 발생 원인
  - getter/setter의 과도한 사용
  - public 필드의 무분별한 노출
  - 객체 간 책임 경계가 불명확한 설계
  - 캡슐화와 정보 은닉 원칙을 간과한 개발

- 해결 방안
  - 구조적 개선
    - 적절한 접근 제어자 사용 (private, protected)
    - 인터페이스 기반 설계로 구현 세부사항 숨기기
    - 객체의 책임과 역할을 명확히 정의
    - Law of Demeter (최소 지식 원칙) 준수
    - 불필요한 getter/setter 제거
- 예방 방법
  - SOLID 원칙 준수
  - 명확한 객체 책임 정의
  - 정기적인 코드 리뷰
  - 의존성 주입(DI) 활용
  - 캡슐화와 정보 은닉 원칙 준수

- 기대 효과
  - 코드 유지보수성 향상
  - 시스템 확장성 개선
  - 버그 발생 가능성 감소
  - 코드 품질 향상
  - 재사용성 증가

---

### 응집력(cohesion)
- 단일 소프트웨어 클래스 또는 모듈 내의 요소들이 잘 정의된 단일 목표를 달성하기 위해 함께 작동하는 척도를 말함
- 객체들이 서로 얼마나 밀접하게 연관 되어 있는지, 모듈 전체 목표와 얼마나 밀접하게 연관되어 있는지를 나타냄

**응집력의 특징**
  - 높은 응집력은 좋은 설계의 지표가 됨
  - 유지보수성과 재사용성이 향상됨
  - 모듈의 독립성이 증가함

**응집력의 종류 (강한 순서대로)**
  - **기능적 응집(Functional Cohesion)**
    - 모든 요소가 단일 기능을 위해 협력
    - 가장 강한 응집도를 가짐
  - 순차적 응집(Sequential Cohesion)
    - 한 요소의 출력이 다른 요소의 입력으로 사용
  - 통신적 응집(Communication Cohesion
    - 동일한 데이터를 사용하는 요소들의 그룹
  - 절차적 응집(Procedural Cohesion)
    - 특정 실행 순서로 관련된 요소들
  - 시간적 응집(Temporal Cohesion)
    - 특정 시점에 실행되는 요소들의 그룹
  - 논리적 응집(Logical Cohesion)
    - 논리적으로 유사한 기능을 수행하는 요소들
  - 우연적 응집(Coincidental Cohesion)
    - 의미 있는 연관성 없이 그룹화된 요소들
    - 가장 약한 응집도를 가짐

**실무적 의의**
  - 코드의 가독성과 이해도가 향상됨
  - 버그 발생 가능성이 감소함
  - 테스트가 용이해짐
  - 코드 변경 시 영향 범위가 최소화됨

**응집력을 높이는 방법**
  - 단일 책임 원칙(SRP) 준수
  - 관련 있는 기능들을 같은 모듈에 배치
  - 불필요한 의존성 제거
  - 명확한 모듈의 목적 정의

---

### 은빛 총알은 없다(No Sliver Bullet)

**핵심 개념**
- 소프트웨어 개발에서 모든 문제를 해결할 수 있는 마법같은 단일 해결책은 존재하지 않는다는 프레더릭 브룩스의 통찰
- 각 문제와 상황에 맞는 적절한 해결책을 찾아야 함

**주요 시사점**
- 복잡성의 본질

  - 소프트웨어의 본질적 복잡성(Essential Complexity)은 피할 수 없음
  - 우발적 복잡성(Accidental Complexity)은 개선 가능

- 개선 방향
  - 점진적인 개선과 지속적인 노력이 필요
  - 다양한 도구와 방법론의 조합 활용
  - 상황에 맞는 최적의 해결책 선택

- 실무적 적용

  - 새로운 기술이나 방법론을 맹신하지 않음
  - 기존 시스템과 방법의 장단점을 고려
  - 팀과 프로젝트 상황에 맞는 균형잡힌 접근

**주의사항**
- 완벽한 해결책을 찾으려 하기보다 실용적인 접근 필요
- 새로운 기술이나 도구도 장단점이 있음을 인식
- 과도한 기대나 환상을 경계

**적용 전략**
- 문제를 정확히 이해하고 분석
- 가능한 여러 해결책의 장단점 평가
- 상황에 가장 적합한 방법 선택
- 지속적인 개선과 피드백 수용

---

### 신속한 프로토타이핑  

#### 개념  
- 제품 개발에서 최종 사용자가 검증할 수 있는 작동 프로토타입을 신속하게 생성하는 기술  
- 단순한 '빠른 시제품 제작'을 넘어 '검증 기반 학습 과정'으로서의 가치를 지님  
- 디자이너가 테스트와 개선을 통해 디자인을 검증한 후, 일관되고 강력하며 우아한 코드를 작성할 수 있게 됨  
- 최종 사용자 검증뿐만 아니라 내부 이해관계자와의 아이디어 소통 및 합의를 위한 도구로 활용  

#### 프로토타이핑의 유형  
- **저충실도 프로토타입(Low-fidelity)**: 종이 스케치, 와이어프레임 등으로 빠르게 아이디어를 시각화  
- **중충실도 프로토타입(Mid-fidelity)**: 클릭 가능한 모형, 기본적 상호작용이 구현된 형태  
- **고충실도 프로토타입(High-fidelity)**: 실제 제품과 유사한 외관과 기능을 갖춘 작동 모델  

#### 프로세스  
1. **문제 정의 및 가설 설정**: 해결하려는 문제와 검증할 가설을 명확히 함  
2. **아이디어 구체화**: 핵심 기능과 사용자 경험 흐름 설계  
3. **프로토타입 제작**: 빠르게 테스트 가능한 형태로 구현  
4. **사용자 테스트 및 피드백 수집**: 실제 사용자로부터 정성적/정량적 데이터 수집  
5. **반복 및 개선**: 피드백을 바탕으로 프로토타입 수정 및 재검증  

#### 주요 이점  
- 개발 초기 단계에서 잠재적 문제 식별 및 비용 절감  
- 이해관계자 간 효과적인 커뮤니케이션 촉진  
- 사용자 요구사항에 대한 정확한 이해 도모  
- 혁신적 아이디어를 위험 부담 없이 테스트 가능  
- 최종 제품 개발 시 명확한 방향성 제시  

#### 현대적 접근법과 도구  
- **디자인 시스템 활용**: 재사용 가능한 컴포넌트로 프로토타이핑 시간 단축  
- **노코드/로코드 도구**: Figma, Webflow, Bubble 등을 활용한 빠른 구현  
- **AI 지원 프로토타이핑**: 인공지능을 활용한 디자인 및 코드 생성으로 프로세스 가속화  
- **DevOps 통합**: 지속적 통합/배포(CI/CD) 파이프라인과 연결하여 프로토타입에서 제품으로의 전환 효율화  

#### 실무적 조언  
- '완벽함'보다 '충분한 기능성'에 집중하는 MVP(Minimum Viable Product) 접근법 채택  
- 프로토타입의 목적과 범위를 명확히 정의하여 불필요한 기능 구현 방지  
- 사용자 피드백 수집을 위한 구체적인 질문과 시나리오 준비  
- 프로토타입 결과를 팀 내 지식으로 체계화하여 향후 개발에 활용  

신속한 프로토타이핑은 단순한 기술적 과정이 아닌, 제품 개발의 핵심 철학으로 자리 잡고 있으며, 디자인적 사고와 애자일 방법론의 중요한 구성 요소임을 인지해야 함 

---

## 돌연변이 테스트(Mutation Testing)  

- 단위 테스트의 **품질을 평가하는 데 사용되는 기법**이다.  
- 테스트 중인 코드에 작고 통제된 변경사항(이를 **돌연변이(mutant)** 라고 함)을 도입하고, 기존 단위 테스트가 이 변경을 **감지하고 실패하는지** 확인한다.  
- 돌연변이를 도입한 후에도 테스트가 여전히 통과된다면, 이는 테스트가 해당 코드의 동작을 제대로 검증하지 못하고 있다는 뜻이다.  
- 따라서 **코드에 대한 테스트 커버리지뿐 아니라, 테스트의 검증력(assertion strength)** 을 평가할 수 있는 수단이다.  
- **테스트되지 않은 경로, 조건, 분기** 등을 식별하는 데 유용하며, **기존 테스트의 실질적인 효과를 측정하는 척도**로 사용된다.  
- 실패한 돌연변이는 **죽은 돌연변이(killed mutant)**, 통과한 돌연변이는 **살아있는 돌연변이(survived mutant)** 라고 한다.  
- **돌연변이 점수(Mutation Score)** = (죽은 돌연변이 수 / 전체 돌연변이 수) × 100으로 계산되며, 이 점수를 통해 테스트 품질을 수치로 파악할 수 있다.  

**왜 돌연변이 테스트가 중요한가?**

- 단순한 **라인 커버리지(line coverage)** 나 **브랜치 커버리지(branch coverage)** 는 코드 실행 여부만 확인할 수 있다.  
- 그러나 이러한 커버리지 지표만으로는 테스트가 코드의 동작을 **의미 있게 검증하고 있는지**는 판단할 수 없다.  
- 돌연변이 테스트는 테스트의 **내재된 취약점을 드러내며**, 테스트가 실제로 코드의 **의도된 동작을 감시하고 있는지**를 검증하게 해준다.  
- 특히 **복잡한 로직, 조건 분기, 예외 처리** 가 많은 코드에서 돌연변이 테스트는 테스트 강도를 높이는 데 매우 유용하다.  

**돌연변이 테스트의 단점과 고려사항**  

- 돌연변이 테스트는 **계산 비용이 크고 수행 시간이 길다.**  
  - 각 돌연변이에 대해 전체 테스트를 반복 실행해야 하기 때문이다.  
- 생성된 돌연변이 중 일부는 **등가 돌연변이(equivalent mutant)** 일 수 있으며, 이는 기존 코드와 의미상 동일한 코드로 변경된 경우를 말한다.  
  - 등가 돌연변이는 테스트로 감지할 수 없기 때문에, **자동으로 식별하기 어렵고 수동으로 분석이 필요**할 수 있다.  
- 이러한 비용과 한계 때문에 일반적으로 **CI/CD 파이프라인에 통합하기보다는, 테스트 개선이나 리팩토링의 품질 측정 용도**로 주로 사용된다.

---

### 놀람 최소화 원칙

놀람 최소화 원칙(Principle of Least Astonishment, POLA)은 시스템이 사용자에게 예상치 못한 놀라움을 주지 않고 직관적인 방식으로 작동해야 한다는 설계 원칙이다. 이 원칙은 사용자 인터페이스뿐만 아니라 API, 라이브러리, 프레임워크 등 모든 소프트웨어 인터페이스에 적용된다.

#### 핵심 개념

- **예측 가능성**: 시스템의 동작이 사용자의 기대와 일치해야 함
- **일관성**: 유사한 상황에서는 항상 유사한 방식으로 동작해야 함
- **명확성**: 인터페이스의 의도와 동작이 명확하게 이해될 수 있어야 함
- **관용성**: 일반적인 실수나 오해에 대해 관대하게 대응해야 함

#### 실제 적용 예시

```java
// 나쁜 예: 예상치 못한 부작용이 있는 메서드
public class User {
    private String name;
    
    // 이름을 반환하지만 동시에 로그를 기록하는 게터
    public String getName() {
        Logger.log("사용자 이름 접근: " + name);
        return name;
    }
}

// 좋은 예: 놀람 최소화 원칙 준수
public class User {
    private String name;
    
    // 단순히 이름만 반환하는 순수 게터
    public String getName() {
        return name;
    }
    
    // 로깅이 필요한 경우 별도 메서드로 분리
    public String getNameWithLogging() {
        Logger.log("사용자 이름 접근: " + name);
        return name;
    }
}
```

#### 놀람 최소화 원칙의 이점

1. **학습 곡선 완화**: 사용자가 시스템을 더 빠르게 배울 수 있음
2. **오류 감소**: 사용자의 혼란으로 인한 실수 가능성 감소
3. **생산성 향상**: 시스템 동작을 이해하는 데 소요되는 시간 단축
4. **유지보수성 개선**: 코드의 의도가 명확해져 유지보수가 용이해짐

#### 관련 원칙들

- **최소 놀람 경로(Path of Least Surprise)**: 사용자가 가장 예상하는 경로를 기본 경로로 설정
- **단일 책임 원칙(SRP)**: 각 구성 요소는 하나의 책임만 가져 예측 가능성 증가
- **명시적 인터페이스(Explicit Interface)**: 숨겨진 동작이나 부작용이 없는 명확한 인터페이스 제공

놀람 최소화 원칙은 소프트웨어의 직관성과 사용성을 향상시켜 사용자 경험과 개발자 생산성을 모두 개선하는 중요한 설계 원칙이다.