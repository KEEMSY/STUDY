# Operating System

운영 체제는 애플리케이션 개발자(우리)를 대신하여 간섭하고 개발자와 하드웨어, CPU 사이의 상호작용을 돕는다.

- 사용자가 애플리케이션을 실행하면, 운영체제는 디스크에 있던 프로그램을 메모리로 가져와 프로그램의 인스턴스를 생성한다.

*이 인스턴스를 `프로세스`  또는 `애플리케이션 컨텍스트` 라고 부르기도한다.*

<br>

![Process.png](/img/Process.png)
각 프로세스는 시스템에서 실행되는 다른 프로세스와는 완전히 별개이다.

- 프로세스 안의 메타데이터에는 PID(애플리케이션이 읽고 쓰기 위해 여는 파일), files , Code(CPU에서 실행되는 프로그램 명령어), Heap(애플리케이션에 필요한 모든 데이터가 들어있음), Main Thread(스레드가 적어도 하나이상 존재)가 존재한다.

<br>

스레드는 크게 두가지(스택, 명령어 포인터)를 갖고 있다.

- 멀티 스레드 애플리케이션에서는 각각의 스레드는 자체 스택과 멸령어 포인터를 가지지만, 프로세스 내의 나머지 컴포넌트는 모든 스레드가 공유한다.
- 스택: 메모리 영역으로 지역변수가 저장되고 기능이 실행되는 영역을 말한다.
- 명령어 포인터: 스레드가 실행할 다음 명령어의 주소를 가리키는 역할을 한다.

<br>

스레드가 자체 스택과 명령어 포인터를 갖는 이유는 다음과 같다.

- 각각의 스레드는 특정 순간에 서로 다른 함수를 이용해 다른 명령을 수행하기 위해 자체 스택과 명령어 포인터를 갖는다.

<br><hr><hr>

## **Context Switch**

*하나의 스레드 실행을 멈추고 다른 스레드를 스케줄링한 다음 다시 실행하는 것을 컨텍스트 스위치라 말한다.*

![ThreadCompeting.png](/img/ThreadCompeting.png)

애플리케이션의 각각의 인스턴스는 다른 프로세스와는 독립적으로 실행된다.

- 일반적으로 코어보다 프로세스가 훨씬 많고 각각의 프로세스는 하나 이상의 스레드를 갖는다.
- 모든 스레드는 CPU 실행에 서로 경쟁한다.
- 코어가 여러 개라 하더라도 스레드가 코어보다 많다.
- 운영체제는 스레드 하나를 실행하고, 멈추고를 반복한다.

<br>

컨텍스트 스위치는 동시에 많이 스레드를 다룰경우 효율성이 떨어지기 때문에 중요하다.(병행성에 대한 트레이드오프)

- CPU에서 실행되는 각 스레드는 CPU 내의 레지스터나 캐시 메모리 내의 커널 리소스 같은 것을 일정 부분 차지하게 된다.
- 다른 스레드로 전환 할 때는 기족의 데이터를 저장하고, 또 다른 스레드의 리소스를 CPU와 메모리에 복원해야한다.
- 즉, 너무 많은 스레드는 가동하게 되면 Thrashing(컨텍스트 스위치에 더 많은 시간을 할애하는 것을 말한다.)가 발생한다.

<br>

스레드는 프로세스보다 리소스를 더 적게 사용한다.

- 같은 프로세스에 속한 두 스레드 간의 컨텍스트 스위치가 각각 다른 프로세스의 두 스레드간의 컨텍스트 스위치보다 효율적이다.

<br><hr><hr>

## **Thread Scheduling**

하나의 코어에 프로세스 2개(음악 플레이어, 텍스트 편집기)를 사용하여, 4개의 스레드를 사용한다 가정한다.

- 음악플레이어에는 스레드 2개가 존재한다. 하나는 스피커, 하나는 UI 스레드로 트랙의 상황을 보여주고 재생, 멈춤, 마우스 클릭에 반응한다.
- 텍스트 편집기 또한 스레드가 2개이다. 하나는 UI, 다른 하나는 현재 작업을 2초마다 파일에 저장한다.

<br>

스케줄링은 다음과 같은 상황을 고려할 수 있다.

- **선착순으로 스케줄을 짠다.**

    실행 시간이 긴 스레드가 먼저 도착하면 다른 스레드에 기아현상이 발생한다.

- **짧은 순서대로 스케줄링을 한다.**

    가장 짧은 작업을 항상 맨 앞에 배치하게 되면 계산이 들어간 긴 작업들은 영원히 실행 될 수 없다.

<br>

> **`Dynamic Priority = Static Priority + Bonuse(can be negative)`**

스레드에 시간을 할당하는 방법은 운영체제가 각각의 스레드에 적용하는 **동적 우선순위** 에 달렸다.

- 정적 우선순위는 개발자가 미리 설정하고, 보너스는 운영체제가 각각의 에포크 마다 조절한다.
- 이를 통해 운영체제는 즉각적인 반응이 필요한 실시간 스레드나 인터랙티브 스레드에게 우선권을 준다.
- 동시에 기아현상을 막기 위해 이전 에포크에서 실행 시간이 부족했거나 완료되지 않은 스레드도 놓치지 않는다.

<br><hr><hr>

## **Threads VS Process**

새로 생성한 프로그램을 다른 프로세스에 실행하는 시점에 멀티스레드를 사용할지, 멀티 프로세스 접근법을 사용할지 선택해야한다.

- 멀티스레드를 사용한다.

   **많은 데이터를 공유하는 다양한 작업을 실행하는 경우** 멀티스레드 아키텍처가 좋다. 뿐만아니라, 스레드는 생성과 파기가 훨씬 빠르고 같은 프로세스 안에서 멀티 스레드끼리 전환하는 것이 여러 프로세스 전환보다 빠르다.

    <br>

- 프로세스를 사용한다.

    가장 중요한 점이 **보안과 안정성**이라면 프로세스를 사용한다.
    멀티스레드 애플리케이션의 경우 앱전체가 스레드 하나에 다운될 수 있기 때문이다. 또한 **서로 관련이 없는 작업을 실행할 경우** 같은 프로세스에 통합하는것(스레드사용)도 아무 의미가 없다.
