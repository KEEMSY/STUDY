# 시스템 성능 확인
## 요약
- `uptime` 은 일정 시간동안 CPU에 걸리는 부하의 평균을 알려주며, 비정상적인 결과를 보고 CPU를 많이 사용하는 프로세스를 찾아 관리 할 수 있다.
- `nice` 명령은 한정된 시스템 리소스를 놓고 경쟁하는 프로세스들을 조정할 수 있다.
- 실제 메모리와 스왑 메모리는 `free`와 `vmzstat`을 통해 모니터링 할 수 있다.
- 스토리지 한계는 물리적인 디스크 공간뿐만 아니라 사용할 수 있는 inode 개수에 의해 정의된다.
- `iftop` 와 `NetHogs` 는 네트워크 부하 데이터를 파악하는데 사용하는 수십 개의 도구 중 하나이며, `tc`명령으로 네트워크 사용량을 제한 할 수 있다.
- 명령줄 도구들로 정기적인 모니터링은 가능하지만, 명령을 스크립트화하고 모니터링 데이터를 시각화하는 것이 훨씬 효과적이다.

<br><hr><br>

## 핵심용어
- `CPU 부하(CPU load)`: CPU가 처리하는 작업의 양
- `CPU 사용률(CPU utilization)`: CPU 용량 대비 현재 CPU가 사용되는 비율
- `램(RAM)메모리`: OS 커널과 중요 소프트웨어들을 올려놓고 핵심 데이터에 빠르게 접근 할 수 있게 한다.
- `스왑(swap)메모리`: 하드디스트 드라이브에 가상램으로 지정된 공간으로, 실제 메모리가 부족할 때 사용한다.
- `inode`: 위치와 다른 정보들을 담고 있는 메타데이터로, 모든 리눅스 파일 시스템 개체에 연결 되어있다.
- `네트워크 트래핑 스로틀링(network traffic throttling)`: 우선순위가 높은 프로세스들을 위해 프로세스가 사용하는 네트워크 대역폭을 제한한다.


<br><hr><br>


## 세부사항

<br>

> **CPU부하 측정하기**
- `CPU 부하(CPU load)`: 최대 처리 용량 대비 CPU가 수행하는 작업량(현재 활성화되고 큐에 들어가 있는 프로세스의 수)의 비를 백분률로 나타낸 것. 평균 부하는 일정 시간의 시스템 활동을 나타내므로 시스템 상태를 좀 더 정확히 보여주는 좋은 지표이다.
- `CPU 이용율(CPU utilization)`: 최대 처리 용량 대비 CPU가 유휴상태(idle)이 아닌 시간의 비를 백분률로 나타낸 것
    - `kill [PID]` : 프로세스 종료
    - `killall [PROCESS_NAME]` : 프로세스를 생성한 프로그램 이름을 이용해 그 프로그램이 생성한 프로세스를 모두 종료
    - `uptime`: CPU의 평균 부하를을 얻을 수 있다.
    - `top`: 프로세스 정보를 업데이트해가며 CPU의 평균 부하를 알 수 있다.
        
        >`top` 에 나오는 CPU 관련 측정 기호
        - `us`: 높은 우선순위(nice 되지 않은) 프로세스를 실행한 시간
        - `sy`: 커널 프로세스를 실행한 시간
        - `ni`: 낮은 우선순위(nice 된) 프로세스를 실행한 시간
        - `id`: 유휴(idle)시간
        - `wa`: I/O 이벤트가 완료될 때 까지 걸린 시간
        - `hi`: 하드웨어 인터럽트를 관리하는 데 걸린 시간
        - `si`: 소프트웨어 인터럽트를 관리하는 데 걸린 시간
        - `st`: 이 VM으로부터 하이퍼바이저(호스트)가 빼앗아간 시간  
    
    <br>

    - `nice [NUMBER] [FILE]`: FILE의 우선순위 설정
        - -20 ~ 19 까지 사이의 값으로 우선순위를 부여한다.
        - 숫자가 커질 수록 다른프로세스에게 양보하며, 작을수록 해당 프로세스는 다른 프로세스에 신경을 쓰지않고 자기에게 필요한 리소스를 모두 사용하게된다.


<br>

> **메모리 상태 평가하기**
- `free [OPTION]` 
    - `-h` : 메모리 크기를 바이트 단위가 아닌 사람이 읽기 쉬운 단위(KB, MB, GB 등)으로 출력
- `vmstat [INTERVAL] [TIME]`: 시스템이 스왑하는 메모리를 확인 할 수 있다.
    - `vmstat 30 4`: 30초 간격으로 4번 읽어라.
    - 메모리와 스왑 장치 간에 데이터가 꾸준히 이동한다면 성능 문제가 없더라도 램 추가를 고려해야한다.


<br>

> **스토리지 가용성**

*물리적인 공간만이 리눅스의 데이터 저장 장치를 제한하는 것은 아니다. inode의 개수가 제한되어 있고 물리적인 공간이 남아있어도 inode의 개수가 먼저 소진 될 수 있다.*
- `df [OPTION]`: 디스크의 남은 공간을 확인 할 수 있다.
    - `-h`: 사람이 읽기 쉬운 단위(KB, MB, GB 등)으로 출력
    - `-i`: inode 데이터를 출력한다.
        - inode의 사용률의 최대치에서 10~20%정도 남아있다면 조치를 취해야한다.
<br>
    - `inode` 가 부족 할 경우 유용한 커맨드
    - `find . -xdev -type f | cut -d "/" -f 2 | uniq -c | sort -n`
        - `.`: 현재 디렉토리에서 아래로 내려가면서 탐색한다.
        - `-xdev`: 현재 장치 안에서만 검색한다.
        - `-type -f`: file 형태의 개체를 검색한다.
        - `cut -d "/"`: 구분 문자(여기서는 `/`) 사이의 텍스트를 제거한다.
        - `-f 2`: 찾아낸 항목에서 두 번째 필드를 선택한다.
        - `sort`: 찾아낸 항목들을 정렬하고 표준 출력장치(stdout)으로 보낸다.
        - `uniq -c`: sort가 보낸 항몰들의 줄 수를 센다.
        - `sort -n`: 메시지 숫자 순서대로 출력한다.

- 해결책
    - 우분투 
        - `dpkg --configure -a`: 필요없는 파일을 안전하게 삭제한다.
        - `apt autoremove`: 예전 커널 헤더 자체를 삭제한다.

    <br>

    - CentOS
    
        *`yum-utils` 패키지를 설치하고 `pakage-cleanup` 명령을 수행한다.*
        - `pakage-cleanup --oldkernels --count=2`: 최신 커널 두 개만 남기고 모두 삭제한다.

<br>

> **네트워크 부하**

*네트워크 부하가 용량을 넘었는지 의심을 해야할 때는 일반적인 데스크탑에서 내려받는 시간이 정상적인 경우보다 오래걸리거나 실패할 경우, 외부용 서버에서는 고객이 서비스 속도가 느리다고 불평할 때이다.*

- 대역폭 측정

    *`iftop` 패키지를 설치하여 `iftop` 을 사용한다. `iftop`은 네트워크 인터페이스를 통과하는 활동이 가장 많은 리소스를 계속 업데이트하면서 보여준다.*
- `iftop [OPTION] eth0`: 컴퓨터와 원격 호스트 간의 네트워크 연결과 이 연결이 사용하는 대역폭을 나열한다. 연결은 인바운드/아웃바운드 쌍으로 나열된다.
    - `iftop` 은 원격 호스트 관점에서 네트워크 사용량을 분석하기에 좋다.(웹 브라우저  트래픽 문제 해결 등)
    - `PID` 로 로컬 프로세스를 관리해야할 경우에는 `iftop` 보다는 `NetHogs`(nethogs 패키지 설치)를 사용하여 관리한다.
        > NetHogs
        - `nethogs eth0`
        - 네트워크 인터페이스를 지정해 nethogs 명령을 실행한다.
        - 리눅스용 스택 클라이언트와 크롬 브라우저의 PID를 보여준다. 무엇인가 비정상적으로 작동하면 원인을 찾아 내고 PID로 프로세스를 제어 할 수 있다.
    
    <br>

    - 네트워크에서 예기치 않게 누수되는 트래픽들을 발견 할 수 있으며, 심지어는 숨어 있던 악성 코드가 해커에게 연결되는 것도 `iftop` 이 잡아 낼 수 있다.

<br>

- 해결책
    - 트래픽 셰이핑(traffic shaping): 특정 서비스를 완전히 종료하는 대신 프로세스에 대역폭 상한선을 지정하는 방법으로 대역폭을 관리할 수 있어 한정된 대역폭을 시스템 전반에 전략적으로 분배 할 수 있다. <br>

        *pinh을 통해 확인(전, 후) 할 수 있다.*

    - `tc qdisc add dev eth0 root netem delay 100ms`: 각 패킷을 100ms 지연해 다른 프로세스들이 대역폭을 더 많이 공유하도록 한다.
    - `tc qdisc del dev eth0 root`: 규칙을 삭제한다.